<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    <title>Linux入门教程 | Peony7的博客乐园</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="">
    <meta name="description" content="Linux是一个多用户多任务操作系统，不但被很多开发者用作个人操作系统，还大量运行在Web服务器上。该教程将带你快速了解Linux系统，包括基本概念、Linux命令、Shell脚本、常用工具等。该教程可以让你快速入门快速上手，能很快让你看到学习的效果；如果你希望深入研究Linux，成为大师，请阅读《鸟哥的Lunix私房菜》。阅读该教程之前，最好对操作系统有所了解，请查看计算机操作系统教程自行学习。">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux入门教程">
<meta property="og:url" content="http://yoursite.com/2017/07/05/linux-base/index.html">
<meta property="og:site_name" content="Peony7的博客乐园">
<meta property="og:description" content="Linux是一个多用户多任务操作系统，不但被很多开发者用作个人操作系统，还大量运行在Web服务器上。该教程将带你快速了解Linux系统，包括基本概念、Linux命令、Shell脚本、常用工具等。该教程可以让你快速入门快速上手，能很快让你看到学习的效果；如果你希望深入研究Linux，成为大师，请阅读《鸟哥的Lunix私房菜》。阅读该教程之前，最好对操作系统有所了解，请查看计算机操作系统教程自行学习。">
<meta property="og:image" content="http://yoursite.com/hexo-blog//2017/07/05/linux-base/linux1816.png">
<meta property="og:image" content="http://yoursite.com/hexo-blog//2017/07/05/linux-base/linux25807.png">
<meta property="og:image" content="http://yoursite.com/hexo-blog//2017/07/05/linux-base/linux36302.png">
<meta property="og:image" content="http://yoursite.com/hexo-blog//2017/07/05/linux-base/linux36302.png">
<meta property="og:image" content="http://yoursite.com/hexo-blog//2017/07/05/linux-base/linux43471.png">
<meta property="og:image" content="http://yoursite.com/hexo-blog//2017/07/05/linux-base/linux43471.png">
<meta property="og:updated_time" content="2017-07-06T02:09:04.437Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux入门教程">
<meta name="twitter:description" content="Linux是一个多用户多任务操作系统，不但被很多开发者用作个人操作系统，还大量运行在Web服务器上。该教程将带你快速了解Linux系统，包括基本概念、Linux命令、Shell脚本、常用工具等。该教程可以让你快速入门快速上手，能很快让你看到学习的效果；如果你希望深入研究Linux，成为大师，请阅读《鸟哥的Lunix私房菜》。阅读该教程之前，最好对操作系统有所了解，请查看计算机操作系统教程自行学习。">
<meta name="twitter:image" content="http://yoursite.com/hexo-blog//2017/07/05/linux-base/linux1816.png">
    
        <link rel="alternate" type="application/atom+xml" title="Peony7的博客乐园" href="/hexo-blog/atom.xml">
    
    <link rel="shortcut icon" href="/hexo-blog/favicon.ico">
    <link rel="stylesheet" href="/hexo-blog/css/style.css?v=1.6.5">
    <script>window.lazyScripts=[]</script>
</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/hexo-blog/img/brand.jpg)">
      <div class="brand">
        <a href="/hexo-blog/" class="avatar waves-effect waves-circle waves-light">
          <img src="/hexo-blog/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Peony7</h5>
          <a href="mailto:990313204@qq.com" title="990313204@qq.com" class="mail">990313204@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/hexo-blog/"  >
                <i class="icon icon-lg icon-home"></i>
                Home
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/hexo-blog/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/hexo-blog/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/hexo-blog/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/Peony7" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Linux入门教程</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Linux入门教程</h1>
        <h5 class="subtitle">
            
                <time datetime="2017-07-04T16:00:00.000Z" itemprop="datePublished" class="page-time">
  2017-07-05
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Linux简介"><span class="post-toc-number">1.</span> <span class="post-toc-text">Linux简介**</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Linux简介-1"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">Linux简介**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Linux版本"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">Linux版本**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Linux体系结构"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">Linux体系结构**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#系统启动（开机）"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">系统启动（开机）**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#登录Linux"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">登录Linux**</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#登录步骤："><span class="post-toc-number">1.5.0.1.</span> <span class="post-toc-text">登录步骤：**</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#修改密码"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">修改密码**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#查看目录和文件"><span class="post-toc-number">1.7.</span> <span class="post-toc-text">查看目录和文件**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#查看当前用户信息"><span class="post-toc-number">1.8.</span> <span class="post-toc-text">查看当前用户信息**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#查看当前在线用户"><span class="post-toc-number">1.9.</span> <span class="post-toc-text">查看当前在线用户**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#退出登录"><span class="post-toc-number">1.10.</span> <span class="post-toc-text">退出登录**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#关闭系统（关机）"><span class="post-toc-number">1.11.</span> <span class="post-toc-text">关闭系统（关机）**</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Linux文件管理"><span class="post-toc-number">2.</span> <span class="post-toc-text">Linux文件管理**</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-普通文件"><span class="post-toc-number">2.0.0.1.</span> <span class="post-toc-text">1) 普通文件**</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-目录"><span class="post-toc-number">2.0.0.2.</span> <span class="post-toc-text">2) 目录**</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-设备文件"><span class="post-toc-number">2.0.0.3.</span> <span class="post-toc-text">3) 设备文件**</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#查看文件"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">查看文件**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#元字符"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">元字符**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#隐藏文件"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">隐藏文件**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#创建文件"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">创建文件**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#编辑文件"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">编辑文件**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#查看文件内容"><span class="post-toc-number">2.6.</span> <span class="post-toc-text">查看文件内容**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#统计单词数目"><span class="post-toc-number">2.7.</span> <span class="post-toc-text">统计单词数目**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#复制文件"><span class="post-toc-number">2.8.</span> <span class="post-toc-text">复制文件**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#重命名文件"><span class="post-toc-number">2.9.</span> <span class="post-toc-text">重命名文件**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#删除文件"><span class="post-toc-number">2.10.</span> <span class="post-toc-text">删除文件**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#标准的Linux流"><span class="post-toc-number">2.11.</span> <span class="post-toc-text">标准的Linux流**</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Linux目录"><span class="post-toc-number">3.</span> <span class="post-toc-text">Linux目录**</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#主目录"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">主目录**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#绝对路径和相对路径"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">绝对路径和相对路径**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#创建目录"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">创建目录**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#创建父目录"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">创建父目录**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#删除目录"><span class="post-toc-number">3.5.</span> <span class="post-toc-text">删除目录**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#改变所在目录"><span class="post-toc-number">3.6.</span> <span class="post-toc-text">改变所在目录**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#重命名目录"><span class="post-toc-number">3.7.</span> <span class="post-toc-text">重命名目录**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#点号"><span class="post-toc-number">3.8.</span> <span class="post-toc-text">点号(.)**</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Linux文件权限和访问模式"><span class="post-toc-number">4.</span> <span class="post-toc-text">Linux文件权限和访问模式**</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#查看文件权限"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">查看文件权限**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#文件访问模式"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">文件访问模式**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#目录访问模式"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">目录访问模式**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#改变权限"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">改变权限**</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#使用符号表示权限"><span class="post-toc-number">4.4.0.1.</span> <span class="post-toc-text">使用符号表示权限**</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#使用数字表示权限"><span class="post-toc-number">4.4.0.2.</span> <span class="post-toc-text">使用数字表示权限**</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#更改所有者和用户组"><span class="post-toc-number">4.5.</span> <span class="post-toc-text">更改所有者和用户组**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#SUID和SGID位"><span class="post-toc-number">4.6.</span> <span class="post-toc-text">SUID和SGID位**</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Linux环境变量"><span class="post-toc-number">5.</span> <span class="post-toc-text">Linux环境变量**</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#profile文件"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">.profile文件**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#设置终端类型"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">设置终端类型**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#设置PATH变量"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">设置PATH变量**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#PS1和PS2变量"><span class="post-toc-number">5.4.</span> <span class="post-toc-text">PS1和PS2变量**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#常用环境变量"><span class="post-toc-number">5.5.</span> <span class="post-toc-text">常用环境变量**</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Linux打印文件和发送邮件"><span class="post-toc-number">6.</span> <span class="post-toc-text">Linux打印文件和发送邮件**</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#文件打印"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">文件打印**</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#pr命令"><span class="post-toc-number">6.1.0.1.</span> <span class="post-toc-text">pr命令**</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#lp和lpr命令"><span class="post-toc-number">6.1.0.2.</span> <span class="post-toc-text">lp和lpr命令**</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#lpstat-和-lpq-命令"><span class="post-toc-number">6.1.0.3.</span> <span class="post-toc-text">lpstat 和 lpq 命令**</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#cancel-和-lprm-命令"><span class="post-toc-number">6.1.0.4.</span> <span class="post-toc-text">cancel 和 lprm 命令**</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#发送邮件"><span class="post-toc-number">6.2.</span> <span class="post-toc-text">发送邮件**</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Linux管道和过滤器"><span class="post-toc-number">7.</span> <span class="post-toc-text">Linux管道和过滤器**</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#grep命令"><span class="post-toc-number">7.1.</span> <span class="post-toc-text">grep命令**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#sort命令"><span class="post-toc-number">7.2.</span> <span class="post-toc-text">sort命令**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#pg和more命令"><span class="post-toc-number">7.3.</span> <span class="post-toc-text">pg和more命令**</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Linux进程管理"><span class="post-toc-number">8.</span> <span class="post-toc-text">Linux进程管理**</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#创建进程"><span class="post-toc-number">8.1.</span> <span class="post-toc-text">创建进程**</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#前台进程"><span class="post-toc-number">8.1.0.1.</span> <span class="post-toc-text">前台进程**</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#后台进程"><span class="post-toc-number">8.1.0.2.</span> <span class="post-toc-text">后台进程**</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#查看正在运行的进程"><span class="post-toc-number">8.2.</span> <span class="post-toc-text">查看正在运行的进程**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#终止进程"><span class="post-toc-number">8.3.</span> <span class="post-toc-text">终止进程**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#父进程和子进程"><span class="post-toc-number">8.4.</span> <span class="post-toc-text">父进程和子进程**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#僵尸进程和孤儿进程"><span class="post-toc-number">8.5.</span> <span class="post-toc-text">僵尸进程和孤儿进程**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#常驻进程"><span class="post-toc-number">8.6.</span> <span class="post-toc-text">常驻进程**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#top命令"><span class="post-toc-number">8.7.</span> <span class="post-toc-text">top命令**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#任务和进程"><span class="post-toc-number">8.8.</span> <span class="post-toc-text">任务和进程**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#前台任务和后台任务的切换"><span class="post-toc-number">8.9.</span> <span class="post-toc-text">前台任务和后台任务的切换**</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Linux网络通信工具"><span class="post-toc-number">9.</span> <span class="post-toc-text">Linux网络通信工具**</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#ping-命令"><span class="post-toc-number">9.1.</span> <span class="post-toc-text">ping 命令**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#ftp-工具"><span class="post-toc-number">9.2.</span> <span class="post-toc-text">ftp 工具**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#telnet工具"><span class="post-toc-number">9.3.</span> <span class="post-toc-text">telnet工具**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#finger工具"><span class="post-toc-number">9.4.</span> <span class="post-toc-text">finger工具**</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#10分钟掌握Linux-vi编辑器常见命令的使用，最简单的vi编辑器教程"><span class="post-toc-number">10.</span> <span class="post-toc-text">10分钟掌握Linux vi编辑器常见命令的使用，最简单的vi编辑器教程**</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#进入-vi-编辑器"><span class="post-toc-number">10.1.</span> <span class="post-toc-text">进入 vi 编辑器**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#工作模式"><span class="post-toc-number">10.2.</span> <span class="post-toc-text">工作模式**</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-普通模式"><span class="post-toc-number">10.2.0.1.</span> <span class="post-toc-text">1) 普通模式**</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-编辑模式"><span class="post-toc-number">10.2.0.2.</span> <span class="post-toc-text">2) 编辑模式**</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-命令模式"><span class="post-toc-number">10.2.0.3.</span> <span class="post-toc-text">3) 命令模式**</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#退出-vi-编辑器"><span class="post-toc-number">10.3.</span> <span class="post-toc-text">退出 vi 编辑器**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#移动光标"><span class="post-toc-number">10.4.</span> <span class="post-toc-text">移动光标**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#控制命令"><span class="post-toc-number">10.5.</span> <span class="post-toc-text">控制命令**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#编辑文件-1"><span class="post-toc-number">10.6.</span> <span class="post-toc-text">编辑文件**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#删除字符"><span class="post-toc-number">10.7.</span> <span class="post-toc-text">删除字符**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#修改文本"><span class="post-toc-number">10.8.</span> <span class="post-toc-text">修改文本**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#粘贴复制"><span class="post-toc-number">10.9.</span> <span class="post-toc-text">粘贴复制**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#高级命令"><span class="post-toc-number">10.10.</span> <span class="post-toc-text">高级命令**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#文本查找"><span class="post-toc-number">10.11.</span> <span class="post-toc-text">文本查找**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#set-命令"><span class="post-toc-number">10.12.</span> <span class="post-toc-text">set 命令**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#运行命令"><span class="post-toc-number">10.13.</span> <span class="post-toc-text">运行命令**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#文本替换"><span class="post-toc-number">10.14.</span> <span class="post-toc-text">文本替换**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#几点提示"><span class="post-toc-number">10.15.</span> <span class="post-toc-text">几点提示**</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Linux文件系统"><span class="post-toc-number">11.</span> <span class="post-toc-text">Linux文件系统**</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#分区与目录"><span class="post-toc-number">11.1.</span> <span class="post-toc-text">分区与目录**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#常用文件管理命令"><span class="post-toc-number">11.2.</span> <span class="post-toc-text">常用文件管理命令**</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#df命令"><span class="post-toc-number">11.2.0.1.</span> <span class="post-toc-text">df命令**</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#du-命令"><span class="post-toc-number">11.2.0.2.</span> <span class="post-toc-text">du 命令**</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#挂载文件系统"><span class="post-toc-number">11.3.</span> <span class="post-toc-text">挂载文件系统**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#用户和群组配额"><span class="post-toc-number">11.4.</span> <span class="post-toc-text">用户和群组配额**</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Linux文件存储结构，包括目录项、inode、数据块"><span class="post-toc-number">12.</span> <span class="post-toc-text">Linux文件存储结构，包括目录项、inode、数据块**</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#先说inode"><span class="post-toc-number">12.1.</span> <span class="post-toc-text">先说inode**</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#inode的大小"><span class="post-toc-number">12.1.0.1.</span> <span class="post-toc-text">inode的大小**</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#inode号码"><span class="post-toc-number">12.1.0.2.</span> <span class="post-toc-text">inode号码**</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#目录项"><span class="post-toc-number">12.2.</span> <span class="post-toc-text">目录项**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#硬链接和软链接"><span class="post-toc-number">12.3.</span> <span class="post-toc-text">硬链接和软链接**</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#硬链接"><span class="post-toc-number">12.3.0.1.</span> <span class="post-toc-text">硬链接**</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#软链接"><span class="post-toc-number">12.3.0.2.</span> <span class="post-toc-text">软链接**</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Linux用户管理"><span class="post-toc-number">13.</span> <span class="post-toc-text">Linux用户管理**</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#与用户和组有关的系统文件"><span class="post-toc-number">13.1.</span> <span class="post-toc-text">与用户和组有关的系统文件**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#管理用户和组"><span class="post-toc-number">13.2.</span> <span class="post-toc-text">管理用户和组**</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#创建用户组"><span class="post-toc-number">13.2.0.1.</span> <span class="post-toc-text">创建用户组**</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#修改用户组"><span class="post-toc-number">13.2.0.2.</span> <span class="post-toc-text">修改用户组**</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#删除用户组"><span class="post-toc-number">13.2.0.3.</span> <span class="post-toc-text">删除用户组**</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#添加用户"><span class="post-toc-number">13.2.0.4.</span> <span class="post-toc-text">添加用户**</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#修改用户"><span class="post-toc-number">13.2.0.5.</span> <span class="post-toc-text">修改用户**</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#删除用户"><span class="post-toc-number">13.2.0.6.</span> <span class="post-toc-text">删除用户**</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Linux系统性能分析"><span class="post-toc-number">14.</span> <span class="post-toc-text">Linux系统性能分析**</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Linux系统日志及日志分析"><span class="post-toc-number">15.</span> <span class="post-toc-text">Linux系统日志及日志分析**</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#日志类型"><span class="post-toc-number">15.0.1.</span> <span class="post-toc-text">日志类型**</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#日志优先级"><span class="post-toc-number">15.0.2.</span> <span class="post-toc-text">日志优先级**</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#常见日志文件"><span class="post-toc-number">15.0.3.</span> <span class="post-toc-text">常见日志文件**</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#etc-syslog-conf-文件"><span class="post-toc-number">15.0.4.</span> <span class="post-toc-text">/etc/syslog.conf 文件**</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#logger-命令"><span class="post-toc-number">15.0.5.</span> <span class="post-toc-text">logger 命令**</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#日志转储"><span class="post-toc-number">15.0.6.</span> <span class="post-toc-text">日志转储**</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Linux信号机制与信号处理"><span class="post-toc-number">16.</span> <span class="post-toc-text">Linux信号机制与信号处理**</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#信号种类"><span class="post-toc-number">16.1.</span> <span class="post-toc-text">信号种类**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#发送信号"><span class="post-toc-number">16.2.</span> <span class="post-toc-text">发送信号**</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#捕获信号"><span class="post-toc-number">16.3.</span> <span class="post-toc-text">捕获信号**</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-清理临时文件"><span class="post-toc-number">16.3.0.1.</span> <span class="post-toc-text">1) 清理临时文件**</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-忽略信号"><span class="post-toc-number">16.3.0.2.</span> <span class="post-toc-text">2) 忽略信号**</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-恢复默认动作"><span class="post-toc-number">16.3.0.3.</span> <span class="post-toc-text">3) 恢复默认动作**</span></a></li></ol></li></ol></li></ol></li></ol>
        </nav>
    </aside>
    
<article id="post-linux-base"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Linux入门教程</h1>
        <div class="post-meta">
            <time class="post-time" title="2017-07-05 00:00:00" datetime="2017-07-04T16:00:00.000Z"  itemprop="datePublished">2017-07-05</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>Linux是一个多用户多任务操作系统，不但被很多开发者用作个人操作系统，还大量运行在Web服务器上。<br>该教程将带你快速了解Linux系统，包括基本概念、Linux命令、Shell脚本、常用工具等。<br>该教程可以让你快速入门快速上手，能很快让你看到学习的效果；如果你希望深入研究Linux，成为大师，请阅读《鸟哥的Lunix私房菜》。<br>阅读该教程之前，最好对操作系统有所了解，请查看<a href="http://c.biancheng.net/cpp/u/xitong/" target="_blank" rel="external">计算机操作系统教程</a>自行学习。<br>学习过程中，会涉及到Linux命令和Shell脚本，如果不希望在本地搭建学习环境，那么可以在线免费体验：<a href="http://compileonline.com/" target="_blank" rel="external">compileonline.com</a><br>Linux有大量的命令，教程中没有一一详解，如果遇到困难，可以随时查看在线手册：<a href="http://man.linuxde.net/" target="_blank" rel="external">http://man.linuxde.net/</a><br>注意：Linux 是一个类似 Unix 的操作系统，Unix 是闭源收费的，Linux 是开源免费的，Unix 要早于 Linux，所以 Linux 的开发者也模仿了 Unix（但并没有包括Unix源码），使得Linux在外观和操作上与 Unix 非常相似。</p>
<h1 id="Linux简介"><a href="#Linux简介" class="headerlink" title="Linux简介**"></a><strong>Linux简介<em>**</em></strong></h1><h2 id="Linux简介-1"><a href="#Linux简介-1" class="headerlink" title="Linux简介**"></a><strong>Linux简介<em>**</em></strong></h2><p>严格的来讲，Linux 不算是一个操作系统，只是一个 Linux 系统中的<strong>内核</strong>，即计算机软件与硬件通讯之间的平台；Linux的全称是GNU/Linux，这才算是一个真正意义上的Linux系统。GNU是Richard Stallman组织的一个项目，世界各地的程序员可以变形GNU程序，同时遵循GPL协议，允许任何人任意改动。但是，修改后的程序必须遵循GPL协议。<br>Linux 是一个多用户多任务的操作系统，也是一款自由软件，完全兼容POSIX标准，拥有良好的用户界面，支持多种处理器架构，移植方便。<br>为程序分配系统资源，处理计算机内部细节的软件叫做操作系统或者内核。如果你希望详细了解操作系统的概念，请查看<a href="http://c.biancheng.net/cpp/u/xitong/" target="_blank" rel="external">操作系统教程</a>。<br>用户通过Shell与Linux内核交互。Shell是一个命令行解释工具（是一个软件），它将用户输入的命令转换为内核能够理解的语言（命令）。<br>Linux下，很多工作都是通过命令完成的，学好Linux，首先要掌握常用命令。</p>
<h2 id="Linux版本"><a href="#Linux版本" class="headerlink" title="Linux版本**"></a><strong>Linux版本<em>**</em></strong></h2><p>内核版本指的是在 Linus 领导下的开发小组开发出的系统内核的版本号。Linux 的每个内核版本使用形式为 x.y.zz-www 的一组数字来表示。其中：</p>
<p>· x.y：为linux的主版本号。通常y若为奇数，表示此版本为测试版，系统会有较多bug，主要用途是提供给用户测试。<br>· zz：为次版本号。<br>· www：代表发行号（注意，它与发行版本号无关）。<br>当内核功能有一个飞跃时，主版本号升级，如 Kernel2.2、2.4、2.6等。如果内核增加了少量补丁时，常常会升级次版本号，如Kernel2.6.15、2.6.20等。</p>
<p>一些组织或厂家将 Linux 内核与GNU软件（系统软件和工具）整合起来，并提供一些安装界面和系统设定与管理工具，这样就构成了一个发型套件，例如Ubuntu、Red Hat、Centos、Fedora、SUSE、Debian、FreeBSD等。相对于内核版本，发行套件的版本号随着发布者的不同而不同，与系统内核的版本号是相对独立的。因此把Red Hat等直接说成是Linux是不确切的，它们是Linux的发行版本，更确切地说，应该叫做“以linux为核心的操作系统软件包”。</p>
<h2 id="Linux体系结构"><a href="#Linux体系结构" class="headerlink" title="Linux体系结构**"></a><strong>Linux体系结构<em>**</em></strong></h2><p>下面是Linux体系结构的示意图：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/hexo-blog//2017/07/05/linux-base/linux1816.png" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure><br>在所有Linux版本中，都会涉及到以下几个重要概念：</p>
<p>· <strong>内核</strong>：内核是操作系统的核心。内核直接与硬件交互，并处理大部分较低层的任务，如内存管理、进程调度、文件管理等。</p>
<p>· <strong>Shell</strong>：Shell是一个处理用户请求的工具，它负责解释用户输入的命令，调用用户希望使用的程序。</p>
<p>· <strong>命令和工具</strong>：日常工作中，你会用到很多系统命令和工具，如cp、mv、cat和grep等。在Linux系统中，有250多个命令，每个命令都有多个选项；第三方工具也有很多，他们也扮演着重要角色。</p>
<p>· <strong>文件和目录</strong>：Linux系统中所有的数据都被存储到文件中，这些文件被分配到各个目录，构成文件系统。Linux的目录与Windows的文件夹是类似的概念。</p>
<h2 id="系统启动（开机）"><a href="#系统启动（开机）" class="headerlink" title="系统启动（开机）**"></a><strong>系统启动（开机）<em>**</em></strong></h2><p>如果你有一台装有Linux的电脑，通电后系统会自动启动，然后提示你登录系统，只有登录后才能进行其他操作。</p>
<h2 id="登录Linux"><a href="#登录Linux" class="headerlink" title="登录Linux**"></a><strong>登录Linux<em>**</em></strong></h2><p>第一次使用Linux，会看到登录的提示，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">login:</div></pre></td></tr></table></figure>
<h4 id="登录步骤："><a href="#登录步骤：" class="headerlink" title="登录步骤：**"></a><strong>登录步骤：<em>**</em></strong></h4><p>· 登录Linux必须有用户名（用户ID）和密码，如果没有，可以向管理员所要。<br>· 在登录提示处输入用户名并回车；用户名是区分大小写的，输入时要注意。<br>· 然后会提示你输入密码，密码也是区分大小写的。<br>· 如果用户名和密码正确，那么会成功登录，并看到上次登录信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">login : amrood</div><div class="line">amrood&apos;s password:</div><div class="line">Last login: Sun Jun 14 09:32:32 2009 from 62.61.164.73</div><div class="line">$</div></pre></td></tr></table></figure></p>
<p>登录后会出现命令提示符(<code>$</code>)，你可以输入任何命令。下面通过 cal 命令来查看日历：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ cal</div><div class="line">​     June 2009</div><div class="line">Su Mo Tu We Th Fr Sa</div><div class="line">​    1  2  3  4  5  6</div><div class="line">7   8  9 10 11 12 13</div><div class="line">14 15 16 17 18 19 20</div><div class="line">21 22 23 24 25 26 27</div><div class="line">28 29 30</div><div class="line">$</div></pre></td></tr></table></figure></p>
<h2 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码**"></a><strong>修改密码<em>**</em></strong></h2><p>Linux系统通过密码来保证数据和文件的安全，防止黑客破解和攻击。你可以通过以下方法来修改密码：<br>· 输入 password 命令。<br>· 输入你现在使用的密码。<br>· 输入新密码。注意密码不要过于简单，简单的密码往往会为入侵者大开便利之门。<br>· 确认密码，再输入一遍刚才的密码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ passwd</div><div class="line">Changing password for amrood</div><div class="line">(current) Linux password:******</div><div class="line">New Linux password:*******</div><div class="line">Retype new Linux password:*******</div><div class="line">passwd: all authentication tokens updated  successfully</div><div class="line">$</div></pre></td></tr></table></figure></p>
<p>注意：输入的密码是看不到的，只会看到一个占位符(*)。</p>
<h2 id="查看目录和文件"><a href="#查看目录和文件" class="headerlink" title="查看目录和文件**"></a><strong>查看目录和文件<em>**</em></strong></h2><p>在Linux中，所有的数据都被保存在文件中，所有的文件又被分配到不同的目录；目录是一种类似树的结构，称为文件系统。<br>你可以使用 ls 命令来查看当前目录下的文件和目录。下面的例子，使用了 ls 命令的 -l 选项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ ls -l</div><div class="line">total 19621</div><div class="line">drwxrwxr-x  2 amrood amrood      4096 Dec 25 09:59 uml</div><div class="line">-rw-rw-r--  1 amrood amrood      5341 Dec 25 08:38 uml.jpg</div><div class="line">drwxr-xr-x  2 amrood amrood      4096 Feb 15  2006 univ</div><div class="line">drwxr-xr-x  2 root   root        4096 Dec  9  2007 urlspedia</div><div class="line">-rw-r--r--  1 root   root      276480 Dec  9  2007 urlspedia.tar</div><div class="line">drwxr-xr-x  8 root   root        4096 Nov 25  2007 usr</div><div class="line">-rwxr-xr-x  1 root   root        3192 Nov 25  2007 webthumb.php</div><div class="line">-rw-rw-r--  1 amrood amrood     20480 Nov 25  2007 webthumb.tar</div><div class="line">-rw-rw-r--  1 amrood amrood      5654 Aug  9  2007 yourfile.mid</div><div class="line">-rw-rw-r--  1 amrood amrood    166255 Aug  9  2007 yourfile.swf</div><div class="line">$</div></pre></td></tr></table></figure></p>
<p>注意：以<code>d*</code> 开头的为目录，如 uml、univ、urlspedia等；其他的都是文件。</p>
<h2 id="查看当前用户信息"><a href="#查看当前用户信息" class="headerlink" title="查看当前用户信息**"></a><strong>查看当前用户信息<em>**</em></strong></h2><p>登录系统后，如果你希望知道自己的用户名（用户ID），可以使用 whoami 命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ whoami</div><div class="line">amrood</div><div class="line">$</div></pre></td></tr></table></figure></p>
<p>如果你希望了解更多关于当前用户的信息，可以使用 who am i 命令，读者可以自己尝试一下。</p>
<h2 id="查看当前在线用户"><a href="#查看当前在线用户" class="headerlink" title="查看当前在线用户**"></a><strong>查看当前在线用户<em>**</em></strong></h2><p>如果你希望知道当前在线的用户（同时登录到系统的用户），可以使用 users、who 和 w 命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ users</div><div class="line">amrood bablu qadir</div><div class="line">$ who</div><div class="line">amrood ttyp0 Oct 8 14:10 (limbo)</div><div class="line">bablu  ttyp2 Oct 4 09:08 (calliope)</div><div class="line">qadir  ttyp4 Oct 8 12:09 (dent)</div><div class="line">$</div></pre></td></tr></table></figure></p>
<p>w 命令可以看到在线用户的更多信息，读者可以自己尝试。</p>
<h2 id="退出登录"><a href="#退出登录" class="headerlink" title="退出登录**"></a><strong>退出登录<em>**</em></strong></h2><p>完成工作后，你需要退出系统，防止他人使用你的账户。<br>使用 logout 命令即可退出登录，系统会清理有关信息并断开连接。</p>
<h2 id="关闭系统（关机）"><a href="#关闭系统（关机）" class="headerlink" title="关闭系统（关机）**"></a><strong>关闭系统（关机）<em>**</em></strong></h2><p>关系Linux系统可以使用下列命令：<br>| <strong>命令<em>**</em></strong> | <strong>说明<em>**</em></strong>                   |<br>| ———- | —————————- |<br>| halt       | 直接关闭系统                       |<br>| init 0     | 使用预先定义的脚本关闭系统，关闭前可以清理和更新有关信息 |<br>| init 6     | 重新启动系统                       |<br>| poweroff   | 通过断电来关闭系统                    |<br>| reboot     | 重新启动系统                       |<br>| shutdown   | 安全关闭系统                       |<br>注意：一般情况下只有超级用户和root用户（Linux系统中的最高特权用户）才有关闭系统的权限，但是给普通用户赋予相应权限也可以关闭系统。</p>
<h1 id="Linux文件管理"><a href="#Linux文件管理" class="headerlink" title="Linux文件管理**"></a><strong>Linux文件管理<em>**</em></strong></h1><p>Linux中的所有数据都被保存在文件中，所有的文件被分配到不同的目录。目录是一种类似于树的结构，称为文件系统。<br>当你使用Linux时，大部分时间都会和文件打交道，通过本节可以了解基本的文件操作，如创建文件、删除文件、复制文件、重命名文件以及为文件创建链接等。<br>在Linux中，有三种基本的文件类型：</p>
<h4 id="1-普通文件"><a href="#1-普通文件" class="headerlink" title="1) 普通文件**"></a><strong>1) 普通文件<em>**</em></strong></h4><p>普通文件是以字节为单位的数据流，包括文本文件、源码文件、可执行文件等。文本和二进制对Linux来说并无区别，对普通文件的解释由处理该文件的应用程序进行。</p>
<h4 id="2-目录"><a href="#2-目录" class="headerlink" title="2) 目录**"></a><strong>2) 目录<em>**</em></strong></h4><p>目录可以包含普通文件和特殊文件，目录相当于Windows和Mac OS中的文件夹。</p>
<h4 id="3-设备文件"><a href="#3-设备文件" class="headerlink" title="3) 设备文件**"></a><strong>3) 设备文件<em>**</em></strong></h4><p>有些教程中称特殊文件，是一个含义。Linux 与外部设备（例如光驱，打印机，终端，modern等）是通过一种被称为设备文件的文件来进行通信。Linux 输入输出到外部设备的方式和输入输出到一个文件的方式是相同的。Linux 和一个外部设备通讯之前，这个设备必须首先要有一个设备文件存在。<br>例如，每一个终端都有自己的设备文件来供 Linux 写数据（出现在终端屏幕上）和读取数据（用户通过键盘输入）。<br>设备文件和普通文件不一样，设备文件中并不包含任何数据。</p>
<p>设备文件有两种类型：字符设备文件和块设备文件。<br>· 字符设备文件以字母<code>&quot;c&quot;</code>开头。字符设备文件向设备传送数据时，一次传送一个字符。典型的通过字符传送数据的设备有终端、打印机、绘图仪、modern等。字符设备文件有时也被称为”raw”设备文件。<br>· 块设备文件以字母<code>&quot;b&quot;</code>开头。块设备文件向设备传送数据时，先从内存中的buffer中读或写数据，而不是直接传送数据到物理磁盘。磁盘和CD-ROMS既可以使用字符设备文件也可以使用块设备文件。</p>
<h2 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件**"></a><strong>查看文件<em>**</em></strong></h2><p>查看当前目录下的文件和目录可以使用 <strong>ls</strong> 命令，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ls</div><div class="line">bin        hosts  lib     res.03</div><div class="line">ch07       hw1    pub     test_results</div><div class="line">ch07.bak   hw2    res.01  users</div><div class="line">docs       hw3    res.02  work</div></pre></td></tr></table></figure></p>
<p>通过 <strong>ls</strong> 命令的 <strong>-l</strong> 选项，你可以获取更多文件信息，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">$ls -l</div><div class="line">total 1962188</div><div class="line">drwxrwxr-x  2 amrood amrood      4096 Dec 25 09:59 uml</div><div class="line">-rw-rw-r--  1 amrood amrood      5341 Dec 25 08:38 uml.jpg</div><div class="line">drwxr-xr-x  2 amrood amrood      4096 Feb 15  2006 univ</div><div class="line">drwxr-xr-x  2 root   root        4096 Dec  9  2007 urlspedia</div><div class="line">-rw-r--r--  1 root   root      276480 Dec  9  2007 urlspedia.tar</div><div class="line">drwxr-xr-x  8 root   root        4096 Nov 25  2007 usr</div><div class="line">drwxr-xr-x  2    200    300      4096 Nov 25  2007 webthumb-1.01</div><div class="line">-rwxr-xr-x  1 root   root        3192 Nov 25  2007 webthumb.php</div><div class="line">-rw-rw-r--  1 amrood amrood     20480 Nov 25  2007 webthumb.tar</div><div class="line">-rw-rw-r--  1 amrood amrood      5654 Aug  9  2007 yourfile.mid</div><div class="line">-rw-rw-r--  1 amrood amrood    166255 Aug  9  2007 yourfile.swf</div><div class="line">drwxr-xr-x 11 amrood amrood      4096 May 29  2007 zlib-1.2.3</div><div class="line">$</div></pre></td></tr></table></figure></p>
<p>每一列的含义如下：<br>· 第一列：文件类型。<br>· 第二列：表示文件个数。如果是文件，那么就是1；如果是目录，那么就是该目录中文件的数目。<br>· 第三列：文件的所有者，即文件的创建者。<br>· 第四列：文件所有者所在的用户组。在Linux中，每个用户都隶属于一个用户组。<br>· 第五列：文件大小（以字节计）。<br>· 第六列：文件被创建或上次被修改的时间。<br>· 第七列：文件名或目录名。<br>注意：每一个目录都有一个指向它本身的子目录<code>.</code> 和指向它上级目录的子目录<code>..</code>，所以对于一个空目录，第二列应该为 2。</p>
<p>通过 <strong>ls -l</strong> 列出的文件，每一行都是以 a、d、- 或 l 开头，这些字符表示文件类型：<br>| <strong>前缀<em>**</em></strong> | <strong>描述<em>**</em></strong>                               |<br>| ———- | —————————————- |<br>| -          | 普通文件。如文本文件、二进制可执行文件、源代码等。                |<br>| b          | 块设备文件。硬盘可以使用块设备文件。                       |<br>| c          | 字符设备文件。硬盘也可以使用字符设备文件。                    |<br>| d          | 目录文件。目录可以包含文件和其他目录。                      |<br>| l          | 符号链接（软链接）。可以链接任何普通文件，类似于 Windows 中的快捷方式。 |<br>| p          | 具名管道。管道是进程间的一种通信机制。                      |<br>| s          | 用于进程间通信的套接字。                             |<br>提示：通俗的讲软连接就是windows的快捷方式，原来文件删了，快捷方式虽然在但是不起作用了。</p>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符**"></a><strong>元字符<em>**</em></strong></h2><p>元字符是具有特殊含义的字符。<code>*</code> 和 <code>?</code> 都是元字符：<br>· <code>*</code> 可以匹配 0 个或多个任意字符；<br>· <code>?</code> 匹配一个字符。<br>例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ls ch*.doc</div></pre></td></tr></table></figure></p>
<p>可以显示所有以 ch 开头，以<code>.doc</code> 结尾的文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ch01-1.doc   ch010.doc  ch02.doc    ch03-2.doc</div><div class="line">ch04-1.doc   ch040.doc  ch05.doc    ch06-2.doc</div><div class="line">ch01-2.doc ch02-1.doc c</div></pre></td></tr></table></figure></p>
<p>这里，<code>*</code> 匹配任意一个字符。如果你希望显示所有以 <code>.doc</code> 结尾的文件，可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ls *.doc。</div></pre></td></tr></table></figure></p>
<h2 id="隐藏文件"><a href="#隐藏文件" class="headerlink" title="隐藏文件**"></a><strong>隐藏文件<em>**</em></strong></h2><p>隐藏文件的第一个字符为英文句号或点号(<code>.</code>)，Linux程序（包括Shell）通常使用隐藏文件来保存配置信息。<br>下面是一些常见的隐藏文件：<br><code>.profile</code>：Bourne shell (sh) 初始化脚本<br><code>.kshrc</code>：Korn shell (ksh) 初始化脚本<br><code>.cshrc</code>：C shell (csh) 初始化脚本<br><code>.rhosts</code>：Remote shell (rsh) 配置文件</p>
<p>查看隐藏文件需要使用 <strong>ls</strong> 命令的 <strong>-a</strong> 选项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ ls -a</div><div class="line">.         .profile       docs     lib     test_results</div><div class="line">..        .rhosts        hosts    pub     users</div><div class="line">.emacs    bin            hw1      res.01  work</div><div class="line">.exrc     ch07           hw2      res.02</div><div class="line">.kshrc    ch07.bak       hw3      res.03</div><div class="line">$</div></pre></td></tr></table></figure></p>
<p>一个点号(<code>.</code>)表示当前目录，两个点号(<code>..</code>)表示上级目录<br>注意：输入密码时，星号(<code>*</code>)作为占位符，代表你输入的字符个数。</p>
<h2 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件**"></a><strong>创建文件<em>**</em></strong></h2><p>在Linux中，可以使用 vi 编辑器创建一个文本文件，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vi filename</div></pre></td></tr></table></figure></p>
<p>上面的命令会创建文件 filename 并打开，按下 <code>i</code> 键即可进入编辑模式，你可以向文件中写入内容。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">This is Linux file....I created it for the first time.....</div><div class="line">I&apos;m going to save this content in this file.</div></pre></td></tr></table></figure></p>
<p>完成编辑后，可以按 <code>esc</code> 键退出编辑模式，也可以按组合键 <code>Shift + ZZ</code> 完全退出文件。这样，就完成了文件的创建。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ vi filename</div><div class="line">$</div></pre></td></tr></table></figure></p>
<h2 id="编辑文件"><a href="#编辑文件" class="headerlink" title="编辑文件**"></a><strong>编辑文件<em>**</em></strong></h2><p>vi 编辑器可以用来编辑文件。由于篇幅限制，这里仅作简单介绍，将在后面章节进行详细讲解。<br>如下可以打开一个名为 filename 的文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vi filename</div></pre></td></tr></table></figure></p>
<p>当文件被打开后，可以按 <code>i</code> 键进入编辑模式，按照自己的方式编辑文件。如果想移动光标，必须先按 <code>esc</code> 键退出编辑模式，然后使用下面的按键在文件内移动光标：<br>· l 键向右移动<br>· h 键向左移动<br>· k 键向上移动<br>· j 键向下移动</p>
<p>使用上面的按键，可以将光标快速定位到你想编辑的地方。定位好光标后，按 <code>i</code> 键再次进入编辑模式。编辑完成后按 <code>esc</code> 键退出编辑模式或者按组合键<code>Shift+ZZ</code> 退出当前文件。</p>
<h2 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容**"></a><strong>查看文件内容<em>**</em></strong></h2><p>可以使用 <strong>cat</strong> 命令来查看文件内容，下面是一个简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ cat filename</div><div class="line">This is Linux file....I created it for the first time.....</div><div class="line">I&apos;m going to save this content in this file.</div><div class="line">$</div></pre></td></tr></table></figure></p>
<p>可以通过 <strong>cat</strong> 命令的 <strong>-b</strong> 选项来显示行号，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ cat -b filename</div><div class="line">1   This is Linux file....I created it for the first time.....</div><div class="line">2   I&apos;m going to save this content in this file.</div><div class="line">$</div></pre></td></tr></table></figure></p>
<h2 id="统计单词数目"><a href="#统计单词数目" class="headerlink" title="统计单词数目**"></a><strong>统计单词数目<em>**</em></strong></h2><p>可以使用 <strong>wc</strong> 命令来统计当前文件的行数、单词数和字符数，下面是一个简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ wc filename</div><div class="line">2  19 103 filename</div><div class="line">$</div></pre></td></tr></table></figure></p>
<p>每一列的含义如下：<br>· 第一列：文件的总行数<br>· 第二列：单词数目<br>· 第三列：文件的字节数，即文件的大小<br>· 第四列：文件名</p>
<p>也可以一次查看多个文件的内容，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wc filename1 filename2 filename3</div></pre></td></tr></table></figure></p>
<h2 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件**"></a><strong>复制文件<em>**</em></strong></h2><p>可以使用 <strong>cp</strong> 命令来复制文件。<strong>cp</strong> 命令的基本语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cp source_file destination_file</div></pre></td></tr></table></figure></p>
<p>下面的例子将会复制 filename 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cp filename copyfile</div><div class="line">$</div></pre></td></tr></table></figure></p>
<p>现在在当前目录中会多出一个和 filename 一模一样的 copyfile 文件。</p>
<h2 id="重命名文件"><a href="#重命名文件" class="headerlink" title="重命名文件**"></a><strong>重命名文件<em>**</em></strong></h2><p>重命名文件可以使用 <strong>mv</strong> 命令，语法为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mv old_file new_file</div></pre></td></tr></table></figure></p>
<p>下面的例子将会把 filename 文件重命名为 newfile：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ mv filename newfile</div><div class="line">$</div></pre></td></tr></table></figure></p>
<p>现在在当前目录下，只有一个 newfile 文件。<br><strong>mv</strong> 命令其实是一个移动文件的命令，不但可以更改文件的路径，也可以更改文件名。</p>
<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件**"></a><strong>删除文件<em>**</em></strong></h2><p><strong>rm</strong>命令可以删除文件，语法为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rm filename</div></pre></td></tr></table></figure></p>
<p>注意：删除文件是一种危险的行为，因为文件内可能包含有用信息，建议结合 <strong>-i</strong> 选项来使用 <strong>rm</strong> 命令。<br>下面的例子会彻底删除一个文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ rm filename</div><div class="line">$</div></pre></td></tr></table></figure></p>
<p>你也可以一次删除多个文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ rm filename1 filename2 filename3</div><div class="line">$</div></pre></td></tr></table></figure></p>
<h2 id="标准的Linux流"><a href="#标准的Linux流" class="headerlink" title="标准的Linux流**"></a><strong>标准的Linux流<em>**</em></strong></h2><p>一般情况下，每个Linux程序运行时都会创建三个文件流（三个文件）：<br>· 标准输入流(stdin)：stdin的文件描述符为0，Linux程序默认从stdin读取数据。<br>· 标准输出流(stdout)：stdout 的文件描述符为1，Linux程序默认向stdout输出数据。<br>· 标准错误流(stderr)：stderr的文件描述符为2，Linux程序会向stderr流中写入错误信息。</p>
<h1 id="Linux目录"><a href="#Linux目录" class="headerlink" title="Linux目录**"></a><strong>Linux目录<em>**</em></strong></h1><p>目录也是一个文件，它的唯一功能是用来保存文件及其相关信息。所有的文件，包括普通文件、设备文件和目录文件，都会被保存到目录中。</p>
<h2 id="主目录"><a href="#主目录" class="headerlink" title="主目录**"></a><strong>主目录<em>**</em></strong></h2><p>登录后，你所在的位置就是你的主目录（或登录目录），接下来你主要是在这个目录下进行操作，如创建文件、删除文件等。<br>使用下面的命令可以随时进入主目录：<br>$cd ~<br>$<br>这里 ~ 就表示主目录。如果你希望进入其他用户的主目录，可以使用下面的命令：<br>$cd ~username<br>$<br>返回进入当前目录前所在的目录可以使用下面的命令：<br>$cd -<br>$</p>
<h2 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径**"></a><strong>绝对路径和相对路径<em>**</em></strong></h2><p>Linux 的目录有清晰的层次结构，/ 代表根目录，所有的目录都位于 / 下面；文件在层次结构中的位置可以用路径来表示。<br>如果一个路径以 / 开头，就称为绝对路径；它表示当前文件与根目录的关系。举例如下：<br>/etc/passwd<br>/users/sjones/chem/notes<br>/dev/rdsk/Os3<br>不以 / 开头的路径称为相对路径，它表示文件与当前目录的关系。例如：<br>chem/notes<br>personal/res<br>获取当前所在的目录可以使用 pwd 命令：<br>$pwd<br>/user0/home/amrood<br>$<br>查看目录中的文件可以使用 <strong>ls</strong> 命令：<br>$ls dirname<br>下面的例子将遍历 /usr/local 目录下的文件：<br>$ls /usr/local<br>X11       bin          gimp       jikes       sbin<br>ace       doc          include    lib         share<br>atalk     etc          info       man         ami</p>
<h2 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录**"></a><strong>创建目录<em>**</em></strong></h2><p>可以使用 <strong>mkdir</strong> 命令来创建目录，语法为：<br>$mkdir dirname<br>dirname 可以为绝对路径，也可以为相对路径。例如<br>$mkdir mydir<br>$<br>会在当前目录下创建 mydir 目录。又如<br>$mkdir /tmp/test-dir<br>$<br>会在 /tmp 目录下创建 test-dir 目录。<strong>mkdir</strong> 成功创建目录后不会输出任何信息。<br>也可以使用 <strong>mkdir</strong> 命令同时创建多个目录，例如<br>$mkdir docs pub<br>$<br>会在当前目录下创建 docs 和 pub 两个目录。</p>
<h2 id="创建父目录"><a href="#创建父目录" class="headerlink" title="创建父目录**"></a><strong>创建父目录<em>**</em></strong></h2><p>使用 <strong>mkdir</strong> 命令创建目录时，如果上级目录不存在，就会报错。下面的例子中，mkdir 会输出错误信息：<br>$mkdir /tmp/amrood/test<br>mkdir: Failed to make directory “/tmp/amrood/test”;<br>No such file or directory<br>$<br>为 <strong>mkdir</strong> 命令增加 <strong>-p</strong> 选项，可以一级一级创建所需要的目录，即使上级目录不存在也不会报错。例如<br>$mkdir -p /tmp/amrood/test<br>$<br>会创建所有不存在的上级目录。</p>
<h2 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录**"></a><strong>删除目录<em>**</em></strong></h2><p>可以使用 <strong>rmdir</strong> 命令来删除目录，例如：<br>$rmdir dirname<br>$<br>注意：删除目录时请确保目录为空，不会包含其他文件或目录。<br>也可以使用 <strong>rmdir</strong> 命令同时删除多个目录：<br>$rmdir dirname1 dirname2 dirname3<br>$<br>如果 dirname1、dirname2、dirname3 为空，就会被删除。<strong>rmdir</strong> 成功删除目录后不会输出任何信息。</p>
<h2 id="改变所在目录"><a href="#改变所在目录" class="headerlink" title="改变所在目录**"></a><strong>改变所在目录<em>**</em></strong></h2><p>可以使用 <strong>cd</strong> 命令来改变当前所在目录，进入任何有权限的目录，语法为：<br>$cd dirname<br>dirname 为路径，可以为相对路径，也可以为绝对路径。例如<br>$cd /usr/local/bin<br>$<br>可以进入 /usr/local/bin 目录。可以使用相对路径从这个目录进入 /usr/home/amrood 目录：<br>$cd ../../home/amrood<br>$</p>
<h2 id="重命名目录"><a href="#重命名目录" class="headerlink" title="重命名目录**"></a><strong>重命名目录<em>**</em></strong></h2><p><strong>mv</strong> (move) 命令也可以用来重命名目录，语法为：<br>$mv olddir newdir<br>下面的例子将会把 mydir 目录重命名为 yourdir 目录：<br>$mv mydir yourdir<br>$</p>
<h2 id="点号"><a href="#点号" class="headerlink" title="点号(.)**"></a><strong>点号(.)<em>**</em></strong></h2><p>一个点号(.)表示当前目录，两个点号(..)表示上级目录（父目录）。<br><strong>ls</strong> 命令的 <strong>-a</strong> 选项可以查看所有文件，包括隐藏文件；<strong>-l</strong> 选项可以查看文件的所有信息，共有7列。例如：<br>$ls -la<br>drwxrwxr-x    4    teacher   class   2048  Jul 16 17.56 .<br>drwxr-xr-x    60   root              1536  Jul 13 14:18 ..<br>———-    1    teacher   class   4210  May 1 08:27 .profile<br>-rwxr-xr-x    1    teacher   class   1948  May 12 13:42 memo<br>$</p>
<h1 id="Linux文件权限和访问模式"><a href="#Linux文件权限和访问模式" class="headerlink" title="Linux文件权限和访问模式**"></a><strong>Linux文件权限和访问模式<em>**</em></strong></h1><p>为了更加安全的存储文件，Linux为不同的文件赋予了不同的权限，每个文件都拥有下面三种权限：<br>· 所有者权限：文件所有者能够进行的操作<br>· 组权限：文件所属用户组能够进行的操作<br>· 外部权限（其他权限）：其他用户可以进行的操作。</p>
<h2 id="查看文件权限"><a href="#查看文件权限" class="headerlink" title="查看文件权限**"></a><strong>查看文件权限<em>**</em></strong></h2><p>使用 <strong>ls -l</strong> 命令可以查看与文件权限相关的信息：<br>$ls -l /home/amrood<br>-rwxr-xr–  1 amrood   users 1024  Nov 2 00:10  myfile<br>drwxr-xr— 1 amrood   users 1024  Nov 2 00:10  mydir<br>第一列就包含了文件或目录的权限。<br>第一列的字符可以分为三组，每一组有三个，每个字符都代表不同的权限，分别为读取(r)、写入(w)和执行(x)：<br>· 第一组字符(2-4)表示文件所有者的权限，-rwxr-xr– 表示所有者拥有读取(r)、写入(w)和执行(x)的权限。<br>· 第二组字符(5-7)表示文件所属用户组的权限，-rwxr-xr– 表示该组拥有读取(r)和执行(x)的权限，但没有写入权限。<br>· 第三组字符(8-10)表示所有其他用户的权限，rwxr-xr– 表示其他用户只能读取(r)文件。</p>
<h2 id="文件访问模式"><a href="#文件访问模式" class="headerlink" title="文件访问模式**"></a><strong>文件访问模式<em>**</em></strong></h2><p>文件权限是Linux系统的第一道安全防线，基本的权限有读取(r)、写入(w)和执行(x)：<br>· 读取：用户能够读取文件信息，查看文件内容。<br>· 写入：用户可以编辑文件，可以向文件写入内容，也可以删除文件内容。<br>· 执行：用户可以将文件作为程序来运行。</p>
<h2 id="目录访问模式"><a href="#目录访问模式" class="headerlink" title="目录访问模式**"></a><strong>目录访问模式<em>**</em></strong></h2><p>目录的访问模式和文件类似，但是稍有不同：<br>· 读取：用户可以查看目录中的文件<br>· 写入：用户可以在当前目录中删除文件或创建文件<br>· 执行：执行权限赋予用户遍历目录的权利，例如执行 cd 和 ls 命令。</p>
<h2 id="改变权限"><a href="#改变权限" class="headerlink" title="改变权限**"></a><strong>改变权限<em>**</em></strong></h2><p>可以使用 <strong>chmod</strong> (change mode) 命令来改变文件或目录的访问权限，权限可以使用符号或数字来表示。</p>
<h4 id="使用符号表示权限"><a href="#使用符号表示权限" class="headerlink" title="使用符号表示权限**"></a><strong>使用符号表示权限<em>**</em></strong></h4><p>对于初学者来说最简单的就是使用符号来改变文件或目录的权限，你可以增加(+)和删除(-)权限，也可以指定特定权限。<br>| <strong>符号<em>**</em></strong> | <strong>说明<em>**</em></strong> |<br>| ———- | ———- |<br>| +          | 为文件或目录增加权限 |<br>| -          | 删除文件或目录的权限 |<br>| =          | 设置指定的权限    |<br>下面的例子将会修改 testfile 文件的权限：<br>$ls -l testfile<br>-rwxrwxr–  1 amrood   users 1024  Nov 2 00:10  testfile<br>$chmod o+wx testfile<br>$ls -l testfile<br>-rwxrwxrwx  1 amrood   users 1024  Nov 2 00:10  testfile<br>$chmod u-x testfile<br>$ls -l testfile<br>-rw-rwxrwx  1 amrood   users 1024  Nov 2 00:10  testfile<br>$chmod g=rx testfile<br>$ls -l testfile<br>-rw-r-xrwx  1 amrood   users 1024  Nov 2 00:10  testfile<br>也可以同时使用多个符号：<br>$chmod o+wx,u-x,g=rx testfile<br>$ls -l testfile<br>-rw-r-xrwx  1 amrood   users 1024  Nov 2 00:10  testfile</p>
<h4 id="使用数字表示权限"><a href="#使用数字表示权限" class="headerlink" title="使用数字表示权限**"></a><strong>使用数字表示权限<em>**</em></strong></h4><p>除了符号，也可以使用八进制数字来指定具体权限，如下表所示：<br>| <strong>数字<em>**</em></strong> | <strong>说明<em>**</em></strong>                         | <strong>权限<em>**</em></strong> |<br>| ———- | ———————————- | ———- |<br>| 0          | 没有任何权限                             | —        |<br>| 1          | 执行权限                               | –x        |<br>| 2          | 写入权限                               | -w-        |<br>| 3          | 执行权限和写入权限：1 (执行) + 2 (写入) = 3      | -wx        |<br>| 4          | 读取权限                               | r–        |<br>| 5          | 读取和执行权限：4 (读取) + 1 (执行) = 5        | r-x        |<br>| 6          | 读取和写入权限：4 (读取) + 2 (写入) = 6        | rw-        |<br>| 7          | 所有权限: 4 (读取) + 2 (写入) + 1 (执行) = 7 | rwx        |<br>下面的例子，首先使用 <strong>ls -1</strong> 命令查看 testfile 文件的权限，然后使用 <strong>chmod</strong> 命令更改权限：<br>$ls -l testfile<br>-rwxrwxr–  1 amrood   users 1024  Nov 2 00:10  testfile<br>$ chmod 755 testfile<br>$ls -l testfile<br>-rwxr-xr-x  1 amrood   users 1024  Nov 2 00:10  testfile<br>$chmod 743 testfile<br>$ls -l testfile<br>-rwxr—wx  1 amrood   users 1024  Nov 2 00:10  testfile<br>$chmod 043 testfile<br>$ls -l testfile<br>—-r—wx  1 amrood   users 1024  Nov 2 00:10  testfile</p>
<h2 id="更改所有者和用户组"><a href="#更改所有者和用户组" class="headerlink" title="更改所有者和用户组**"></a><strong>更改所有者和用户组<em>**</em></strong></h2><p>在Linux中，每添加一个新用户，就会为它分配一个用户ID和群组ID，上面提到的文件权限也是基于用户和群组来分配的。<br>有两个命令可以改变文件的所有者或群组：<br>· <strong>chown</strong>：chown 命令是”change owner”的缩写，用来改变文件的所有者。<br>· <strong>chgrp</strong>：chgrp 命令是”change group”的缩写，用来改变文件所在的群组。<br><strong>chown</strong> 命令用来更改文件所有者，其语法如下：<br>$ chown user filelist<br>user 可以是用户名或用户ID，例如<br>$ chown amrood testfile<br>$<br>将 testfile 文件的所有者改为 amrood。<br>注意：超级用户 root 可以不受限制的更改文件的所有者和用户组，但是普通用户只能更改所有者是自己的文件或目录。<br><strong>chgrp</strong> 命令用来改变文件所属群组，其语法为：<br>$ chgrp group filelist<br>group可以是群组名或群组ID，例如<br>$ chgrp special testfile<br>$<br>将文件 testfile 的群组改为 special。</p>
<h2 id="SUID和SGID位"><a href="#SUID和SGID位" class="headerlink" title="SUID和SGID位**"></a><strong>SUID和SGID位<em>**</em></strong></h2><p>在Linux中，一些程序需要特殊权限才能完成用户指定的操作。<br>例如，用户的密码保存在 /etc/shadow 文件中，出于安全考虑，一般用户没有读取和写入的权限。但是当我们使用<strong>passwd</strong> 命令来更改密码时，需要对 /etc/shadow 文件有写入权限。这就意味着，passwd 程序必须要给我们一些特殊权限，才可以向 /etc/shadow 文件写入内容。<br>Linux 通过给程序设置SUID(Set User ID)和SGID(Set Group ID)位来赋予普通用户特殊权限。当我们运行一个带有SUID位的程序时，就会继承该程序所有者的权限；如果程序不带SUID位，则会根据程序使用者的权限来运行。<br>SGID也是一样。一般情况下程序会根据你的组权限来运行，但是给程序设置SGID后，就会根据程序所在组的组权限运行。<br>如果程序设置了SUID位，就会在表示文件所有者可执行权限的位置上出现’s’字母；同样，如果设置了SGID，就会在表示文件群组可执行权限的位置上出现’s’字母。如下所示：<br>$ ls -l /usr/bin/passwd<br>-r-<strong>s</strong>r-xr-x  1   root   bin  19031 Feb 7 13:47  /usr/bin/passwd*<br>$<br>上面第一列第四个字符不是’x’或’-‘，而是’s’，说明 /usr/bin/passwd 文件设置了SUID位，这时普通用户会以root用户的权限来执行passwd程序。<br>注意：小写字母’s’说明文件所有者有执行权限(x)，大写字母’S’说明程序所有者没有执行权限(x)。<br>如果在表示群组权限的位置上出现SGID位，那么也仅有三类用户可以删除该目录下的文件：目录所有者、文件所有者、超级用户 root。<br>为一个目录设置SUID和SGID位可以使用下面的命令：<br>$ chmod ug+s dirname<br>$ ls -l<br>drwsr-sr-x 2 root root  4096 Jun 19 06:45 dirname<br>$</p>
<h1 id="Linux环境变量"><a href="#Linux环境变量" class="headerlink" title="Linux环境变量**"></a><strong>Linux环境变量<em>**</em></strong></h1><p>在Linux中，环境变量是一个很重要的概念。环境变量可以由系统、用户、Shell以及其他程序来设定。<br>变量就是一个可以被赋值的字符串，赋值范围包括数字、文本、文件名、设备以及其他类型的数据。<br>下面的例子，我们将为变量 TEST 赋值，然后使用 <strong>echo</strong> 命令输出：<br>$TEST=”Linux Programming”<br>$echo $TEST<br>Linux Programming<br>注意：变量赋值时前面不能加 $ 符号，变量输出时必须要加 $ 前缀。退出 Shell 时，变量将消失。<br>登录系统后，Shell会有一个初始化的过程，用来设置环境变量。这个阶段，Shell会读取 /etc/profile 和 .profile 两个文件，过程如下：<br>· Shell首先检查 /etc/profile 文件是否存在，如果存在，就读取内容，否则就跳过，但是不会报错。<br>· 然后检查你的主目录（登录目录）中是否存在 .profile 文件，如果存在，就读取内容，否则就跳过，也不会报错。<br>读取完上面两个文件，Shell就会出现 $ 命令提示符：<br>$<br>出现这个提示符，就可以输入命令并调用相应的程序了。<br>注意：上面是Bourne Shell的初始化过程，bash 和 ksh 在初始化过程中还会检查其他文件。</p>
<h2 id="profile文件"><a href="#profile文件" class="headerlink" title=".profile文件**"></a><strong>.profile文件<em>**</em></strong></h2><p>/etc/profile文件包含了通用的Shell初始化信息，由Linux管理员维护，一般用户无权修改。<br>但是你可以修改主目录下的 .profile 文件，增加一些“私人定制”初始化信息，包括：<br>· 设置默认终端类型和外观样式；<br>· 设置 Shell 命令查找路径，即PATH变量；<br>· 设置命令提示符。<br>找到主目录下的 .profile 文件，使用 vi 编辑器打开并查看内容。</p>
<h2 id="设置终端类型"><a href="#设置终端类型" class="headerlink" title="设置终端类型**"></a><strong>设置终端类型<em>**</em></strong></h2><p>一般情况下，我们使用的终端是由 login 或 getty 程序设置的，可能会不符合我们的习惯。<br>对于没有使用过的终端，可能会比较生疏，不习惯命令的输出样式，交互起来略显吃力。所以，一般用户会将终端设置成下面的类型：<br>$TERM=vt100<br>$<br>vt100 是 virtual terminate 100 的缩写。虚拟终端是一种假的终端，真正有自己的显示器和键盘的终端，会通过特殊电缆（如串口）连到计算机主机。vt100 是被绝大多数Linux系统所支持的一种虚拟终端规范，常用的还有ansi、xterm等。</p>
<h2 id="设置PATH变量"><a href="#设置PATH变量" class="headerlink" title="设置PATH变量**"></a><strong>设置PATH变量<em>**</em></strong></h2><p>在命令提示符下输入一个命令时，Shell 会根据 PATH 变量来查找该命令对应的程序，PATH变量指明了这些程序所在的路径。<br>一般情况下PATH变量的设置如下：<br>$PATH=/bin:/usr/bin<br>$<br>多个路径使用冒号(:)分隔。如果用户输入的命令在PATH设置的路径下没有找到，就会报错，例如：<br>$hello<br>hello: not found<br>$</p>
<h2 id="PS1和PS2变量"><a href="#PS1和PS2变量" class="headerlink" title="PS1和PS2变量**"></a><strong>PS1和PS2变量<em>**</em></strong></h2><p>PS1变量用来保存命令提示符，可以随意修改，如果你不习惯使用 $ 作为提示符，也可以改成其他字符。PS1变量被修改后，提示符会立即改变。<br>例如，把命令提示符设置成’=&gt;’：<br>$PS1=’=&gt;’<br>=&gt;<br>=&gt;<br>=&gt;<br>也可以将提示信息设置成当前目录，例如：<br>=&gt;PS1=”[\u@\h \w]\$”<br>[root@ip-72-167-112-17 /var/www/tutorialspoint/Linux]$<br>[root@ip-72-167-112-17 /var/www/tutorialspoint/Linux]$<br>命令提示信息包含了用户名、主机名和当前目录。<br>下表中的转义字符可以被用作PS1的参数，丰富命令提示符信息。<br>| <strong>转义字符<em>**</em></strong> | <strong>描述<em>**</em></strong>                 |<br>| ———— | ————————– |<br>| \t           | 当前时间，格式为 HH:MM:SS          |<br>| \d           | 当前日期，格式为Weekday Month Date |<br>| \n           | 换行                         |<br>| \W           | 当前所在目录                     |<br>| \w           | 当前所在目录的完整路径                |<br>| \u           | 用户名                        |<br>| \h           | 主机名（IP地址）                  |<br>| #            | 输入的命令的个数，每输入一个新的命令就会加1     |<br>| \$           | 如果是超级用户 root，提示符为#，否则为$。   |<br>你可以在每次登录的时候修改提示符，也可以在 .profile 文件中增加 PS1 变量，这样每次登录时会自动修改提示符。<br>如果用户输入的命令不完整，Shell还会使用第二提示符来等待用户完成命令的输入。默认的第二命令提示符是 &gt;，保存在 PS2 变量，可以随意修改。<br>下面的例子使用默认的第二命令提示符：<br>$ echo “this is a<br>> test”<br>this is a<br>test<br>$<br>下面的例子通过PS2变量改变提示符：<br>$ PS2=”secondary prompt-&gt;”<br>$ echo “this is a<br>secondary prompt-&gt;test”<br>this is a<br>test<br>$</p>
<h2 id="常用环境变量"><a href="#常用环境变量" class="headerlink" title="常用环境变量**"></a><strong>常用环境变量<em>**</em></strong></h2><p>下表列出了部分重要的环境变量，这些变量可以通过上面提到的方式修改。<br>| <strong>变量<em>**</em></strong> | <strong>描述<em>**</em></strong>                               |<br>| ———- | —————————————- |<br>| DISPLAY    | 用来设置将图形显示到何处。                            |<br>| HOME       | 当前用户的主目录。                                |<br>| IFS        | 内部域分隔符。                                  |<br>| LANG       | LANG可以让系统支持多语言。例如，将LANG设为pt_BR，则可以支持(巴西)葡萄牙语。 |<br>| PATH       | 指定Shell命令的路径。                            |<br>| PWD        | 当前所在目录，即 cd 到的目录。                        |<br>| RANDOM     | 生成一个介于 0 和 32767 之间的随机数。                 |<br>| TERM       | 设置终端类型。                                  |<br>| TZ         | 时区。可以是AST(大西洋标准时间)或GMT(格林尼治标准时间)等。       |<br>| UID        | 以数字形式表示的当前用户ID，shell启动时会被初始化。            |<br>下面的例子中使用了部分环境变量：<br>$ echo $HOME<br>/root<br>]$ echo $DISPLAY<br>$ echo $TERM<br>xterm<br>$ echo $PATH<br>/usr/local/bin:/bin:/usr/bin:/home/amrood/bin:/usr/local/bin<br>$</p>
<h1 id="Linux打印文件和发送邮件"><a href="#Linux打印文件和发送邮件" class="headerlink" title="Linux打印文件和发送邮件**"></a><strong>Linux打印文件和发送邮件<em>**</em></strong></h1><p>通过前面的介绍，相信你对 Linux 的命令和特性有了一个基本的认识，本节将介绍如果打印文件以及发送邮件。</p>
<h2 id="文件打印"><a href="#文件打印" class="headerlink" title="文件打印**"></a><strong>文件打印<em>**</em></strong></h2><p>如果你希望打印文本文件，最好预先处理一下，包括调整边距、设置行高、设置标题等，这样打印出来的文件更加美观，易于阅读。当然，不处理也可以打印，但是可能会比较丑陋。<br>大部分的Linux自带了 nroff 和 troff 两个强大的文本格式化工具，不过比较老旧，使用的人很少，有兴趣的读者可以可以自行学习，本教程不再进行深入讲解。</p>
<h4 id="pr命令"><a href="#pr命令" class="headerlink" title="pr命令**"></a><strong>pr命令<em>**</em></strong></h4><p><strong>pr</strong> 命令用来将文本文件转换成适合打印的格式，它可以把较大的文件分割成多个页面进行打印，并为每个页面添加标题。<br><strong>pr</strong> 命令的语法如下：<br>pr option(s) filename(s)<br><strong>pr</strong> 命令仅仅改变文件在屏幕上的显示样式和打印输出样式，并不会更改文件本身。下表是 pr 命令的几个选项：<br>| <strong>选项<em>**</em></strong>     | <strong>说明<em>**</em></strong>                   |<br>| ————– | —————————- |<br>| -k             | 分成几列打印，默认为1。                 |<br>| -d             | 两倍行距（并不是所有版本的 pr 都有效）。       |<br>| -h “header”    | 设置每个页面的标题。                   |<br>| -t             | 不打印标题和上下边距。                  |<br>| -l PAGE_LENGTH | 每页显示多少行。默认是每个页面一共66行，文本占56行。 |<br>| -o MARGIN      | 每行缩进的空格数。                    |<br>| -w PAGE_WIDTH  | 多列输出时，设置页面宽度，默认是72个字符。       |<br>例如，food 文件包含了很多食品的名字，使用 pr 命令分成两列打印，并设置每页的标题为“Restaurants”。<br>首先查看文件内容：<br>$cat food<br>Sweet Tooth<br>Bangkok Wok<br>Mandalay<br>Afghani Cuisine<br>Isle of Java<br>Big Apple Deli<br>Sushi and Sashimi<br>Tio Pepe’s Peppers<br>……..<br>$<br>然后使用 <strong>pr</strong> 命令打印：<br>$pr -2 -h “Restaurants” food<br>Nov  7  9:58 1997  Restaurants   Page 1<br>Sweet Tooth              Isle of Java<br>Bangkok Wok              Big Apple Deli<br>Mandalay                 Sushi and Sashimi<br>Afghani Cuisine          Tio Pepe’s Peppers<br>……..<br>$</p>
<h4 id="lp和lpr命令"><a href="#lp和lpr命令" class="headerlink" title="lp和lpr命令**"></a><strong>lp和lpr命令<em>**</em></strong></h4><p><strong>lp</strong> 和 <strong>lpr</strong> 命令将文件传送到打印机进行打印。使用 pr 命令将文件格式化后就可以使用这两个命令来打印。<br>打印机一般由系统管理员来设置，下面的例子使用默认的打印机打印food文件：<br>$lp food<br>request id is laserp-525  (1 file)<br>$<br>命令成功执行会返回一个表示打印任务的ID，通过这个ID可以取消打印或者查看打印状态。<br>如果你希望打印多份文件，可以使用 lp 的 -n<strong>Num</strong> 选项，或者 lpr 命令的 -<strong>Num</strong> 选项。<strong>Num</strong> 是一个数字，可以随意设置。<br>如果系统连接了多台打印机，可以使用 lp 命令的 -d<strong>printer</strong> 选项，或者 lpr 命令的 -P<strong>printer</strong> 选项来选择打印机。<strong>printer</strong> 为打印机名称。</p>
<h4 id="lpstat-和-lpq-命令"><a href="#lpstat-和-lpq-命令" class="headerlink" title="lpstat 和 lpq 命令**"></a><strong>lpstat 和 lpq 命令<em>**</em></strong></h4><p><strong>lpstat</strong> 命令可以查看打印机的缓存队列（有多少个文件等待打印），包括任务ID、所有者、文件大小、请求时间和请求状态。<br>提示：等待打印的文件会被放到打印机的的缓存队列中。<br>例如，使用 <strong>lpstat -o</strong> 命令查看打印机中所有等待打印的文件，包括你自己的：<br>$lpstat -o<br>laserp-573  john  128865  Nov 7  11:27  on laserp<br>laserp-574  grace  82744  Nov 7  11:28<br>laserp-575  john   23347  Nov 7  11:35<br>$<br>lpstat -o 命令按照打印顺序输出队列中的文件。<br><strong>lpq</strong> 命令显示的信息与 lpstat -o 稍有差异：<br>$lpq<br>laserp is ready and printing<br>Rank   Owner      Job  Files                  Total Size<br>active john       573  report.ps              128865 bytes<br>1st    grace      574  ch03.ps ch04.ps        82744 bytes<br>2nd    john       575  standard input         23347 bytes<br>$<br>第一行为打印机的状态。如果打印机无法使用或者纸被用完，将会输出其他信息。</p>
<h4 id="cancel-和-lprm-命令"><a href="#cancel-和-lprm-命令" class="headerlink" title="cancel 和 lprm 命令**"></a><strong>cancel 和 lprm 命令<em>**</em></strong></h4><p><strong>cancel</strong> 和 <strong>lprm</strong> 分别用来终止 lp 和 lpr 的打印请求。使用这两个命令，需要指定ID（由 lp 或 lpq 返回）或打印机名称。<br>例如，通过ID取消打印请求：<br>$cancel laserp-575<br>request “laserp-575” cancelled<br>$<br>如果希望取消正在打印的文件，那么可以不指定ID，仅仅指定打印机名称即可：<br>$cancel laserp<br>request “laserp-573” cancelled<br>$<br>lprm 命令用来取消当前用户的正在等待打印的文件，使用任务号作为参数可以取消指定文件，使用横线(-)作为参数可以取消所有文件。<br>例如，取消575号打印任务：<br>$lprm 575<br>dfA575diamond dequeued<br>cfA575diamond dequeued<br>$<br>lprm 会返回被取消的文件名。</p>
<h2 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件**"></a><strong>发送邮件<em>**</em></strong></h2><p>可以使用<strong>mail</strong>命令发送和接收邮件，语法如下：<br>$mail [-s subject] [-c cc-addr] [-b bcc-addr] to-addr<br>每个选项的含义如下：<br>| <strong>选项<em>**</em></strong> | <strong>描述<em>**</em></strong>                  |<br>| ———- | ————————— |<br>| -s         | 邮件标题。                       |<br>| -c         | 要发送的用户，多个用户以逗号(,)分隔。        |<br>| -b         | 需要密件发送（密送）的用户，多个用户以逗号(,)分隔。 |<br>例如，向admin@yahoo.com发送邮件：<br>$mail -s “Test Message” admin@yahoo.com<br>Hello everyone,<br>this is Linux tutorial and url is <a href="http://see.xidian.edu.cn/cpp/linux/" target="_blank" rel="external">http://see.xidian.edu.cn/cpp/linux/</a>.<br>Cc:<br>第一行是输入的命令，-s表示邮件的主题，后面的admin@yahoo.com则是邮件的接收人，输入完这行命令后回车，会进入邮件正文的编写，你可以输入任何文字，比如上面的两行。输入完邮件正文，需要按CTRL+D结束输入，此时会提示你输入Cc地址，即邮件抄送地址，没有直接回车就完成了邮件的发送。<br>也可以通过重定向操作符 &lt; 来发送文件：<br>$mail -s “Report 05/06/07” admin@yahoo.com &lt; demo.txt<br>通过上面的命令，就可以把demol.txt文件的内容作为邮件的内容发送给admin@yahoo.com了。<br>接收邮件不需要任何参数：<br>$mail<br>no email</p>
<h1 id="Linux管道和过滤器"><a href="#Linux管道和过滤器" class="headerlink" title="Linux管道和过滤器**"></a><strong>Linux管道和过滤器<em>**</em></strong></h1><p>有时候，我们可以把两个命令连起来使用，一个命令的输出作为另一个命令的输入，这就叫做<strong>管道</strong>。为了建立管道，需要在两个命令之间使用竖线(|)连接。<br>管道是Linux进程之间一种重要的通信机制；除了管道，还有共享内存、消息队列、信号、套接字(socket) 等进程通信机制。<br>管道使用竖线(|)将两个命令隔开，竖线左边命令的输出就会作为竖线右边命令的输入。连续使用竖线表示第一个命令的输出会作为第二个命令的输入，第二个命令的输出又会作为第三个命令的输入，依此类推。<br>能够接受数据，过滤（处理或筛选）后再输出的工具，称为<strong>过滤器</strong>。</p>
<h2 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令**"></a><strong>grep命令<em>**</em></strong></h2><p>grep 是一个强大的文本搜索工具，可以使用正则表达式，并返回匹配的行，语法为：<br>$grep pattern file(s)<br>“grep”源于 ed（Linux的一个行文本编辑器）的 g/re/p 命令，g/re/p 是“globally search for a regular expression and print all lines containing it”的缩写，意思是使用正则表达式进行全局检索，并把匹配的行打印出来。<br>正则表达式是一个包含了若干特殊字符的字符串，每个字符都有特殊含义，可以用来匹配文本，更多信息请查看<a href="http://c.biancheng.net/cpp/u/zhengze/" target="_blank" rel="external">正则表达式教程</a>。<br>grep 可以看做是一个过滤器，如果没有为 grep 指定要检索的文件，那么它会从标准输入设备（一般是键盘）读取；其他过滤器也是如此。<br>grep 命令最简单的使用就是检索包含固定字符的文本。<br>例如，在管道中使用 grep 命令，只允许包含指定字符的行输出到显示器：<br>$ls -l | grep “Aug”<br>-rw-rw-rw-   1 john  doc     11008 Aug  6 14:10 ch02<br>-rw-rw-rw-   1 john  doc      8515 Aug  6 15:30 ch07<br>-rw-rw-r–   1 john  doc      2488 Aug 15 10:51 intro<br>-rw-rw-r–   1 carol doc      1605 Aug 23 07:35 macros<br>$<br>grep 命令有很多选项：<br>| <strong>选项<em>**</em></strong> | <strong>说明<em>**</em></strong>                               |<br>| ———- | —————————————- |<br>| -v         | 反转查询，输出不匹配的行。例如，grep -v “test” demo.txt 将输出不包含”test”的行。 |<br>| -n         | 输出匹配的行以及行号。                              |<br>| -l         | 输出匹配的行所在的文件名。                            |<br>| -c         | 输出匹配的总行数。                                |<br>| -i         | 不区分大小写进行匹配。                              |<br>下面我们使用正则表达式来匹配这样的行：包含字符“carol”，然后包含任意数目（含零个）的其他字符，最后还要包含“Aug”。<br>使用 -i 选项进行不区分大小写的匹配：<br>$ls -l | grep -i “carol.*aug”<br>-rw-rw-r–   1 carol doc      1605 Aug 23 07:35 macros<br>$</p>
<h2 id="sort命令"><a href="#sort命令" class="headerlink" title="sort命令**"></a><strong>sort命令<em>**</em></strong></h2><p>sort 命令在 Linux 中非常有用，它将文件中的各行按字母或数进行排序。sort命令既可以从特定的文件，也可以从stdin获取输入。<br>例如，对 foot 文件的各行进行排序：<br>$sort food<br>Afghani Cuisine<br>Bangkok Wok<br>Big Apple Deli<br>Isle of Java<br>Mandalay<br>Sushi and Sashimi<br>Sweet Tooth<br>Tio Pepe’s Peppers<br>$<br>通过下面的选项可以控制排序规则：<br>| <strong>选项<em>**</em></strong> | <strong>描述<em>**</em></strong>                              |<br>| ———- | ————————————— |<br>| -n         | 按照数字大小排序，例如，10会排在2后面；-n 选项会忽略空格或 tab缩进。 |<br>| -r         | 降序排序。sort 默认是升序排序。                      |<br>| -f         | 不区分大小写。                                 |<br>| +x         | 对第x列（从0开始）进行排序。                         |<br>下面的例子通过管道将 ls、grep 和 sort 命令连起来使用，过滤包含“Aug”的行，并按照文件大小排序：<br>$ls -l | grep “Aug” | sort +4n<br>-rw-rw-r–  1 carol doc      1605 Aug 23 07:35 macros<br>-rw-rw-r–  1 john  doc      2488 Aug 15 10:51 intro<br>-rw-rw-rw-  1 john  doc      8515 Aug  6 15:30 ch07<br>-rw-rw-rw-  1 john  doc     11008 Aug  6 14:10 ch02<br>$<br>上面的命令，对当前目录中八月份修改的文件按照大小排序；+4n 表示对第5列按照数字大小排序。</p>
<h2 id="pg和more命令"><a href="#pg和more命令" class="headerlink" title="pg和more命令**"></a><strong>pg和more命令<em>**</em></strong></h2><p>如果文件内容过多，全部显示会很乱，可以使用 <strong>pg</strong> 和 <strong>more</strong> 命令分页显示，每次只显示一屏。<br>例如，通过管道，使用more命令显示目录中的文件：<br>$ls -l | grep “Aug” | sort +4n | more<br>-rw-rw-r–  1 carol doc      1605 Aug 23 07:35 macros<br>-rw-rw-r–  1 john  doc      2488 Aug 15 10:51 intro<br>-rw-rw-rw-  1 john  doc      8515 Aug  6 15:30 ch07<br>-rw-rw-r–  1 john  doc     14827 Aug  9 12:40 ch03<br>.<br>.<br>.<br>-rw-rw-rw-  1 john  doc     16867 Aug  6 15:56 ch05<br>–More–(74%)<br>如上，一次只显示一屏文本，显示满后，停下来，并提示已显示全部内容的百分比，按空格键(space)可以查看下一屏，按 b 键可以查看上一屏。</p>
<h1 id="Linux进程管理"><a href="#Linux进程管理" class="headerlink" title="Linux进程管理**"></a><strong>Linux进程管理<em>**</em></strong></h1><p>当我们运行程序时，Linux会为程序创建一个特殊的环境，该环境包含程序运行需要的所有资源，以保证程序能够独立运行，不受其他程序的干扰。这个特殊的环境就称为进程。<br>每个 Linux 命令都与系统中的程序对应，输入命令，Linux 就会创建一个新的进程。例如使用 ls 命令遍历目录中的文件时，就创建了一个进程。<br>简而言之，进程就是程序的实例。<br>系统通过一个五位数字跟踪程序的运行状态，这个数字称为 pid 或进程ID。每个进程都拥有唯一的 pid。<br>理论上，五位数字是有限的，当数字被用完时，下一个 pid 就会重新开始，所以 pid 最终会重复。但是，两个 pid 一样的进程不能同时存在，因为Linux会使用 pid 来跟踪程序的运行状态。</p>
<h2 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程**"></a><strong>创建进程<em>**</em></strong></h2><p>有两种方式来创建进程：前台进程和后台进程。</p>
<h4 id="前台进程"><a href="#前台进程" class="headerlink" title="前台进程**"></a><strong>前台进程<em>**</em></strong></h4><p>默认情况下，用户创建的进程都是前台进程；前台进程从键盘读取数据，并把处理结果输出到显示器。<br>我们可以看到前台进程的运行过程。例如，使用 ls 命令来遍历当前目录下的文件：<br>$ls ch*.doc<br>ch01-1.doc   ch010.doc  ch02.doc    ch03-2.doc<br>ch04-1.doc   ch040.doc  ch05.doc    ch06-2.doc<br>ch01-2.doc   ch02-1.doc<br>这个程序就运行在前台，它会直接把结果输出到显示器。如果 ls 命令需要数据（实际上不需要），那么它会等待用户从键盘输入。<br>当程序运行在前台时，由于命令提示符($)还未出现，用户不能输入其他命令；即使程序需要运行很长时间，也必须等待程序运行结束才能输入其他命令。</p>
<h4 id="后台进程"><a href="#后台进程" class="headerlink" title="后台进程**"></a><strong>后台进程<em>**</em></strong></h4><p>后台进程与键盘没有必然的关系。当然，后台进程也可能会等待键盘输入。<br>后台进程的优点是不必等待程序运行结束就可以输入其他命令。<br>创建后台进程最简单的方式就是在命令的末尾加 &amp;，例如：<br>$ls ch*.doc &amp;<br>ch01-1.doc   ch010.doc  ch02.doc    ch03-2.doc<br>ch04-1.doc   ch040.doc  ch05.doc    ch06-2.doc<br>ch01-2.doc   ch02-1.doc<br>如果 ls 命令需要输入（实际上不需要），那么它会暂停，直到用户把它调到前台并从键盘输入数据才会继续运行。</p>
<h2 id="查看正在运行的进程"><a href="#查看正在运行的进程" class="headerlink" title="查看正在运行的进程**"></a><strong>查看正在运行的进程<em>**</em></strong></h2><p>可以使用 <strong>ps</strong> 命令查看进程的运行状态，包括后台进程，例如：<br>$ps<br>PID       TTY      TIME        CMD<br>18358     ttyp3    00:00:00    sh<br>18361     ttyp3    00:01:31    abiword<br>18789     ttyp3    00:00:00    ps<br>还可以结合 <strong>-f</strong> 选项查看更多信息，f 是 full 的缩写，例如：<br>$ps -f<br>UID      PID  PPID C STIME    TTY   TIME CMD<br>amrood   6738 3662 0 10:23:03 pts/6 0:00 first_one<br>amrood   6739 3662 0 10:22:54 pts/6 0:00 second_one<br>amrood   3662 3657 0 08:10:53 pts/6 0:00 -ksh<br>amrood   6892 3662 4 10:51:50 pts/6 0:00 ps -f<br>每列的含义如下：<br>| <strong>列<em>**</em></strong> | <strong>描述<em>**</em></strong>             |<br>| ——— | ———————- |<br>| UID       | 进程所属用户的ID，即哪个用户创建了该进程。 |<br>| PID       | 进程ID。                  |<br>| PPID      | 父进程ID，创建该进程的进程称为父进程。   |<br>| C         | CPU使用率。                |<br>| STIME     | 进程被创建的时间。              |<br>| TTY       | 与进程有关的终端类型。            |<br>| TIME      | 进程所使用的CPU时间。           |<br>| CMD       | 创建该进程的命令。              |<br>ps 命令还有其他一些选项：<br>| <strong>选项<em>**</em></strong> | <strong>说明<em>**</em></strong>        |<br>| ———- | —————– |<br>| -a         | 显示所有用户的所有进程。      |<br>| -x         | 显示无终端的进程。         |<br>| -u         | 显示更多信息，类似于 -f 选项。 |<br>| -e         | 显示所有进程。           |</p>
<h2 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程**"></a><strong>终止进程<em>**</em></strong></h2><p>当进程运行在前台时，可以通过 <strong>kill</strong> 命令或 Ctrl+C 组合键来结束进程。<br>如果进程运行在后台，那么首先要通过 <strong>ps</strong> 命令来获取进程ID，然后使用 <strong>kill</strong> 命令“杀死”进程，例如：<br>$ps -f<br>UID      PID  PPID C STIME    TTY   TIME CMD<br>amrood   6738 3662 0 10:23:03 pts/6 0:00 first_one<br>amrood   6739 3662 0 10:22:54 pts/6 0:00 second_one<br>amrood   3662 3657 0 08:10:53 pts/6 0:00 -ksh<br>amrood   6892 3662 4 10:51:50 pts/6 0:00 ps -f<br>$kill 6738<br>Terminated<br>如上所示，kill 命令终结了 first_one 进程。<br>如果进程忽略 kill 命令，那么可以通过 kill -9 来结束：<br>$kill -9 6738<br>Terminated</p>
<h2 id="父进程和子进程"><a href="#父进程和子进程" class="headerlink" title="父进程和子进程**"></a><strong>父进程和子进程<em>**</em></strong></h2><p>每个 Linux 进程会包含两个进程ID：当前进程ID(pid)和父进程ID(ppid)。可以暂时认为所有的进程都有父进程。<br>由用户运行的大部分命令都将 Shell 作为父进程，使用 <strong>ps -f</strong> 命令可以查看当前进程ID和父进程ID。</p>
<h2 id="僵尸进程和孤儿进程"><a href="#僵尸进程和孤儿进程" class="headerlink" title="僵尸进程和孤儿进程**"></a><strong>僵尸进程和孤儿进程<em>**</em></strong></h2><p>正常情况下，子进程被终止时会通过 SIGCHLD 信号通知父进程，父进程可以做一些清理工作或者重新启动一个新的进程。但在某些情况下，父进程会在子进程之前被终止，那么这些子进程就没有了“父亲”，被称为<strong>孤儿进程</strong>。<br>init 进程会成为所有孤儿进程的父进程。init 的 pid 为1，是Linux系统的第一个进程，也是所有进程的父进程。<br>如果一个进程被终止了，但是使用 ps 命令仍然可以查看该进程，并且状态为 Z，那么这就是一个<strong>僵尸进程</strong>。僵尸进程虽然被终止了，但是仍然存在于进程列表中。一般僵尸进程很难杀掉，你可以先杀死他们的父进程，让他们变成孤儿进程，init 进程会自动清理僵尸进程。</p>
<h2 id="常驻进程"><a href="#常驻进程" class="headerlink" title="常驻进程**"></a><strong>常驻进程<em>**</em></strong></h2><p>常驻进程一般是系统级进程，以 root 权限运行在后台，可以处理其他进程的请求。<br>常驻进程没有终端，不能访问 /dev/tty 文件，如果使用 ps -ef 查看该进程，tty 这一列会显示问号(?)。<br>更确切地说，常驻进程通常运行在后台，等待指定事件发生，例如打印进程是一个常驻进程，它会等待用户输入打印相关的命令并进行处理。</p>
<h2 id="top命令"><a href="#top命令" class="headerlink" title="top命令**"></a><strong>top命令<em>**</em></strong></h2><p>top 命令是一个很有用的工具，它可以动态显示正在运行的进程，还可以按照指定条件对进程进行排序，与Windows的任务管理器类似。<br>top 命令可以显示进程的很多信息，包括物理内存、虚拟内存、CPU使用率、平均负载以及繁忙的进程等。例如：<br>$top<br>这里仅给出一个示意图，读者最好亲自运行一下：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/hexo-blog//2017/07/05/linux-base/linux25807.png" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure> </p>
<h2 id="任务和进程"><a href="#任务和进程" class="headerlink" title="任务和进程**"></a><strong>任务和进程<em>**</em></strong></h2><p>任务(task)是最抽象的，是一个一般性的术语，指由软件完成的一个活动。一个任务既可以是一个进程，也可以是多个进程。简而言之，它指的是一系列共同达到某一目的的操作。例如，读取数据并将数据放入内存中。这个任务可以由一个进程来实现，也可以由多个进程来实现。  每个任务都有一个数字表示的任务号。<br>进程(process)常常被定义为程序的执行。可以把一个进程看成是一个独立的程序，在内存中有其完备的数据空间和代码空间。一个进程所拥有的数据和变量只属于它自己。<br><strong>jobs</strong> 命令可以用来查看系统中正在运行的任务，包括后台运行的任务。该命令可以显示任务号及其对应的进程ID。一个任务可以对应于一个或者多个进程号。<br>jobs 命令的 -l 选项可以查看当前任务包含的进程ID：<br>$jobs -l<br>[1] + 1903 running                 ls ch*.doc &amp;<br>$<br>其中，第一列表示任务号，第二列表示任务对应的进程ID，第三列表示任务的运行状态，第四列表示启动任务的命令。</p>
<h2 id="前台任务和后台任务的切换"><a href="#前台任务和后台任务的切换" class="headerlink" title="前台任务和后台任务的切换**"></a><strong>前台任务和后台任务的切换<em>**</em></strong></h2><p><strong>fg</strong> 命令可以将后台任务调到前台，语法为：<br>$fg %jobnumber<br>jobnumber 是通过 jobs 命令获取的后台任务的的序号，注意不是pid。如果后台只有一个任务，可以不指定 jobnumber。<br><strong>bg</strong> 命令可以将后台暂停的任务，调到前台继续运行，语法为：<br>$bg %jobnumber<br>jobnumber 同样是通过 jobs 命令获取的后台任务的的序号，注意不是pid。如果前台只有一个任务，可以不指定 jobnumber。<br>如果希望将当前任务转移到后台，可以先 Ctrl+z 暂停任务，再使用 bg 命令。任务转移到后台可以空出终端，继续输入其他命令。</p>
<h1 id="Linux网络通信工具"><a href="#Linux网络通信工具" class="headerlink" title="Linux网络通信工具**"></a><strong>Linux网络通信工具<em>**</em></strong></h1><p>现在是一个互联网的时代，你不可避免的要和其他用户进行远程交流，连接到远程主机。</p>
<h2 id="ping-命令"><a href="#ping-命令" class="headerlink" title="ping 命令**"></a><strong>ping 命令<em>**</em></strong></h2><p>ping 命令会向网络上的主机发送应答请求，根据响应信息可以判断远程主机是否可用。<br>ping 命令的语法：<br>$ping hostname or ip-address<br>如果网络畅通，很快就可以看到响应信息。<br>例如，检测是否可以连接到谷歌的主机：<br>$ping google.com<br>PING google.com (74.125.67.100) 56(84) bytes of data.<br>64 bytes from 74.125.67.100: icmp_seq=1 ttl=54 time=39.4 ms<br>64 bytes from 74.125.67.100: icmp_seq=2 ttl=54 time=39.9 ms<br>64 bytes from 74.125.67.100: icmp_seq=3 ttl=54 time=39.3 ms<br>64 bytes from 74.125.67.100: icmp_seq=4 ttl=54 time=39.1 ms<br>64 bytes from 74.125.67.100: icmp_seq=5 ttl=54 time=38.8 ms<br>— google.com ping statistics —<br>22 packets transmitted, 22 received, 0% packet loss, time 21017ms<br>rtt min/avg/max/mdev = 38.867/39.334/39.900/0.396 ms<br>$<br>如果主机没有响应，可以看到类似下面的信息：<br>$ping giiiiiigle.com<br>ping: unknown host giiiiigle.com<br>$</p>
<h2 id="ftp-工具"><a href="#ftp-工具" class="headerlink" title="ftp 工具**"></a><strong>ftp 工具<em>**</em></strong></h2><p>ftp 是 File Transfer Protocol 的缩写，称为文件传输协议。通过 ftp 工具，能够将文件上传到远程服务器，也可以从远程服务器下载文件。<br>ftp 工具有自己的命令（类似Linux命令），可以：<br>· 连接并登录远程主机；<br>· 查看目录，遍历目录下的文件；<br>· 上传或下载文件，包括文本文件、二进制文件等。<br>ftp 命令的用法如下：<br>$ftp hostname or ip-address<br>接下来会提示你输入用户名和密码，验证成功后会进入主目录，然后就可以使用 ftp 工具的命令进行操作了。<br>| <strong>ftp命令<em>**</em></strong>  | <strong>说明<em>**</em></strong>                               |<br>| ————– | —————————————- |<br>| put filename   | 将本地文件上传到远程主机。                            |<br>| get filename   | 将远程文件下载到本地。                              |<br>| mput file list | 将多个本地文件上传到远程主机。                          |<br>| mget file list | 将多个远程文件下载到本地。                            |<br>| prompt off     | 关闭提示。默认情况下，使用 mput 或 mget 命令会不断提示你确认文件的上传或下载。 |<br>| prompt on      | 打开提示。                                    |<br>| dir            | 列出远程主机当前目录下的所有文件。                        |<br>| cd dirname     | 改变远程主机目录。                                |<br>| lcd dirname    | 改变本地目录。                                  |<br>| quit           | 退出登录。                                    |<br>注意，所有的上传和下载都是针对本地主机和远程主机的当前目录，如果你希望上传指定目录下的文件，首先要 cd 到该目录，然后才能上传。<br>ftp 工具使用举例：<br>$ftp amrood.com<br>Connected to amrood.com.<br>220 amrood.com FTP server (Ver 4.9 Thu Sep 2 20:35:07 CDT 2009)<br>Name (amrood.com:amrood): amrood<br>331 Password required for amrood.<br>Password:<br>230 User amrood logged in.<br>ftp&gt; dir<br>200 PORT command successful.<br>150 Opening data connection for /bin/ls.<br>total 1464<br>drwxr-sr-x   3 amrood   group       1024 Mar 11 20:04 Mail<br>drwxr-sr-x   2 amrood   group       1536 Mar  3 18:07 Misc<br>drwxr-sr-x   5 amrood   group        512 Dec  7 10:59 OldStuff<br>drwxr-sr-x   2 amrood   group       1024 Mar 11 15:24 bin<br>drwxr-sr-x   5 amrood   group       3072 Mar 13 16:10 mpl<br>-rw-r–r–   1 amrood   group     209671 Mar 15 10:57 myfile.out<br>drwxr-sr-x   3 amrood   group        512 Jan  5 13:32 public<br>drwxr-sr-x   3 amrood   group        512 Feb 10 10:17 pvm3<br>226 Transfer complete.<br>ftp&gt; cd mpl<br>250 CWD command successful.<br>ftp&gt; dir<br>200 PORT command successful.<br>150 Opening data connection for /bin/ls.<br>total 7320<br>-rw-r–r–   1 amrood   group       1630 Aug  8 1994  dboard.f<br>-rw-r—–   1 amrood   group       4340 Jul 17 1994  vttest.c<br>-rwxr-xr-x   1 amrood   group     525574 Feb 15 11:52 wave_shift<br>-rw-r–r–   1 amrood   group       1648 Aug  5 1994  wide.list<br>-rwxr-xr-x   1 amrood   group       4019 Feb 14 16:26 fix.c<br>226 Transfer complete.<br>ftp&gt; get wave_shift<br>200 PORT command successful.<br>150 Opening data connection for wave_shift (525574 bytes).<br>226 Transfer complete.<br>528454 bytes received in 1.296 seconds (398.1 Kbytes/s)<br>ftp&gt; quit<br>221 Goodbye.<br>$</p>
<h2 id="telnet工具"><a href="#telnet工具" class="headerlink" title="telnet工具**"></a><strong>telnet工具<em>**</em></strong></h2><p>Telnet 工具可以让我们连接并登录到远程计算机。<br>一旦连接到了远程计算机，就可以在上面进行各种操作了，例如：<br>C:&gt;telnet amrood.com<br>Trying…<br>Connected to amrood.com.<br>Escape character is ‘^]’.<br>login: amrood<br>amrood’s Password:</p>
<hr>
<p>*                                                   <em><br>\</em>                                                   <em><br>\</em>            WELCOME TO AMROOD.COM                  <em><br>\</em>                                                   <em><br>\</em>                                                   *</p>
<hr>
<p>Last unsuccessful login: Fri Mar  3 12:01:09 IST 2009<br>Last login: Wed Mar  8 18:33:27 IST 2009 on pts/10<br>   {  do your work }<br>$ logout<br>Connection closed.<br>C:&gt;</p>
<h2 id="finger工具"><a href="#finger工具" class="headerlink" title="finger工具**"></a><strong>finger工具<em>**</em></strong></h2><p>finger 可以让我们查看本地主机或远程主机上的用户信息。有些系统为了安全会禁用 finger 命令。<br>例如，查看本机在线用户：<br>$ finger<br>Login     Name       Tty      Idle  Login Time   Office<br>amrood               pts/0          Jun 25 08:03 (62.61.164.115)<br>查看本机指定用户的信息：<br>$ finger amrood<br>Login: amrood                           Name: (null)<br>Directory: /home/amrood                 Shell: /bin/bash<br>On since Thu Jun 25 08:03 (MST) on pts/0 from 62.61.164.115<br>No mail.<br>No Plan.<br>查看远程主机上的在线用户：<br>$ finger @avtar.com<br>Login     Name       Tty      Idle  Login Time   Office<br>amrood               pts/0          Jun 25 08:03 (62.61.164.115)<br>查看远程主机上某个用户的信息：<br>$ finger amrood@avtar.com<br>Login: amrood                           Name: (null)<br>Directory: /home/amrood                 Shell: /bin/bash<br>On since Thu Jun 25 08:03 (MST) on pts/0 from 62.61.164.115<br>No mail.<br>No Plan.</p>
<h1 id="10分钟掌握Linux-vi编辑器常见命令的使用，最简单的vi编辑器教程"><a href="#10分钟掌握Linux-vi编辑器常见命令的使用，最简单的vi编辑器教程" class="headerlink" title="10分钟掌握Linux vi编辑器常见命令的使用，最简单的vi编辑器教程**"></a><strong>10分钟掌握Linux vi编辑器常见命令的使用，最简单的vi编辑器教程<em>**</em></strong></h1><p>Linux下的文本编辑器有很多种，vi 是最常用的，也是各版本Linux的标配。注意，vi 仅仅是一个文本编辑器，可以给字符着色，可以自动补全，但是不像 Windows 下的 word 有排版功能。<br>vi 是十年磨一剑的产品，虽然命令繁多，并且大多数功能都是依靠键盘输入来完成，但是一旦你熟悉后，会发现 vi 的功能和效率是其他图形界面编辑器无法比拟的。<br>Vim 是 <strong>V</strong>i <strong>im</strong>proved 的缩写，是 vi 的改进版。在Linux中，vi 被认为是事实上的标准编辑器，因为：<br>· 所有版本的 Linux 都带有 vi 编辑器；<br>· 占用资源少；<br>· 与 ed、ex 等其他编辑器相比，vi 对用户更加友好。<br>你可以使用 vi 编辑器编辑现有的文件，也可以创建一个新文件，还能以只读模式打开文本文件。</p>
<h2 id="进入-vi-编辑器"><a href="#进入-vi-编辑器" class="headerlink" title="进入 vi 编辑器**"></a><strong>进入 vi 编辑器<em>**</em></strong></h2><p>可以通过以下方式进入 vi 编辑器：<br>| <strong>命令<em>**</em></strong>     | <strong>描述<em>**</em></strong>                      |<br>| ————– | ——————————- |<br>| vi filename    | 如果filename存在，则打开；否则会创建一个新文件再打开。 |<br>| vi -R filename | 以只读模式（只能查看不能编辑）打开现有文件。          |<br>| view filename  | 以只读模式打开现有文件。                    |<br>例如，使用 vi 编辑器创建一个新文件并打开：<br>$vi testfile<br>|<br>~<br>~<br>~<br>~<br>~<br>~<br>~<br>~<br>~<br>~<br>~<br>~<br>“testfile” [New File]<br>竖线(|)代表光标的位置；波浪号(~)代表该行没有任何内容。如果没有 ~，也看不到任何内容，那说明这一行肯定是有空白字符（空格、tab 缩进、换行符等）或不可见字符。</p>
<h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式**"></a><strong>工作模式<em>**</em></strong></h2><p>进一步了解 vi 之前先来了解一下 vi 的工作模式，vi 有三种工作模式：</p>
<h4 id="1-普通模式"><a href="#1-普通模式" class="headerlink" title="1) 普通模式**"></a><strong>1) 普通模式<em>**</em></strong></h4><p>由Shell进入vi编辑器时，首先进入普通模式。在普通模式下，从键盘输入任何字符都被当作命令来解释。普通模式下没有任何提示符，输入命令后立即执行，不需要回车，而且输入的字符不会在屏幕上显示出来。<br>普通模式下可以执行命令、保存文件、移动光标、粘贴复制等。</p>
<h4 id="2-编辑模式"><a href="#2-编辑模式" class="headerlink" title="2) 编辑模式**"></a><strong>2) 编辑模式<em>**</em></strong></h4><p>编辑模式主要用于文本的编辑。该模式下用户输入的任何字符都被作为文件的内容保存起来，并在屏幕上显示出来。</p>
<h4 id="3-命令模式"><a href="#3-命令模式" class="headerlink" title="3) 命令模式**"></a><strong>3) 命令模式<em>**</em></strong></h4><p>命令模式下，用户可以对文件进行一些高级处理。尽管普通模式下的命令可以完成很多功能，但要执行一些如字符串查找、替换、显示行号等操作还是必须要进入命令模式。<br>注意：有些教程中称有两种工作模式，是把命令模式合并到普通模式。<br>工作模式切换：<br>· 在普通模式下输入 i(插入)、c(修改)、o(另起一行) 命令时进入编辑模式；按 esc 键退回到普通模式。<br>· 在普通模式下输入冒号(:)可以进入命令模式。输入完命令按回车，命令执行完后会自动退回普通模式。<br>提示：如果不确定当前处于哪种模式，按两次 Esc 键将回到普通模式。</p>
<h2 id="退出-vi-编辑器"><a href="#退出-vi-编辑器" class="headerlink" title="退出 vi 编辑器**"></a><strong>退出 vi 编辑器<em>**</em></strong></h2><p>一般在命令模式下退出 vi 编辑器。<br>| <strong>退出命令<em>**</em></strong> | <strong>说明<em>**</em></strong>                     |<br>| ———— | —————————— |<br>| q            | 如果文件未被修改，会直接退回到Shell；否则提示保存文件。 |<br>| q!           | 强行退出，不保存修改内容。                  |<br>| wq           | w 命令保存文件，q 命令退出 vi，合起来就是保存并退出。 |<br>| ZZ           | 保存并退出，相当于 wq，但是更加方便。           |<br>退出之前，你也可以在 w 命令后面指定一个文件名，将文件另存为新文件，例如：<br>w filename2<br>将当前文件另存为 filename2。<br>注意：vi 编辑文件时，用户的操作都是基于缓冲区中的副本进行的。如果退出时没有保存到磁盘，则缓冲区中的内容就会被丢失。</p>
<h2 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标**"></a><strong>移动光标<em>**</em></strong></h2><p>为了不影响文件内容，必须在普通模式（按两次 Esc 键）下移动光标。使用下表中的命令每次可以移动一个字符：<br>| <strong>命令<em>**</em></strong> | <strong>描述<em>**</em></strong>     |<br>| ———- | ————– |<br>| k          | 向上移动光标（移动一行）   |<br>| j          | 向下移动光标（移动一行）   |<br>| h          | 向左移动光标（移动一个字符） |<br>| l          | 向右移动光标（移动一个字符） |<br>两点提醒：<br>· vi 是区分大小写的，输入命令时注意不要锁定大写。<br>· 可以在命令前边添加一个数字作为前缀，例如，2j 将光标向下移动两行。<br>当然，还有很多其他命令来移动光标，不过记住，一定要在普通模式（按两次 Esc 键）下。<br>| 用来移动光标的命令  |                                |<br>| ———- | —————————— |<br>| <strong>命令<em>**</em></strong> | <strong>说明<em>**</em></strong>                     |<br>| 0 或 |     | 将光标定位在一行的开头。                   |<br>| $          | 将光标定位在一行的末尾。                   |<br>| w          | 定位到下一个单词。                      |<br>| b          | 定位到上一个单词。                      |<br>| (          | 定位到一句话的开头，句子是以 ! . ? 三种符号来界定的。 |<br>| )          | 定位到一句话的结尾。                     |<br>| {          | 移动到段落开头。&amp;&amp;&amp;&amp;&amp;&amp;                 |<br>| }          | 移动到段落结束。&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;              |<br>| [[         | 回到段落的开头处。&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;            |<br>| ]]         | 向前移到下一个段落的开头处。&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;       |<br>| n|        | 移动到第 n 列（当前行）。                 |<br>| 1G         | 移动到文件第一行。                      |<br>| G          | 移动到文件最后一行。                     |<br>| nG         | 移动到文件第 n 行。                    |<br>| :n         | 移动到文件第 n 行。                    |<br>| H          | 移动到屏幕顶部。                       |<br>| nH         | 移动到距离屏幕顶部第 n 行的位置。             |<br>| M          | 移动到屏幕中间。                       |<br>| L          | 移动到屏幕底部。                       |<br>| nL         | 移动到距离屏幕底部第 n 行的位置。             |<br>| :x         | x 是一个数字，表示移动到行号为 x 的行。         |</p>
<h2 id="控制命令"><a href="#控制命令" class="headerlink" title="控制命令**"></a><strong>控制命令<em>**</em></strong></h2><p>有一些控制命令可以与 Ctrl 键组合使用，如下：<br>| <strong>命令<em>**</em></strong> | <strong>描述<em>**</em></strong> |<br>| ———- | ———- |<br>| CTRL+d     | 向前滚动半屏     |<br>| CTRL+f     | 向前滚动全屏     |<br>| CTRL+u     | 向后滚动半屏     |<br>| CTRL+b     | 向后滚动整屏     |<br>| CTRL+e     | 向上滚动一行     |<br>| CTRL+y     | 向下滚动一行     |<br>| CTRL+I     | 刷新屏幕       |</p>
<h2 id="编辑文件-1"><a href="#编辑文件-1" class="headerlink" title="编辑文件**"></a><strong>编辑文件<em>**</em></strong></h2><p>切换到编辑模式下才能编辑文件。有很多命令可以从普通模式切换到编辑模式，如下所示：<br>| <strong>命令<em>**</em></strong> | <strong>描述<em>**</em></strong>    |<br>| ———- | ————- |<br>| i          | 在当前光标位置之前插入文本 |<br>| I          | 在当前行的开头插入文本   |<br>| a          | 在当前光标位置之后插入文本 |<br>| A          | 在当前行的末尾插入文本   |<br>| o          | 在当前位置下面创建一行   |<br>| O          | 在当前位置上面创建一行   |</p>
<h2 id="删除字符"><a href="#删除字符" class="headerlink" title="删除字符**"></a><strong>删除字符<em>**</em></strong></h2><p>下面的命令，可以删除文件中的字符或行：<br>| <strong>命令<em>**</em></strong> | <strong>说明<em>**</em></strong>      |<br>| ———- | ————— |<br>| x          | 删除当前光标下的字符      |<br>| X          | 删除光标前面的字符       |<br>| dw         | 删除从当前光标到单词结尾的字符 |<br>| d^         | 删除从当前光标到行首的字符   |<br>| d$         | 删除从当前光标到行尾的字符   |<br>| D          | 删除从当前光标到行尾的字符   |<br>| dd         | 删除当前光标所在的行      |<br>可以在命令前面添加一个数字前缀，表示重复操作的次数，例如，2x  表示连续两次删除光标下的字符，2dd 表示连续两次删除光标所在的行。<br>建议各位读者多加练习上面的命令，再进一步深入学习。</p>
<h2 id="修改文本"><a href="#修改文本" class="headerlink" title="修改文本**"></a><strong>修改文本<em>**</em></strong></h2><p>如果你希望对字符、单词或行进行修改，可以使用下面的命令：<br>| <strong>命令<em>**</em></strong> | <strong>描述<em>**</em></strong>             |<br>| ———- | ———————- |<br>| cc         | 删除当前行，并进入编辑模式。         |<br>| cw         | 删除当前字（单词），并进入编辑模式。     |<br>| r          | 替换当前光标下的字符。            |<br>| R          | 从当前光标开始替换字符，按 Esc 键退出。 |<br>| s          | 用输入的字符替换当前字符，并进入编辑模式。  |<br>| S          | 用输入的文本替换当前行，并进入编辑模式。   |</p>
<h2 id="粘贴复制"><a href="#粘贴复制" class="headerlink" title="粘贴复制**"></a><strong>粘贴复制<em>**</em></strong></h2><p>vi 中的复制粘贴命令：<br>| <strong>命令<em>**</em></strong> | <strong>描述<em>**</em></strong>    |<br>| ———- | ————- |<br>| yy         | 复制当前行         |<br>| nyy        | 复制n行          |<br>| yw         | 复制一个字（单词）     |<br>| nyw        | 复制n行          |<br>| p          | 将复制的文本粘贴到光标后面 |<br>| P          | 将复制的文本粘贴到光标前面 |</p>
<h2 id="高级命令"><a href="#高级命令" class="headerlink" title="高级命令**"></a><strong>高级命令<em>**</em></strong></h2><p>下面的一些命令虽然看起来有些古怪，但是会让你的工作更有效率，如果你是 vi 重度用户，就了解一下吧。<br>| <strong>命令<em>**</em></strong>  | <strong>说明<em>**</em></strong>                         |<br>| ———– | ———————————- |<br>| J           | 将当前行和下一行连接为一行                      |<br>| &lt;&lt;          | 将当前行左移一个单位（一个缩进宽度）                 |<br>| &gt;&gt;          | 将当前行右移一个单位（一个缩进宽度）                 |<br>| ~           | 改变当前字符的大小写                         |<br>| ^G          | Ctrl+G组合键可以显示当前文件名和状态              |<br>| U           | 撤销对当前行所做的修改                        |<br>| u           | 撤销上次操作，再次按 ‘u’ 恢复该次操作              |<br>| :f          | 以百分号(%)的形式显示当前光标在文件中的位置、文件名和文件的总行数 |<br>| :f filename | 将文件重命名为 filename                   |<br>| :w filename | 保存修改到 filename                     |<br>| :e filename | 打开另一个文件名为 filename 的文件             |<br>| :cd dirname | 改变当前工作目录到 dirname                  |<br>| :e #        | 在两个打开的文件之间进行切换                     |<br>| :n          | 如果用 vi 打开了多个文件，可以使用 :n 切换到下一个文件    |<br>| :p          | 如果用 vi 打开了多个文件，可以使用 :n 切换到上一个文件    |<br>| :N          | 如果用 vi 打开了多个文件，可以使用 :n 切换到上一个文件    |<br>| :r file     | 读取文件并在当前行的后边插入                     |<br>| :nr file    | 读取文件并在第 n 行后边插入                    |</p>
<h2 id="文本查找"><a href="#文本查找" class="headerlink" title="文本查找**"></a><strong>文本查找<em>**</em></strong></h2><p>如果希望进行全文件搜索，可以在普通模式（按两次 Esc 键）下输入 / 命令，这时状态栏（最后一行）出现”/“并提示输入要查找的字符串，回车即可。<br>/ 命令是向下查找，如果希望向上查找，可以使用 ? 命令。<br>这时，输入 n 命令可以按相同的方向继续查找，输入 N 命令可以按相反的方向继续查找。<br>搜索的字符串中可以包含一些有特殊含义的字符，如果希望搜索这些字符本身，需要在前面加反斜杠()。<br>| 部分特殊字符列表   |            |<br>| ———- | ———- |<br>| <strong>字符<em>**</em></strong> | <strong>说明<em>**</em></strong> |<br>| ^          | 匹配一行的开头    |<br>| .          | 匹配一个字符     |<br>| *          | 匹配0个或多个字符  |<br>| $          | 匹配一行的结尾    |<br>| [ ]        | 匹配一组字符     |<br>如果希望搜索某行中的单个字符，可以使用 f 或 F 命令，f 向上搜索，F 向下搜索，并且会把光标定位到匹配的字符。<br>也可以使用 t 或 T 命令：t 命令向上搜索，并把光标定位到匹配字符的前面；T 命令向下搜索，并把光标定位到匹配字符的后面。</p>
<h2 id="set-命令"><a href="#set-命令" class="headerlink" title="set 命令**"></a><strong>set 命令<em>**</em></strong></h2><p>set 命令可以对 vi 编辑器进行一些设置。使用 set 命令需要进入命令模式。<br>| :set 命令选项  |                                      |<br>| ———- | ———————————— |<br>| <strong>命令<em>**</em></strong> | <strong>说明<em>**</em></strong>                           |<br>| :set ic    | 搜索时忽略大小写。                            |<br>| :set ai    | 设置自动缩进（自动对齐）。                        |<br>| :set noai  | 取消自动缩进（自动对齐）。                        |<br>| :set nu    | 显示行号。                                |<br>| :set sw    | 设置缩进的空格数，例如，将缩进空格数设置为4：:set sw=4。    |<br>| :set ws    | 循环搜索：如果直到文件末尾也没有查找到指定字符，那么会回到开头继续查找。 |<br>| :set wm    | 设置自动换行，例如，设置距离边际2个字符时换行：:set wm=2 。  |<br>| :set ro    | 将文件类型改为只读。                           |<br>| :set term  | 输出终端类型。                              |<br>| :set bf    | 忽略输入的控制字符，如 BEL(响铃)、BS(退格)、CR(回车)等。  |</p>
<h2 id="运行命令"><a href="#运行命令" class="headerlink" title="运行命令**"></a><strong>运行命令<em>**</em></strong></h2><p>切换到命令模式，再输入 ! 命令即可运行 Linux 命令。<br>例如，保存文件前，如果希望查看该文件是否存在，那么输入<br>:! ls<br>即可列出当前目录下的文件。<br>按任意键回到 vi 编辑器。</p>
<h2 id="文本替换"><a href="#文本替换" class="headerlink" title="文本替换**"></a><strong>文本替换<em>**</em></strong></h2><p>切换到命令模式，再输入 s/ 命令即可对文本进行替换。语法为：<br>:s/search/replace/g<br>search 为检索的文本，replace 为要替换的文本，g 表示全局替换。</p>
<h2 id="几点提示"><a href="#几点提示" class="headerlink" title="几点提示**"></a><strong>几点提示<em>**</em></strong></h2><p>vi 编辑器的使用讲解完毕，但是请记住下面几点：<br>· 输入冒号(:)进入命令模式，按两次 Esc 键进入普通模式。<br>· 命令大小写的含义是不一样的。<br>· 必须在编辑模式下才能输入内容。</p>
<h1 id="Linux文件系统"><a href="#Linux文件系统" class="headerlink" title="Linux文件系统**"></a><strong>Linux文件系统<em>**</em></strong></h1><p>文件系统就是分区或磁盘上的所有文件的逻辑集合。<br>文件系统不仅包含着文件中的数据而且还有文件系统的结构，所有Linux 用户和程序看到的文件、目录、软连接及文件保护信息等都存储在其中。<br>不同Linux发行版本之间的文件系统差别很少，主要表现在系统管理的特色工具以及软件包管理方式的不同，文件目录结构基本上都是一样的。<br>文件系统有多种类型，如：<br>· ext2 ： 早期linux中常用的文件系统；<br>· ext3 ： ext2的升级版，带日志功能；<br>· RAMFS ： 内存文件系统，速度很快；<br>· iso9660：光盘或光盘镜像；<br>· NFS ： 网络文件系统，由SUN发明，主要用于远程文件共享；<br>· MS-DOS ： MS-DOS文件系统；<br>· FAT ： Windows XP 操作系统采用的文件系统；<br>· NTFS ： Windows NT/XP 操作系统采用的文件系统。</p>
<h2 id="分区与目录"><a href="#分区与目录" class="headerlink" title="分区与目录**"></a><strong>分区与目录<em>**</em></strong></h2><p>文件系统位于磁盘分区中；一个硬盘可以有多个分区，也可以只有一个分区；一个分区只能包含一个文件系统。<br>Linux文件系统与Windows有较大的差别。Windows的文件结构是多个并列的树状结构，最顶部的是不同的磁盘（分区），如 C、D、E、F等。<br>Linux的文件结构是单个的树状结构，根目录是“/”，其他目录都要位于根目录下。<br>每次安装系统的时候我们都会进行分区，Linux下磁盘分区和目录的关系如下：<br>· 任何一个分区都必须对应到某个目录上，才能进行读写操作，称为“挂载”。<br>· 被挂载的目录可以是根目录，也可以是其他二级、三级目录，任何目录都可以是挂载点。<br>· 目录是逻辑上的区分。分区是物理上的区分。<br>· 根目录是所有Linux的文件和目录所在的地方，需要挂载上一个磁盘分区。<br>下图是常见的目录和分区的对应关系：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/hexo-blog//2017/07/05/linux-base/linux36302.png" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure><br>为什么要分区，如何分区？<br>· 可以把不同资料，分别放入不同分区中管理，降低风险。<br>· 大硬盘搜索范围大，效率低。<br>· /home、/var、/usr/local 经常是单独分区，因为经常会操作，容易产生碎片。<br>为了便于定位和查找，Linux中的每个目录一般都存放特定类型的文件，下表列出了各种Linux发行版本的常见目录：<br>| <strong>目录<em>**</em></strong> | <strong>说明<em>**</em></strong>                               |<br>| ———- | —————————————- |<br>| /          | 根目录，只能包含目录，不能包含具体文件。                     |<br>| /bin       | 存放可执行文件。很多命令就对应/bin目录下的某个程序，例如 ls、cp、mkdir。/bin目录对所有用户有效。 |<br>| /dev       | 硬件驱动程序。例如声卡、磁盘驱动等，还有如 /dev/null、/dev/console、/dev/zero、/dev/full 等文件。 |<br>| /etc       | 主要包含系统配置文件和用户、用户组配置文件。                   |<br>| /lib       | 主要包含共享库文件，类似于Windows下的DLL；有时也会包含内核相关文件。  |<br>| /boot      | 系统启动文件，例如Linux内核、引导程序等。                  |<br>| /home      | 用户工作目录（主目录），每个用户都会分配一个目录。                |<br>| /mnt       | 临时挂载文件系统。这个目录一般是用于存放挂载储存设备的挂载目录的，例如挂载CD-ROM的cdrom目录。 |<br>| /proc      | 操作系统运行时，进程（正在运行中的程序）信息及内核信息（比如cpu、硬盘分区、内存信息等）存放在这里。/proc目录伪装的文件系统proc的挂载目录，proc并不是真正的文件系统。 |<br>| /tmp       | 临时文件目录，系统重启后不会被保存。                       |<br>| /usr       | /user目下的文件比较混杂，包含了管理命令、共享文件、库文件等，可以被很多用户使用。 |<br>| /var       | 主要包含一些可变长度的文件，会经常对数据进行读写，例如日志文件和打印队列里的文件。 |<br>| /sbin      | 和 /bin 类似，主要包含可执行文件，不过一般是系统管理所需要的，不是所有用户都需要。 |</p>
<h2 id="常用文件管理命令"><a href="#常用文件管理命令" class="headerlink" title="常用文件管理命令**"></a><strong>常用文件管理命令<em>**</em></strong></h2><p>你可以通过下面的命令来管理文件：<br>| <strong>Command<em>**</em></strong>   | <strong>Description<em>**</em></strong>          |<br>| —————– | —————————- |<br>| cat filename      | 查看文件内容。                      |<br>| cd dirname        | 改变所在目录。                      |<br>| cp file1 file2    | 复制文件或目录。                     |<br>| file filename     | 查看文件类型(binary, text, etc)。   |<br>| find filename dir | 搜索文件或目录。                     |<br>| head filename     | 显示文件的开头，与tail命令相对。           |<br>| less filename     | 查看文件的全部内容，可以分页显示，比more命令要强大。 |<br>| ls dirname        | 遍历目录下的文件或目录。                 |<br>| mkdir dirname     | 创建目录。                        |<br>| more filename     | 查看文件的全部内容，可以分页显示。            |<br>| mv file1 file2    | 移动文件或重命名。                    |<br>| pwd               | 显示用户当前所在目录。                  |<br>| rm filename       | 删除文件。                        |<br>| rmdir dirname     | 删除目录。                        |<br>| tail filename     | 显示文件的结尾，与head命令相对。           |<br>| touch filename    | 文件不存在时创建一个空文件，存在时修改文件时间戳。    |<br>| whereis filename  | 查看文件所在位置。                    |<br>| which filename    | 如果文件在环境变量PATH中有定义，那么显示文件位置。  |</p>
<h4 id="df命令"><a href="#df命令" class="headerlink" title="df命令**"></a><strong>df命令<em>**</em></strong></h4><p>管理磁盘分区时经常会使用 <strong>df</strong> (disk free) 命令，df -k 命令可以用来查看磁盘空间的使用情况（以千字节计），例如：<br>$df -k<br>Filesystem      1K-blocks      Used   Available Use% Mounted on<br>/dev/vzfs        10485760   7836644     2649116  75% /<br>/devices                0         0           0   0% /devices<br>$<br>每一列的含义如下：<br>| <strong>列<em>**</em></strong>  | <strong>说明<em>**</em></strong>                    |<br>| ———- | —————————– |<br>| Filesystem | 代表文件系统对应的设备文件的路径名（一般是硬盘上的分区）。 |<br>| kbytes     | 分区包含的数据块（1024字节）的数目。          |<br>| used       | 已用空间。                         |<br>| avail      | 可用空间。                         |<br>| capacity   | 已用空间的百分比。                     |<br>| Mounted on | 文件系统挂载点。                      |<br>某些目录（例如 /devices）的 kbytes、used、avail 列为0，use列为0%，这些都是特殊（或虚拟）文件系统，即使位于根目录下，也不占用硬盘空间。<br>你可以结合 -h (human readable) 选项将输出信息格式化，让人更易阅读。 </p>
<h4 id="du-命令"><a href="#du-命令" class="headerlink" title="du 命令**"></a><strong>du 命令<em>**</em></strong></h4><p>du (disk usage) 命令可以用来查看特定目录的空间使用情况。<br>du 命令会显示每个目录所占用数据块。根据系统的不同，一个数据块可能是 512 字节或 1024 字节。举例如下：<br>$du /etc<br>10     /etc/cron.d<br>126    /etc/default<br>6      /etc/dfs<br>…<br>$<br>结合 -h 选项可以让信息显示的更加清晰：<br>$du -h /etc<br>5k    /etc/cron.d<br>63k   /etc/default<br>3k    /etc/dfs<br>…<br>$</p>
<h2 id="挂载文件系统"><a href="#挂载文件系统" class="headerlink" title="挂载文件系统**"></a><strong>挂载文件系统<em>**</em></strong></h2><p>挂载是指将一个硬件设备（例如硬盘、U盘、光盘等）对应到一个已存在的目录上。 若要访问设备中的文件，必须将文件挂载到一个已存在的目录上， 然后通过访问这个目录来访问存储设备。<br>这样就为用户提供了统一的接口，屏蔽了硬件设备的细节。Linux将所有的硬件设备看做文件，对硬件设备的操作等同于对文件的操作。<br>注意：挂载目录可以不为空，但挂载后这个目录下以前的内容将不可用。<br>需要知道的是，光盘、软盘、其他操作系统使用的文件系统的格式与linux使用的文件系统格式是不一样的，挂载需要确认Linux是否支持所要挂载的文件系统格式。<br>查看当前系统所挂载的硬件设备可以使用 mount 命令：<br>$ mount<br>/dev/vzfs on / type reiserfs (rw,usrquota,grpquota)<br>proc on /proc type proc (rw,nodiratime)<br>devpts on /dev/pts type devpts (rw)<br>$<br>一般约定，/mnt 为临时挂载目录，例如挂载CD-ROM、远程网络设备、软盘等。<br>也可以通过mount命令来挂载文件系统，语法为：<br>mount -t file_system_type device_to_mount directory_to_mount_to<br>例如：<br>$ mount -t iso9660 /dev/cdrom /mnt/cdrom<br>将 CD-ROM 挂载到 /mnt/cdrom 目录。<br>注意：file_system_type用来指定文件系统类型，通常可以不指定，Linux会自动正确选择文件系统类型。<br>挂载文件系统后，就可以通过 cd、cat 等命令来操作对应文件。<br>可以通过 umount 命令来卸载文件系统。例如，卸载 cdrom：<br>$ umount /dev/cdrom<br>不过，大部分现代的Linux系统都有自动挂载卸载功能，unmount 命令较少用到。</p>
<h2 id="用户和群组配额"><a href="#用户和群组配额" class="headerlink" title="用户和群组配额**"></a><strong>用户和群组配额<em>**</em></strong></h2><p>用户和群组配额可以让管理员为每个用户或群组分配固定的磁盘空间。<br>管理员有两种方式来分配磁盘空间：<br>· 软限制：如果用户超过指定的空间，会有一个宽限期，等待用户释放空间。<br>· 硬限制：没有宽限期，超出指定空间立即禁止操作。<br>下面的命令可以用来管理配额：<br>| <strong>命令<em>**</em></strong> | <strong>说明<em>**</em></strong>                  |<br>| ———- | ————————— |<br>| quota      | 显示磁盘使用情况以及每个用户组的配额。         |<br>| edquota    | 编辑用户和群组的配额。                 |<br>| quotacheck | 查看文件系统的磁盘使用情况，创建、检查并修复配额文件。 |<br>| setquota   | 设置配额。                       |<br>| quotaon    | 开启用户或群组的配额功能。               |<br>| quotaoff   | 关闭用户或群组的配额功能。               |<br>| repquota   | 打印指定文件系统的配额。                |</p>
<h1 id="Linux文件存储结构，包括目录项、inode、数据块"><a href="#Linux文件存储结构，包括目录项、inode、数据块" class="headerlink" title="Linux文件存储结构，包括目录项、inode、数据块**"></a><strong>Linux文件存储结构，包括目录项、inode、数据块<em>**</em></strong></h1><p>大部分的Linux文件系统（如ext2、ext3）规定，一个文件由目录项、inode和数据块组成：<br>· 目录项：包括文件名和inode节点号。<br>· Inode：又称文件索引节点，包含文件的基础信息以及数据块的指针。<br>· 数据块：包含文件的具体内容。</p>
<h2 id="先说inode"><a href="#先说inode" class="headerlink" title="先说inode**"></a><strong>先说inode<em>**</em></strong></h2><p>理解inode，要从文件储存说起。文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector），每个扇区储存512字节（相当于0.5KB）。<br>操作系统读取硬盘的时候，不会一个扇区一个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。<br>文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。<br>inode包含文件的元信息，具体来说有以下内容：<br>· 文件的字节数。<br>· 文件拥有者的User ID。<br>· 文件的Group ID。<br>· 文件的读、写、执行权限。<br>· 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。<br>· 链接数，即有多少文件名指向这个inode。<br>· 文件数据block的位置。<br>可以用stat命令，查看某个文件的inode信息：<br>stat demo.txt<br>总之，除了文件名以外的所有文件信息，都存在inode之中。至于为什么没有文件名，下文会有详细解释。<br>当查看某个文件时，会先从inode表中查出文件属性及数据存放点，再从数据块中读取数据。<br>请看文件存储结构示意图：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/hexo-blog//2017/07/05/linux-base/linux36302.png" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure> </p>
<h4 id="inode的大小"><a href="#inode的大小" class="headerlink" title="inode的大小**"></a><strong>inode的大小<em>**</em></strong></h4><p>inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。<br>每个inode节点的大小，一般是128字节或256字节。inode节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个inode。假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，占整块硬盘的12.8%。<br>查看每个硬盘分区的inode总数和已经使用的数量，可以使用df -i 命令。<br>查看每个inode节点的大小，可以用如下命令：<br>sudo dumpe2fs -h /dev/hda | grep “Inode size”<br>由于每个文件都必须有一个inode，因此有可能发生inode已经用光，但是硬盘还未存满的情况。这时，就无法在硬盘上创建新文件。</p>
<h4 id="inode号码"><a href="#inode号码" class="headerlink" title="inode号码**"></a><strong>inode号码<em>**</em></strong></h4><p>每个inode都有一个号码，操作系统用inode号码来识别不同的文件。<br>这里值得重复一遍，Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：首先，系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。<br>使用ls -i命令，可以看到文件名对应的inode号码，例如：<br>ls -i demo.txt</p>
<h2 id="目录项"><a href="#目录项" class="headerlink" title="目录项**"></a><strong>目录项<em>**</em></strong></h2><p>Linux系统中，目录（directory）也是一种文件。打开目录，实际上就是打开目录文件。<br>目录文件的结构非常简单，就是一系列目录项（dirent）的列表。每个目录项，由两部分组成：所包含文件的文件名，以及该文件名对应的inode号码。<br>ls命令只列出目录文件中的所有文件名：<br>ls /etc<br>ls -i命令列出整个目录文件，即文件名和inode号码：<br>ls -i /etc<br>如果要查看文件的详细信息，就必须根据inode号码，访问inode节点，读取信息。ls -l命令列出文件的详细信息。<br>ls -l /etc</p>
<h2 id="硬链接和软链接"><a href="#硬链接和软链接" class="headerlink" title="硬链接和软链接**"></a><strong>硬链接和软链接<em>**</em></strong></h2><h4 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接**"></a><strong>硬链接<em>**</em></strong></h4><p>一般情况下，文件名和inode号码是”一一对应”关系，每个inode号码对应一个文件名。但是，Linux系统允许，多个文件名指向同一个inode号码。这意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访问。这种情况就被称为”硬链接”（hard link）。<br>ln命令可以创建硬链接，语法为：<br>ln source_file target_file<br>运行上面这条命令以后，源文件与目标文件的inode号码相同，都指向同一个inode。inode信息中有一项叫做”链接数”，记录指向该inode的文件名总数，这时就会增加1。反过来，删除一个文件名，就会使得inode节点中的”链接数”减1。当这个值减到0，表明没有文件名指向这个inode，系统就会回收这个inode号码，以及其所对应block区域。<br>这里顺便说一下目录文件的”链接数”。创建目录时，默认会生成两个目录项：”.”和”..”。前者的inode号码就是当前目录的inode号码，等同于当前目录的”硬链接”；后者的inode号码就是当前目录的父目录的inode号码，等同于父目录的”硬链接”。所以，任何一个目录的”硬链接”总数，总是等于2加上它的子目录总数（含隐藏目录）,这里的2是父目录对其的“硬链接”和当前目录下的”.硬链接“。</p>
<h4 id="软链接"><a href="#软链接" class="headerlink" title="软链接**"></a><strong>软链接<em>**</em></strong></h4><p>除了硬链接以外，还有一种特殊情况。文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的”软链接”（soft link）或者”符号链接（symbolic link）。<br>这意味着，文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错：”No such file or directory”。这是软链接与硬链接最大的不同：文件A指向文件B的文件名，而不是文件B的inode号码，文件B的inode”链接数”不会因此发生变化。<br>ln -s命令可以创建软链接，语法为：<br>ln source_file target_file</p>
<h1 id="Linux用户管理"><a href="#Linux用户管理" class="headerlink" title="Linux用户管理**"></a><strong>Linux用户管理<em>**</em></strong></h1><p>在Linux中，有三种用户：<br>· Root 用户：也称为超级用户，对系统拥有完全的控制权限。超级用户可以不受限制的运行任何命令。Root 用户可以看做是系统管理员。<br>· 系统用户：系统用户是Linux运行某些程序所必须的用户，例如 mail 用户、sshd 用户等。系统用户通常为系统功能所必须的，不建议修改这些用户。<br>· 普通用户：一般用户都是普通用户，这些用户对系统文件的访问受限，不能执行全部Linux命令。<br>Linux支持用户组，用户组就是具有相同特征的用户的集合。一个组可以包含多个用户，每个用户也可以属于不同的组。用户组在Linux中扮演着重要的角色，方便管理员对用户进行集中管理。</p>
<h2 id="与用户和组有关的系统文件"><a href="#与用户和组有关的系统文件" class="headerlink" title="与用户和组有关的系统文件**"></a><strong>与用户和组有关的系统文件<em>**</em></strong></h2><p>与用户和组有关的系统文件：<br>| <strong>系统文件<em>**</em></strong> | <strong>说明<em>**</em></strong>                               |<br>| ———— | —————————————- |<br>| /etc/passwd  | 保存用户名和密码等信息，Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行。这个文件对所有用户都是可读的。 |<br>| /etc/shadow  | /etc/shadow中的记录行和/etc/passwd中的相对应，他由pwconv命令根据/etc/passwd中的数据自动产生，它的格式和/etc/passwd类似，只是对密码进行了加密。并不是所有的系统都支持这个文件。 |<br>| /etc/group   | 以记录行的形式保存了用户组的所有信息。                      |<br>来看一下/etc/passwd文件的结构：<br>$cat /etc/passwd<br>root:x:0:0:Superuser:/:<br>daemon:x:1:1:System daemons:/etc:<br>bin:x:2:2:Owner of system commands:/bin:<br>sys:x:3:3:Owner of system files:/usr/sys:<br>adm:x:4:4:System accounting:/usr/adm:<br>uucp:x:5:5:UUCP administrator:/usr/lib/uucp:<br>auth:x:7:21:Authentication administrator:/tcb/files/auth:<br>cron:x:9:16:Cron daemon:/usr/spool/cron:<br>listen:x:37:4:Network daemon:/usr/net/nls:<br>lp:x:71:18:printer administrator:/usr/spool/lp:<br>sam:x:200:50:Sam san:/usr/sam:/bin/sh<br>可以看到，/etc/passwd文件中一行记录对应着一个用户，每行记录又被冒号分隔为7个字段，其格式和具体含义如下图所示：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/hexo-blog//2017/07/05/linux-base/linux43471.png" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure><br>对每个字段的说明：<br>| <strong>字段<em>**</em></strong> | <strong>说明<em>**</em></strong>                               |<br>| ———- | —————————————- |<br>| 用户名        | 用户名是惟一的，长度根据不同的linux系统而定，一般是8位。          |<br>| 密码         | 由于系统中还有一个/etc/shadow文件用于存放加密后的口令，所以在这里这一项是“x”来表示，如果用户没有设置口令，则该项为空。如果passwd字段中的第一个字符是“*”的话，那么，就表示该账号被查封了，系统不允许持有该账号的用户登录。 |<br>| 用户ID       | 系统内部根据用户ID而不是用户名来识别不同的用户，用户ID有以下几种：· 0代表系统管理员，如果你想建立一个系统管理员的话，可以建立一个普通帐户，然后将该账户的用户ID改为0即可。· 1~500系统预留的ID。· 500以上是普通用户使用。 |<br>| 组ID        | 其实这个和用户ID差不多，用来管理群组，与/etc/group文件相关。     |<br>| 描述信息       | 这个字段几乎没有什么用，只是用来解释这个账号的意义。在不同的Linux系统中，这个字段的 格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用做finger命令的输出。 |<br>| 用户主目录      | 用户登录系统的起始目录。用户登录系统后将首先进入该目录。root用户默认是/，普通用户是/home/username。 |<br>| 用户Shell    | 用户登录系统时使用的Shell。                         |</p>
<h2 id="管理用户和组"><a href="#管理用户和组" class="headerlink" title="管理用户和组**"></a><strong>管理用户和组<em>**</em></strong></h2><p>下面是一些常用的管理用户和组的命令：<br>| <strong>命令<em>**</em></strong> | <strong>说明<em>**</em></strong> |<br>| ———- | ———- |<br>| useradd    | 添加用户。      |<br>| usermod    | 修改用户信息。    |<br>| userdel    | 删除用户。      |<br>| groupadd   | 添加用户组。     |<br>| groupmod   | 修改用户组信息。   |<br>| groupdel   | 删除用户组。     |</p>
<h4 id="创建用户组"><a href="#创建用户组" class="headerlink" title="创建用户组**"></a><strong>创建用户组<em>**</em></strong></h4><p>添加用户时，可以将用户添加到现有的用户组，或者创建一个新的用户组。可以在 /etc/groups 文件中看到所有的用户组信息。<br>默认的用户组通常用来管理系统用户，不建议将普通用户添加到这些用户组。使用groupadd命令创建用户组的语法为：<br>groupadd [-g gid [-o]] [-r] [-f] groupname<br>每个选项的含义如下：<br>| <strong>选项<em>**</em></strong> | <strong>说明<em>**</em></strong>      |<br>| ———- | ————— |<br>| -g GID     | 以数字表示的用户组ID。    |<br>| -o         | 可以使用重复的组ID。     |<br>| -r         | 建立系统组，用来管理系统用户。 |<br>| -f         | 强制创建。           |<br>| groupname  | 用户组的名称。         |<br>如果不指定选项，系统将使用默认值。例如创建一个 developers 用户组：<br>$ groupadd developers</p>
<h4 id="修改用户组"><a href="#修改用户组" class="headerlink" title="修改用户组**"></a><strong>修改用户组<em>**</em></strong></h4><p>groupmod命令可以用来修改用户组，语法为：<br>$ groupmod -n new_modified_group_name old_group_name<br>例如，将用户组 developers_2 重命名为 developer：<br>$ groupmod -n developer developer_2<br>将developer用户组的ID改为545：<br>$ groupmod -g 545 developer</p>
<h4 id="删除用户组"><a href="#删除用户组" class="headerlink" title="删除用户组**"></a><strong>删除用户组<em>**</em></strong></h4><p>通过groupdel命令可以删除用户组。例如，删除developer组：<br>$ groupdel developer<br>groupdel 仅仅删除用户组，并不删除与之相关的文件，这些文件仍然可以被所有者访问。</p>
<h4 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户**"></a><strong>添加用户<em>**</em></strong></h4><p>添加用户可以使用useradd命令，语法为：<br>useradd -d homedir -g groupname -m -s shell -u userid accountname<br>每个选项的含义如下：<br>| <strong>选项<em>**</em></strong>   | <strong>描述<em>**</em></strong>    |<br>| ———— | ————- |<br>| -d homedir   | 指定用户主目录。      |<br>| -g groupname | 指定用户组。        |<br>| -m           | 如果主目录不存在，就创建。 |<br>| -s shell     | 为用户指定默认Shell。 |<br>| -u userid    | 指定用户ID。       |<br>| accountname  | 用户名。          |<br>如果不指定任何选项，系统将使用默认值。useradd 命令将会修改 /etc/passwd、/etc/shadow、and /etc/group 三个文件，并创建用户主目录。<br>下面的例子将会添加用户 mcmohd，并设置主目录为 /home/mcmohd，用户组为 developers，默认 Shell 为  Korn Shell：<br>$ useradd -d /home/mcmohd -g developers -s /bin/ksh mcmohd<br>注意：添加用户前请确认 developers 用户组存在。<br>用户被创建后，可以使用 passwd 命令来设置密码，例如：<br>$ passwd mcmohd20<br>Changing password for user mcmohd20.<br>New Linux password:<strong>**</strong><br>Retype new UNIX password:<strong>**</strong><br>passwd: all authentication tokens updated successfully.<br>注意：如果你是管理员，输入 $ passwd username 可以修改你所管理的用户的密码；否则只能修改你自己的密码（不需要提供username）。</p>
<h4 id="修改用户"><a href="#修改用户" class="headerlink" title="修改用户**"></a><strong>修改用户<em>**</em></strong></h4><p>usermod 命令可以修改现有用户的信息。usermod 命令的选项和 useradd 相同，不过可以增加 -l 选项来更改用户名。<br>下面的例子将用户 mcmohd 的用户名修改为 mcmohd20，主目录修改为 /home/mcmohd20：<br>$ usermod -d /home/mcmohd20 -m -l mcmohd mcmohd20</p>
<h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户**"></a><strong>删除用户<em>**</em></strong></h4><p>userdel 命令可以用来删除现有用户。userdel 是一个危险的命令，请谨慎使用。<br>userdel 命令仅有一个选项 -r，用来删除用户主目录和本地邮件。例如，删除用户  mcmohd20：<br>$ userdel -r mcmohd20<br>为了便于恢复被误删的用户，可以忽略 -r 选项，保留用户主目录，之后确认无误可以随时删除主目录。</p>
<h1 id="Linux系统性能分析"><a href="#Linux系统性能分析" class="headerlink" title="Linux系统性能分析**"></a><strong>Linux系统性能分析<em>**</em></strong></h1><p>这篇教程的目的是向大家介绍一些免费的系统性能分析工具（命令），使用这些工具可以监控系统资源使用情况，便于发现性能瓶颈。<br>系统的整体性能取决于各种资源的平衡，类似木桶理论，某种资源的耗尽会严重阻碍系统的性能。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/hexo-blog//2017/07/05/linux-base/linux43471.png" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure><br>Linux中需要监控的资源主要有 CPU、主存（内存）、硬盘空间、I/O时间、网络时间、应用程序等。<br>影响系统性能的主要因素有：<br>| <strong>因素<em>**</em></strong>  | <strong>说明<em>**</em></strong>                               |<br>| ———– | —————————————- |<br>| 用户态CPU      | CPU在用户态运行用户程序所花费的时间，包括库调用，但是不包括内核花费的时间。  |<br>| 内核态CPU      | CPU在内核态运行系统服务所花费的时间。所有的 I/O 操作都需要调用系统服务，程序员可以通过阻塞 I/O 传输来影响这部分的时间。 |<br>| I/O 时间和网络时间 | 响应 I/O 请求、处理网络连接所花费的时间。                  |<br>| 内存          | 切换上下文和交换数据（虚拟内存页导入和导出）花费的时间。             |<br>| 应用程序        | 程序等待运行的时间——CPU正在运行其他程序，等待切换到当前程序。        |<br>说明：一般认为用户态CPU和内核态CPU花费的时间小于70%时是良好状态。<br>下面的命令可以用来监控系统性能并作出相应调整：<br>| <strong>命令<em>**</em></strong> | <strong>说明<em>**</em></strong>                               |<br>| ———- | —————————————- |<br>| nice       | 启动程序时指定进程优先级。                            |<br>| renice     | 调整现有进程的优先级。                              |<br>| netstat    | 显示各种网络相关信息，包括网络连接情况、路由表、接口状态(Interface Statistics)、masquerade 连接、多播成员 (Multicast Memberships)等。实际上，netstat 用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。 |<br>| time       | 检测一个命令运行时间以及资源（CPU、内存、I/O等）使用情况。         |<br>| uptime     | 查看系统负载情况。                                |<br>| ps         | 查看系统中进程的资源使用情况（瞬时状态，不是动态监控）。             |<br>| vmstat     | 报告虚拟内存使用情况。                              |<br>| gprof      | 精确分析程序的性能，能给出函数调用时间、调用次数、调用关系等。          |<br>| top        | 实时监控系统中各个进程资源的资源使用情况。                    |<br>常用命令组合：<br>· vmstat、sar、mpstat检测是否存在CPU瓶颈；<br>· vmstat、free检测是否存在内存瓶颈；<br>· iostat检测是否存在磁盘I/O瓶颈；<br>· netstat检测是否存在网络I/O瓶颈。</p>
<h1 id="Linux系统日志及日志分析"><a href="#Linux系统日志及日志分析" class="headerlink" title="Linux系统日志及日志分析**"></a><strong>Linux系统日志及日志分析<em>**</em></strong></h1><p>Linux系统拥有非常灵活和强大的日志功能，可以保存几乎所有的操作记录，并可以从中检索出我们需要的信息。<br>大部分Linux发行版默认的日志守护进程为 syslog，位于 /etc/syslog 或 /etc/syslogd，默认配置文件为 /etc/syslog.conf，任何希望生成日志的程序都可以向 syslog 发送信息。<br>Linux系统内核和许多程序会产生各种错误信息、警告信息和其他的提示信息，这些信息对管理员了解系统的运行状态是非常有用的，所以应该把它们写到日志文件中去。完成这个过程的程序就是syslog。syslog可以根据日志的类别和优先级将日志保存到不同的文件中。例如，为了方便查阅，可以把内核信息与其他信息分开，单独保存到一个独立的日志文件中。默认配置下，日志文件通常都保存在“/var/log”目录下。</p>
<h3 id="日志类型"><a href="#日志类型" class="headerlink" title="日志类型**"></a><strong>日志类型<em>**</em></strong></h3><p>下面是常见的日志类型，但并不是所有的Linux发行版都包含这些类型：<br>| <strong>类型<em>**</em></strong>    | <strong>说明<em>**</em></strong>                               |<br>| ————- | —————————————- |<br>| auth          | 用户认证时产生的日志，如login命令、su命令。                |<br>| authpriv      | 与 auth 类似，但是只能被特定用户查看。                   |<br>| console       | 针对系统控制台的消息。                              |<br>| cron          | 系统定期执行计划任务时产生的日志。                        |<br>| daemon        | 某些守护进程产生的日志。                             |<br>| ftp           | FTP服务。                                   |<br>| kern          | 系统内核消息。                                  |<br>| local0.local7 | 由自定义程序使用。                                |<br>| lpr           | 与打印机活动有关。                                |<br>| mail          | 邮件日志。                                    |<br>| mark          | 产生时间戳。系统每隔一段时间向日志文件中输出当前时间，每行的格式类似于 May 26 11:17:09 rs2 – MARK –，可以由此推断系统发生故障的大概时间。 |<br>| news          | 网络新闻传输协议(nntp)产生的消息。                     |<br>| ntp           | 网络时间协议(ntp)产生的消息。                        |<br>| user          | 用户进程。                                    |<br>| uucp          | UUCP子系统。                                 |</p>
<h3 id="日志优先级"><a href="#日志优先级" class="headerlink" title="日志优先级**"></a><strong>日志优先级<em>**</em></strong></h3><p>常见的日志优先级请见下标：<br>| <strong>优先级<em>**</em></strong> | <strong>说明<em>**</em></strong>                    |<br>| ———– | —————————– |<br>| emerg       | 紧急情况，系统不可用（例如系统崩溃），一般会通知所有用户。 |<br>| alert       | 需要立即修复，例如系统数据库损坏。             |<br>| crit        | 危险情况，例如硬盘错误，可能会阻碍程序的部分功能。     |<br>| err         | 一般错误消息。                       |<br>| warning     | 警告。                           |<br>| notice      | 不是错误，但是可能需要处理。                |<br>| info        | 通用性消息，一般用来提供有用信息。             |<br>| debug       | 调试程序产生的信息。                    |<br>| none        | 没有优先级，不记录任何日志消息。              |</p>
<h3 id="常见日志文件"><a href="#常见日志文件" class="headerlink" title="常见日志文件**"></a><strong>常见日志文件<em>**</em></strong></h3><p>所有的系统应用都会在 /var/log 目录下创建日志文件，或创建子目录再创建日志文件。例如：<br>| <strong>文件/目录<em>**</em></strong>     | <strong>说明<em>**</em></strong>                              |<br>| —————– | ————————————— |<br>| /var/log/boot.log | 开启或重启日志。                                |<br>| /var/log/cron     | 计划任务日志                                  |<br>| /var/log/maillog  | 邮件日志。                                   |<br>| /var/log/messages | 该日志文件是许多进程日志文件的汇总，从该文件可以看出任何入侵企图或成功的入侵。 |<br>| /var/log/httpd 目录 | Apache HTTP 服务日志。                       |<br>| /var/log/samba 目录 | samba 软件日志                              |</p>
<h3 id="etc-syslog-conf-文件"><a href="#etc-syslog-conf-文件" class="headerlink" title="/etc/syslog.conf 文件**"></a><strong>/etc/syslog.conf 文件<em>**</em></strong></h3><p>/etc/syslog.conf 是 syslog 的配置文件，会根据日志类型和优先级来决定将日志保存到何处。典型的 syslog.conf 文件格式如下所示：<br><em>.err;kern.debug;auth.notice /dev/console<br>daemon,auth.notice           /var/log/messages<br>lpr.info                     /var/log/lpr.log<br>mail.</em>                       /var/log/mail.log<br>ftp.<em>                        /var/log/ftp.log<br>auth.</em>                       @see.xidian.edu.cn<br>auth.<em>                       root,amrood<br>netinfo.err                  /var/log/netinfo.log<br>install.</em>                    /var/log/install.log<br><em>.emerg                      </em><br><em>.alert                      |program_name<br>mark.</em>                       /dev/console<br>第一列为日志类型和日志优先级的组合，每个类型和优先级的组合称为一个选择器；后面一列为保存日志的文件、服务器，或输出日志的终端。syslog 进程根据选择器决定如何操作日志。<br>对配置文件的几点说明：<br>· 日志类型和优先级由点号(.)分开，例如 kern.debug 表示由内核产生的调试信息。<br>· kern.debug 的优先级大于 debug。<br>· 星号(<em>)表示所有，例如 </em>.debug 表示所有类型的调试信息，kern.* 表示由内核产生的所有消息。<br>· 可以使用逗号(,)分隔多个日志类型，使用分号(;)分隔多个选择器。<br>对日志的操作包括：<br>· 将日志输出到文件，例如 /var/log/maillog 或 /dev/console。<br>· 将消息发送给用户，多个用户用逗号(,)分隔，例如 root, amrood。<br>· 通过管道将消息发送给用户程序，注意程序要放在管道符(|)后面。<br>· 将消息发送给其他主机上的 syslog 进程，这时 /etc/syslog.conf 文件后面一列为以@开头的主机名，例如@see.xidian.edu.cn。</p>
<h3 id="logger-命令"><a href="#logger-命令" class="headerlink" title="logger 命令**"></a><strong>logger 命令<em>**</em></strong></h3><p>logger 是Shell命令，可以通过该命令使用 syslog 的系统日志模块，还可以从命令行直接向系统日志文件写入一行信息。<br>logger命令的语法为：<br>logger [-i] [-f filename] [-p priority] [-t tag] [message…]<br>每个选项的含义如下：<br>| <strong>选项<em>**</em></strong>  | <strong>说明<em>**</em></strong>                               |<br>| ———– | —————————————- |<br>| -f filename | 将 filename 文件的内容作为日志。                    |<br>| -i          | 每行都记录 logger 进程的ID。                      |<br>| -p priority | 指定优先级；优先级必须是形如 facility.priority 的完整的选择器，默认优先级为 user.notice。 |<br>| -t tag      | 使用指定的标签标记每一个记录行。                         |<br>| message     | 要写入的日志内容，多条日志以空格为分隔；如果没有指定日志内容，并且 -f filename 选项为空，那么会把标准输入作为日志内容。 |<br>例如，将ping命令的结果写入日志：<br>$ ping 192.168.0.1 | logger -it logger_test -p local3.notice&amp;<br>$ tail -f /var/log/userlog<br>Oct 6 12:48:43 kevein logger_test[22484]: PING 192.168.0.1 (192.168.0.1) 56(84) bytes of data.<br>Oct 6 12:48:43 kevein logger_test[22484]: 64 bytes from 192.168.0.1: icmp_seq=1 ttl=253 time=49.7 ms<br>Oct 6 12:48:44 kevein logger_test[22484]: 64 bytes from 192.168.0.1: icmp_seq=2 ttl=253 time=68.4 ms<br>Oct 6 12:48:45 kevein logger_test[22484]: 64 bytes from 192.168.0.1: icmp_seq=3 ttl=253 time=315 ms<br>Oct 6 12:48:46 kevein logger_test[22484]: 64 bytes from 192.168.0.1: icmp_seq=4 ttl=253 time=279 ms<br>Oct 6 12:48:47 kevein logger_test[22484]: 64 bytes from 192.168.0.1: icmp_seq=5 ttl=253 time=347 ms<br>Oct 6 12:48:49 kevein logger_test[22484]: 64 bytes from 192.168.0.1: icmp_seq=6 ttl=253 time=701 ms<br>Oct 6 12:48:50 kevein logger_test[22484]: 64 bytes from 192.168.0.1: icmp_seq=7 ttl=253 time=591 ms<br>Oct 6 12:48:51 kevein logger_test[22484]: 64 bytes from 192.168.0.1: icmp_seq=8 ttl=253 time=592 ms<br>Oct 6 12:48:52 kevein logger_test[22484]: 64 bytes from 192.168.0.1: icmp_seq=9 ttl=253 time=611 ms<br>Oct 6 12:48:53 kevein logger_test[22484]: 64 bytes from 192.168.0.1: icmp_seq=10 ttl=253 time=931 ms<br>ping命令的结果成功输出到 /var/log/userlog 文件。<br>命令 logger -it logger_test -p local3.notice 各选项的含义：<br>· -i：在每行都记录进程ID；<br>· -t logger_test：每行记录都加上“logger_test”这个标签；<br>· -p local3.notice：设置日志类型和优先级。</p>
<h3 id="日志转储"><a href="#日志转储" class="headerlink" title="日志转储**"></a><strong>日志转储<em>**</em></strong></h3><p>日志转储也叫日志回卷或日志轮转。Linux中的日志通常增长很快，会占用大量硬盘空间，需要在日志文件达到指定大小时分开存储。<br>syslog 只负责接收日志并保存到相应的文件，但不会对日志文件进行管理，因此经常会造成日志文件过大，尤其是WEB服务器，轻易就能超过1G，给检索带来困难。<br>大多数Linux发行版使用 logrotate 或 newsyslog 对日志进行管理。logrotate 程序不但可以压缩日志文件，减少存储空间，还可以将日志发送到指定 E-mail，方便管理员及时查看日志。<br>例如，规定邮件日志 /var/log/maillog 超过1G时转储，每周一次，那么每隔一周 logrotate 进程就会检查 /var/log/maillog 文件的大小：<br>· 如果没有超过1G，不进行任何操作。<br>· 如果在1G~2G之间，就会创建新文件 /var/log/maillog.1，并将多出的1G日志转移到该文件，以给 /var/log/maillog 文件瘦身。<br>· 如果在2G~3G之间，会继续创建新文件 /var/log/maillog.2，并将 /var/log/maillog.1 的内容转移到该文件，将 /var/log/maillog 的内容转移到 /var/log/maillog.1，以保持 /var/log/maillog 文件不超过1G。<br>可以看到，每次转存都会创建一个新文件（如果不存在），命名格式为日志文件名加一个数字（从1开始自动增长），以保持当前日志文件和转存后的日志文件不超过指定大小。<br>logrotate 的主要配置文件是 /etc/logrotate.conf，/etc/logrotate.d 目录是对 /etc/logrotate.conf 的补充，或者说为了不使 /etc/logrotate.conf 过大而设置。<br>可以通过 cat 命令查看它的内容：<br>$cat /etc/logrotate.conf<br># see “man logrotate” for details  //可以查看帮助文档<br># rotate log files weekly<br>weekly                             //设置每周转储一次<br># keep 4 weeks worth of backlogs<br>rotate 4                           //最多转储4次<br># create new (empty) log files after rotating old ones<br>create                             //当转储后文件不存储时创建它<br># uncomment this if you want your log files compressed<br>#compress                          //以压缩方式转储<br># RPM packages drop log rotation information into this directory<br>include /etc/logrotate.d           //其他日志文件的转储方式，包含在该目录下<br># no packages own wtmp – we’ll rotate them here<br>/var/log/wtmp {                    //设置/var/log/wtmp日志文件的转储参数<br>​    monthly                        //每月转储<br>​    create 0664 root utmp          //转储后文件不存在时创建它，文件所有者为root，所属组为utmp，对应的权限为0664<br>​    rotate 1                       //最多转储一次<br>}<br>注意：include 允许管理员把多个分散的文件集中到一个，类似于C语言的 #include，将其他文件的内容包含进当前文件。<br>include 非常有用，一些程序会把转储日志的配置文件放在 /etc/logrotate.d 目录，这些配置文件会覆盖或增加 /etc/logrotate.conf 的配置项，如果没有指定相关配置，那么采用 /etc/logrotate.conf 的默认配置。<br>所以，建议将 /etc/logrotate.conf 作为默认配置文件，第三方程序在 /etc/logrotate.d 目录下自定义配置文件。<br>logrotate 也可以作为命令直接运行来修改配置文件。</p>
<h1 id="Linux信号机制与信号处理"><a href="#Linux信号机制与信号处理" class="headerlink" title="Linux信号机制与信号处理**"></a><strong>Linux信号机制与信号处理<em>**</em></strong></h1><p>信号(signal)是Linux进程间通信的一种机制，全称为软中断信号，也被称为软中断。信号本质上是在软件层次上对硬件中断机制的一种模拟。<br>与其他进程间通信方式（例如管道、共享内存等）相比，信号所能传递的信息比较粗糙，只是一个整数。但正是由于传递的信息量少，信号也便于管理和使用，可以用于系统管理相关的任务，例如通知进程终结、中止或者恢复等。<br>每种信号用一个整型常量宏表示，以SIG开头，比如SIGCHLD、SIGINT等，它们在系统头文件<signal.h>中定义。<br>信号由内核(kernel)管理，产生方式多种多样：<br>· 可以由内核自身产生，比如出现硬件错误、内存读取错误，分母为0的除法等，内核需要通知相应进程。<br>· 也可以由其他进程产生并发送给内核，再由内核传递给目标进程。<br>信号传递的过程：<br>· 内核中针对每一个进程都有一个表来保存信号。<br>· 当内核需要将信号传递给某个进程时，就在该进程对应的表中写入信号，这样就生成了信号。<br>· 当该进程由用户态陷入内核态，再次切换到用户态之前，会查看表中的信号。如果有信号，进程就会首先执行信号对应的操作，此时叫做执行信号。<br>· 从生成信号到将信号传递给对应进程这段时间，信号处于等待状态。<br>· 我们可以编写代码，让进程阻塞(block)某些信号，也就是让这些信号始终处于等待的状态，直到进程取消阻塞(unblock)或者忽略信号。</signal.h></p>
<h2 id="信号种类"><a href="#信号种类" class="headerlink" title="信号种类**"></a><strong>信号种类<em>**</em></strong></h2><p>下表列出了一些常见信号：<br>| <strong>信号名称<em>**</em></strong> | <strong>数字表示<em>**</em></strong> | <strong>说明<em>**</em></strong>                               |<br>| ———— | ———— | —————————————- |<br>| SIGHUP       | 1            | 终端挂起或控制进程终止。当用户退出Shell时，由该进程启动的所有进程都会收到这个信号，默认动作为终止进程。 |<br>| SIGINT       | 2            | 键盘中断。当用户按下<ctrl+c>组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号。默认动作为终止进程。 |<br>| SIGQUIT      | 3            | 键盘退出键被按下。当用户按下<ctrl+d>或<ctrl+\>组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号。默认动作为退出程序。 |<br>| SIGFPE       | 8            | 发生致命的运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为0等所有的算法错误。默认动作为终止进程并产生core文件。 |<br>| SIGKILL      | 9            | 无条件终止进程。进程接收到该信号会立即终止，不进行清理和暂存工作。该信号不能被忽略、处理和阻塞，它向系统管理员提供了可以杀死任何进程的方法。 |<br>| SIGALRM      | 14           | 定时器超时，默认动作为终止进程。                         |<br>| SIGTERM      | 15           | 程序结束信号，可以由 kill 命令产生。与SIGKILL不同的是，SIGTERM 信号可以被阻塞和终止，以便程序在退出前可以保存工作或清理临时文件等。 |<br>通过 kill -l 命令可以查看系统支持的所有信号：<br>$ kill -l<br>1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL<br>5) SIGTRAP      6) SIGABRT      7) SIGBUS       8) SIGFPE<br>9) SIGKILL     10) SIGUSR1     11) SIGSEGV     12) SIGUSR2<br>13) SIGPIPE     14) SIGALRM     15) SIGTERM     16) SIGSTKFLT<br>17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP<br>21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU<br>25) SIGXFSZ     26) SIGVTALRM   27) SIGPROF     28) SIGWINCH<br>29) SIGIO       30) SIGPWR      31) SIGSYS      34) SIGRTMIN<br>35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3  38) SIGRTMIN+4<br>39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8<br>43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12<br>47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14<br>51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10<br>55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7  58) SIGRTMAX-6<br>59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2<br>63) SIGRTMAX-1  64) SIGRTMAX<br>上面仅是一个演示，不同的Linux发行版支持的信号可能不同。<br>每种信号都会有一个默认动作。默认动作就是脚本或程序接收到该信号所做出的默认操作。常见的默认动作有终止进程、退出程序、忽略信号、重启暂停的进程等，上表中也对部分默认动作进行了说明。</ctrl+\></ctrl+d></ctrl+c></p>
<h2 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号**"></a><strong>发送信号<em>**</em></strong></h2><p>有多种方式可以向程序或脚本发送信号，例如按下<ctrl+c>组合键会发送SIGINT信号，终止当前进程。<br>还可以通过 kill 命令发送信号，语法为：<br>$ kill -signal pid<br>signal为要发送的信号，可以是信号名称或数字；pid为接收信号的进程ID。例如：<br>$ kill -1 1001<br>将SIGHUP信号发送给进程ID为1001的程序，程序会终止执行。<br>又如，强制杀死ID为1001的进程：<br>$ kill -9 1001</ctrl+c></p>
<h2 id="捕获信号"><a href="#捕获信号" class="headerlink" title="捕获信号**"></a><strong>捕获信号<em>**</em></strong></h2><p>通常情况下，直接终止进程并不是我们所希望的。例如，按下<ctrl+c>，进程被立即终止，不会清理创建的临时文件，带来系统垃圾，也不会保存正在进行的工作，导致需要重做。<br>可以通过编程来捕获这些信号，当终止信号出现时，可以先进行清场和保存处理，再退出程序。<br>用户程序可以通过C/C++等代码捕获信号，这将在Linux C编程中进行讲解，这里仅介绍如果通过Linux命令捕获信号。<br>通过 trap 命令就可以捕获信号，语法为：<br>$ trap commands signals<br>commands为Linux系统命令或用户自定义命令；signals为要捕获的信号，可以为信号名称或数字。<br>捕获到信号后，可以有三种处理：<br>· 执行一段脚本来做一些处理工作，例如清理临时文件；<br>· 接受（恢复）信号的默认操作；<br>· 忽略当前信号。</ctrl+c></p>
<h4 id="1-清理临时文件"><a href="#1-清理临时文件" class="headerlink" title="1) 清理临时文件**"></a><strong>1) 清理临时文件<em>**</em></strong></h4><p>脚本捕获到终止信号后一个常见的动作就是清理临时文件。例如：<br>$ trap “rm -f $WORKDIR/work1$$ $WORKDIR/dataout$$; exit” 2<br>当用户按下<ctrl+c>后，脚本先清理临时文件 work1$$ 和 dataout$$ 再退出。<br>注意：exit 命令是必须的，否则脚本捕获到信号后会继续执行而不是退出。<br>修改上面的脚本，使接收到 SIGHUP 时进行同样的操作：<br>$ trap “rm $WORKDIR/work1$$ $WORKDIR/dataout$$; exit” 1 2<br>几点注意：<br>· 如果执行多个命令，需要将命令用引号包围；<br>· 只有脚本执行到 trap 命令时才会捕获信号；<br>· 再次接收到信号时还会执行同样的操作。<br>上面的脚本，执行到 trap 命令时就会替换 WORKDIR 和 $$ 的值。如果希望接收到 SIGHUP 或 SIGINT 信号时再替换其值，那么可以将命令放在单引号内，例如：<br>$ trap ‘rm $WORKDIR/work1$$ $WORKDIR/dataout$$; exit’ 1 2</ctrl+c></p>
<h4 id="2-忽略信号"><a href="#2-忽略信号" class="headerlink" title="2) 忽略信号**"></a><strong>2) 忽略信号<em>**</em></strong></h4><p>如果 trap 命令的 commands 为空，将会忽略接收到的信号，即不做任何处理，也不执行默认动作。例如：<br>$ trap ‘’ 2<br>也可以同时忽略多个信号：<br>$ trap ‘’ 1 2 3 15<br>注意：必须被引号包围，不能写成下面的形式：<br>$ trap  2</p>
<h4 id="3-恢复默认动作"><a href="#3-恢复默认动作" class="headerlink" title="3) 恢复默认动作**"></a><strong>3) 恢复默认动作<em>**</em></strong></h4><p>如果希望改变信号的默认动作后再次恢复默认动作，那么省略 trap 命令的 commands 即可，例如：<br>$ trap 1 2<br>将恢复SIGHUP 和 SIGINT 信号的默认动作。</p>

        </div>

        <blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2017-07-06T02:09:04.437Z" itemprop="dateUpdated">2017-07-06 10:09:04</time>
</span><br>


        
        这里可以写作者留言，标签和 hexo 中所有变量及辅助函数等均可调用，示例：<a href="/hexo-blog/2017/07/05/linux-base/" target="_blank" rel="external">http://yoursite.com/2017/07/05/linux-base/</a>
        
    </div>
    <footer>
        <a href="http://yoursite.com">
            <img src="/hexo-blog/img/avatar.jpg" alt="Peony7">
            Peony7
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            

            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2017/07/05/linux-base/&title=《Linux入门教程》 — Peony7的博客乐园&pic=http://yoursite.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2017/07/05/linux-base/&title=《Linux入门教程》 — Peony7的博客乐园&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/2017/07/05/linux-base/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Linux入门教程》 — Peony7的博客乐园&url=http://yoursite.com/2017/07/05/linux-base/&via=http://yoursite.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://yoursite.com/2017/07/05/linux-base/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between flex-row-reverse">
  

  
    <div class="waves-block waves-effect next">
      <a href="/hexo-blog/2017/07/04/shell-base/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">C语言中文网：Shell教程</h4>
      </a>
    </div>
  
</nav>



    







<section class="comments" id="comments">
    <!-- UY BEGIN -->
    <div id="uyan_frame"></div>
    <script src="http://v2.uyan.cc/code/uyan.js?uid=2132789"></script>
    <!-- UY END -->
</section>







</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷~
        <i class="icon icon-quote-right"></i>
    </h3>
    <ul class="reward-items">
        
        <li>
            <img src="/hexo-blog/img/wechat.jpg" title="微信打赏二维码" alt="微信打赏二维码">
            <p>微信</p>
        </li>
        

        
        <li>
            <img src="/hexo-blog/img/alipay.jpg" title="支付宝打赏二维码" alt="支付宝打赏二维码">
            <p>支付宝</p>
        </li>
        
    </ul>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/hexo-blog/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>This blog is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>
    <div class="bottom">
        <p>
            <span>Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a></span>
            <span>Peony7 &copy; 2017</span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2017/07/05/linux-base/&title=《Linux入门教程》 — Peony7的博客乐园&pic=http://yoursite.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2017/07/05/linux-base/&title=《Linux入门教程》 — Peony7的博客乐园&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/2017/07/05/linux-base/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Linux入门教程》 — Peony7的博客乐园&url=http://yoursite.com/2017/07/05/linux-base/&via=http://yoursite.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://yoursite.com/2017/07/05/linux-base/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAACuCAAAAACKZ2kyAAABwUlEQVR42u3aQW7DMAwEwPz/0y3Qa2F7SUqqC4xPQRPbox4EcqnPJ76+fq6rz1d/+X1d3bX4wsXFHXPzF1zddf+c+9/nBlxc3PPcZPNKlnG/8SX0BxsuLu7LuEkB1HsmLi7u/+UmZcq8ocLFxX0Pdx5kRK3LIEzBxcU9yZ0HpvPPR/NdXFzcwVRibRSy4O24uLhHuL1QozpWSd6S/1NwcXF3c5NW555YbXvy+PVyC8PFxd3MnZcjecwxCV4fShxcXNxt3N7Rq3yR1eIpyndxcXG3cecD0WSpeReTPwcXF3cH977IyMel862nMA3GxcXdzF1bXhTGIcWgBBcX9yS3ejSq2g71aq7Lu3BxcQ9ye4elqkXPJBDBxcX9W+48MM0PVeSlFS4u7kluvvVUo88J7iF4xcXF3cxNmpbdB7MK7RYuLu5BbnWwmiwv2kGrYS4uLu5Bbn5Vj1bMQ5PyrAYXF3fM7R3Mqh7Jyun5t7i4uLu5+ebV20/y419RK4WLi3uQ2ytHquHIglIGFxf3Zdy8rKkOYApNES4u7uu5vTKlWdzg4uIe5042l17A0fwlLi7uEW6146gOWqqLXBDK4OLi9rnfznoGHHasEYgAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/hexo-blog/', SHARE: true, REWARD: true };



</script>

<script src="/hexo-blog/js/main.min.js?v=1.6.5"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/hexo-blog/js/search.min.js?v=1.6.5" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = 'Peony7的博客乐园';
            clearTimeout(titleTime);
        } else {
            document.title = 'Peony7的博客乐园';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
