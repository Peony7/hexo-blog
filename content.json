{"meta":{"title":"Peony7的博客乐园","subtitle":null,"description":null,"author":"Peony7","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2017-05-04T09:05:08.000Z","updated":"2017-05-04T10:44:08.950Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-05-04T09:05:26.000Z","updated":"2017-05-04T10:44:29.999Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"form表单回车提交问题","slug":"html-form-submit","date":"2017-09-10T16:00:00.000Z","updated":"2017-09-11T09:57:39.024Z","comments":true,"path":"2017/09/11/html-form-submit/","link":"","permalink":"http://yoursite.com/2017/09/11/html-form-submit/","excerpt":"","text":"form表单回车提交问题,JS监听回车事件我们有时候希望回车键敲在文本框（input element）里来提交表单（form），但有时候又不希望如此。比如搜索行为，希望输入完关键词之后直接按回车键立即提交表单，而有些复杂表单，可能要避免回车键误操作在未完成表单填写的时候就触发了表单提交。要控制这些行为，不需要借助JS，浏览器已经帮我们做了这些处理，这里总结几条规则： 如果表单里有一个type=”submit”的按钮，回车键生效。 如果表单里只有一个type=”text”的input，不管按钮是什么type，回车键生效。 如果按钮不是用input，而是用button，并且没有加type，IE下默认为type=button，FX默认为type=submit。 其他表单元素如textarea、select不影响，radio checkbox不影响触发规则，但本身在FX下会响应回车键，在IE下不响应。 type=”image”的input，效果等同于type=”submit”，不知道为什么会设计这样一种type，不推荐使用，应该用CSS添加背景图合适些。 我们在处理表单的页面可以检验他是否点击了按钮来控制下面的程序。if($_POST[‘submit’]){ 如果点击了按钮 程序继续}实际应用的时候，要让表单响应回车键很容易，保证表单里有个type=”submit”的按钮就行。而当只有一个文本框又不希望响应回车键怎么办 呢？我的方法有点别扭，就是再写一个无意义的文本框，隐藏起来。根据第3条规则，我们在用button的时候，尽量显式声明type以使浏览器表现一致。 通过以上可知只要把type=”submit”改成type=”button”然后js提交， 在不要有一个type=”text”的input就行了。就不会发生回车跳转。 但实验发现，ie和火狐不一样，火狐的submit按钮有掩藏的（display：block）和显现的都不行，必须全改，但ie只要显现的没有submit就行了。 12345678910111213&lt;script type=\"text/javascript\"&gt; document.onkeydown=keyDownSearch; function keyDownSearch(e) &#123; // 兼容FF和IE和Opera var theEvent = e || window.event; var code = theEvent.keyCode || theEvent.which || theEvent.charCode; if (code == 13) &#123; DoSomeThing();//具体处理函数 return false; &#125; return true; &#125; &lt;/script&gt; 如果只是针对某个DIV层应用回车查询的话，可以将：document.onkeydown=keyDownSearch;改成：document.getElementById(&#39;层ID&#39;).onkeydown=keyDownSearch; http://www.cnblogs.com/suizhikuo/p/4925086.html","categories":[{"name":"html","slug":"html","permalink":"http://yoursite.com/categories/html/"}],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"CSS 实现隐藏滚动条同时又可以滚动","slug":"css-scrollbar","date":"2017-08-24T16:00:00.000Z","updated":"2017-08-25T03:16:01.986Z","comments":true,"path":"2017/08/25/css-scrollbar/","link":"","permalink":"http://yoursite.com/2017/08/25/css-scrollbar/","excerpt":"","text":"CSS 实现隐藏滚动条同时又可以滚动移动端页面为了更接近原生的体验，是否可以隐藏滚动条，同时又保证页面可以滚动？ 使用 overflow:hidden 隐藏滚动条，但存在的问题是：页面或元素失去了滚动的特性。由于只需要兼容移动浏览器（Chrome 和 Safari），于是想到了自定义滚动条的伪对象选择器::-webkit-scrollbar。 关于这个选择器的介绍可以参考：Styling ScrollbarsCustom Scrollbars in WebKit 应用如下 CSS 可以隐藏滚动条： 1.element::-webkit-scrollbar &#123;display:none&#125; 如果要兼容 PC 其他浏览器（IE、Firefox 等），国外一位才人 John Kurlak 也研究出了一种办法。在容器外面再嵌套一层 overflow:hidden 内部内容再限制尺寸和外部嵌套层一样，就变相隐藏了。 123456789101112131415161718192021222324 &lt;div class=&quot;outer-container&quot;&gt; &lt;div class=&quot;inner-container&quot;&gt; &lt;div class=&quot;content&quot;&gt; ...... &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;.outer-container,.content &#123; width: 200px; height: 200px;&#125;.outer-container &#123; position: relative; overflow: hidden;&#125;.inner-container &#123; position: absolute; left: 0; overflow-x: hidden; overflow-y: scroll;&#125; /* for Chrome */.inner-container::-webkit-scrollbar &#123; display: none;&#125; 参考Hiding Vertical Scrollbars with Pure CSS in Chrome, IE (6+), Firefox, Opera, and Safari https://blog.niceue.com/front-end-development/hide-scrollbar-but-still-scrollable-using-css.html","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"scrollbar","slug":"scrollbar","permalink":"http://yoursite.com/tags/scrollbar/"}]},{"title":"viewports","slug":"viewports","date":"2017-08-10T16:00:00.000Z","updated":"2017-08-11T06:39:16.699Z","comments":true,"path":"2017/08/11/viewports/","link":"","permalink":"http://yoursite.com/2017/08/11/viewports/","excerpt":"","text":"原文: http://www.w3cplus.com/css/viewports.html 桌面浏览器的特性screen.width/height(屏幕尺寸) 含义：用户的屏幕的完整大小。 度量：设备的pixels。 兼容性问题：IE8里，不管使用IE7模式还是IE8模式，都以CSS的pixels来度量 window.innerWidth/Height(浏览器尺寸) 含义：包含滚动条尺寸的浏览器完整尺寸 度量：CSS的pixels 兼容性问题：IE不支持，Opera用设备pixels来度量 window.pageX/YOffset(滚动位移) 含义：页面的移位 度量：CSS的pixels 兼容性问题：pageXOffset 和 pageYOffset 在 IE 8 及之前版本的IE不支持, 使用”document.body.scrollLeft” and “document.body.scrollTop” 来取代 document. documentElement. clientWidth/Height(viewport的尺寸) 含义：viewport的尺寸 度量：CSS的pixels 兼容性问题：无 为&lt;html&gt;元素赋值25%。但document. documentElement. clientWidth/Height的值不变。它虽然貌似从&lt;html&gt;元素取值，但实际描述的确是viewport的尺寸。 document. documentElement. offsetWidth/Height(&lt;html&gt;的尺寸) 含义：&lt;html&gt;的尺寸 度量：CSS的pixels 兼容性问题：IE用这个值标示viewport的尺寸而非&lt;html&gt; 如果你为&lt;html&gt;元素赋值了宽度，offsetWidth会真实的反应出来。 pageX/Y, clientX/Y, screenX/Y(事件坐标) 含义：见下文 度量：见下文 兼容性问题：IE不支持pageX/Y,IE使用CSSpixels来度量screanX/Y 详细描述: pageX/Y：从&lt;html&gt;原点到事件触发点的CSS的 pixels clientX/Y：从viewport原点（浏览器窗口）到事件触发点的CSS的 pixels screenX/Y：从用户显示器窗口原点到事件触发点的设备 的 pixels。 mediaqueries(Media查询) 含义：见下文 度量：见下文 兼容性问题：IE不支持. 详情描述: device-width/height使用screen.width/height来做为的判定值。该值以设备的pixels来度量 width/height使用documentElement.clientWidth/Height即viewport的值。该值以CSS的pixels来度量 在桌面浏览器中使用width而忘记device-width 移动设备浏览器的问题两种viewport因此viewport太窄，不能很好为你的基本CSS布局服务了。最显然的解决方式是让viewport更宽。因此这个需求分为了2个方面：虚拟的visualviewport和布局的layoutviewport。 document. documentElement. clientWidth/Height(度量layout viewviewport)的尺寸 含义：layoutviewport尺寸 度量：CSS的pixels 完整支持：Opera, iPhone, Android, Symbian, Bolt, MicroB, Skyfire, Obigo 问题：在Iris上它标示visualvieport 三星的Webkit核心浏览器，仅当在页面上写入&lt;meta viewport&gt;标签，才正确表示。否则就代表着 FireFox以设备的pixels来度量 IE返回1024 x 768 px，而准确的尺寸保存在document.body.clientWidth/Height NetFront仅当100%缩放时候才正确 塞班的Webkit1(在S60v3设备)不支持这些属性 不支持：黑莓 很幸运浏览器由于浏览器大战而遗留给我们2个特性对来度量这两种viewport。 旋转只关系到高度，而不是宽度。 window.innerWidth/Height(度量visual viewport) 含义：visualviewport尺寸 度量：CSS的pixels 完整支持：iPhone, Symbian, BlackBerry 问题： FireFox和Opera以设备的pixels返回该数值 Android, Bolt, MicroB, 和 NetFront 以CSS的pixels返回该数值，且为layoutviewport的值 不支持： IE，它使用document. documentElement. offsetWidh/Height来表示 三星的Webkit核心浏览器，仅当在页面上写入&lt;meta viewport&gt;标签，才正确表示。否则就代表着&lt;html&gt;的尺寸 混乱：Iris, Skyfire, Obigo返回的值不知所云 我们使用window.innerWidth/Height来度量visualviewport。显然，随着用户缩放浏览器，这值会改变，更多、更少的CSS pixels放进了屏幕。很不幸这是一个待完善的部分，许多浏览器依然没有支持对visualviewport的度量。到现在为止，没有浏览器将该度量存储在其他地方，我猜测window.innerWidth/Height会成为标准，albeit是最强力的支持者。 screen.width and screen.height(屏幕尺寸) 含义：屏幕尺寸 度量：设备的pixels 完整支持：Opera Mini, Android, Symbian, Iris, Firefox, MicroB, IE, BlackBerry 问题： Opera在Windows Mobile下只给出横向尺寸(landscape size)。在S60上工作正确。 三星的Webkit核心浏览器，仅当在页面上写入&lt;meta viewport&gt;标签，才正确表示。否则就代表着&lt;html&gt;的尺寸 iPhone和Obigo仅给出竖直尺寸(portrait sizes) Android, Bolt, MicroB, 和 NetFront 以CSS的pixels返回该数值，且为layoutviewport的值 不支持： IE，它使用document. documentElement. offsetWidh/Height来表示 - 三星的Webkit核心浏览器，仅当在页面上写入&lt;meta viewport&gt;标签，才正确表示。否则就代表着&lt;html&gt;的尺寸 混乱：Iris, Skyfire, Obigo返回的值不知所云 和pc浏览器一样，screen.width/height标示了设备屏幕的尺寸，以设备的pixels度量。和pc浏览器一样，作为web开发人员你永远不需要这些信息。你不关心屏幕的物理宽度，而关心当前有多少CSS的pixels能供你使用。 window.pageX/YOffset(滚动位移) 含义：见描述 度量：CSS的pixels 完整支持：iPhone, Android, Symbian, Iris, MicroB, Skyfire, Obigo 问题： Opera, Bolt, Firefox, and NetFront 总是返回 0. 三星的Webkit核心浏览器，仅当在页面上写入标签，才正确表示。 不支持： IE，它使用document. scrollLeft/Top来表示 你同意需要知道当前visualviewport相对于layoutviewport的距离。这就是滚动位移，如同在桌面浏览器一样，使用window.pageX/YOffset存储。 document. documentElement. offsetWidth / Height 含义：html元素的整体尺寸 度量：CSS的pixels 完整支持：Opera, iPhone, Android, Symbian, Samsung, Iris, Bolt, Firefox, MicroB, Skyfire, BlackBerry, Obigo 问题： NetFront只在100%缩放时返回正确的值. IE，使用这个特性对来表示visualviewport的尺寸。它使用document. body. clientWidth/Height来表示 和在桌面系统一样,document.documentElement.offsetWidth/Height给出了 元素以CSS的pixels度量的尺寸。 Mediaqueries(Media查询) 含义：以CSS的pixels度量&lt;html&gt;元素或以设备 的pixels度量设备 完整支持：Opera, iPhone, Android, Symbian, Samsung, Iris, Bolt, Firefox, MicroB. 不支持：Skyfire, IE, BlackBerry, NetFront, Obigo 备注： 我只测试了浏览器是否从正确的特性对里提取这些值。而特性对里的值是否正确并不在这里进行详细测试。 media查询如同桌面系统一样。width/height使用以CSS的pixels度量的layoutviewport，device-width/height使用以设备的pixels度量的设备屏幕（device screen）。 换句话说，width/height 反映document. documentElement. clientWidth/Height的值, device-width/height 反映screen.width/height. (所有浏览器遵循同样原理，即使取值是错误的)。 media查询在标识网站处于桌面浏览器、pad浏览器或手机浏览器方面很重要，而在区别不同pad和手机设备方面并不有用。 Eventcoordinates(事件坐标) 含义：见下文 度量：见下文 完整支持：Symbian, Iris 问题： Opera 只有pageX/Y，但滚动页面过远时这个值会出错。 在iPhone, Firefox, 和 BlackBerry 上clientX/Y 和pageX/Y相等 在 Android 和 MicroB screenX/Y和clientX/Y相等，也就是它们以CSS的pixels度量屏幕尺寸 在FireFox里screenX/Y值不正确 IE, BlackBerry, 和 Obigo 不支持 pageX/Y. NetFront 所以三个值都是screenX/Y. Obigo clientX/Y是screenX/Y. Samsung WebKit 总是返回pageX/Y. 未测试：Opera Mini,Bolt,Skyfire 事件坐标在桌面浏览器上多多少少是支持的。不幸的是，移动设备上在所测试的12个主流浏览器中只有Symbian WebKit 和 Iris完全正确的支持这3个坐标特性。其余浏览器多多少少都存在问题。 pageX/Y,该特性依然是基于页面的CSSpixels度量的值，如图在桌面浏览器一样，它是三个特性里面最有用的。 clientX/Y是基于visualviewport的，以CSSpixels度量的值. 这样做比较靠谱，虽然我不是很确信这样计算的好处。 screenX/Y基于设备屏幕以设备的pixels度量的值。显然，它使用和clientX/Y同样的参考，而设备的pixels没什么用。所以我们不需要在意screenX/Y,同在桌面浏览器一样，每个bit都是没用的。 Metaviewport(meta viewport) 含义：设置layoutviewport的宽度 度量：CSS的pixels 完整支持：Opera Mobile, iPhone, Android, Iris, IE, BlackBerry, Obigo 不支持：Opera Mini, Symbian, Bolt, Firefox, MicroB, NetFront 问题： Skyfire 不能处理我的测试页面。 在三星的wibkit浏览器下，出现会改变一些特性对的值。 Opera Mobile, iPhone, Samsung, and BlackBerry 不允许用户在设置viewport后再进行缩小操作（do not allow the user to zoom out.）","categories":[],"tags":[{"name":"viewports","slug":"viewports","permalink":"http://yoursite.com/tags/viewports/"}]},{"title":"Linux入门教程","slug":"linux-base","date":"2017-07-04T16:00:00.000Z","updated":"2017-07-12T03:38:01.149Z","comments":true,"path":"2017/07/05/linux-base/","link":"","permalink":"http://yoursite.com/2017/07/05/linux-base/","excerpt":"","text":"Linux是一个多用户多任务操作系统，不但被很多开发者用作个人操作系统，还大量运行在Web服务器上。该教程将带你快速了解Linux系统，包括基本概念、Linux命令、Shell脚本、常用工具等。该教程可以让你快速入门快速上手，能很快让你看到学习的效果；如果你希望深入研究Linux，成为大师，请阅读《鸟哥的Lunix私房菜》。阅读该教程之前，最好对操作系统有所了解，请查看计算机操作系统教程自行学习。学习过程中，会涉及到Linux命令和Shell脚本，如果不希望在本地搭建学习环境，那么可以在线免费体验：compileonline.comLinux有大量的命令，教程中没有一一详解，如果遇到困难，可以随时查看在线手册：http://man.linuxde.net/注意：Linux 是一个类似 Unix 的操作系统，Unix 是闭源收费的，Linux 是开源免费的，Unix 要早于 Linux，所以 Linux 的开发者也模仿了 Unix（但并没有包括Unix源码），使得Linux在外观和操作上与 Unix 非常相似。 Linux简介**Linux简介**严格的来讲，Linux 不算是一个操作系统，只是一个 Linux 系统中的内核，即计算机软件与硬件通讯之间的平台；Linux的全称是GNU/Linux，这才算是一个真正意义上的Linux系统。GNU是Richard Stallman组织的一个项目，世界各地的程序员可以变形GNU程序，同时遵循GPL协议，允许任何人任意改动。但是，修改后的程序必须遵循GPL协议。Linux 是一个多用户多任务的操作系统，也是一款自由软件，完全兼容POSIX标准，拥有良好的用户界面，支持多种处理器架构，移植方便。为程序分配系统资源，处理计算机内部细节的软件叫做操作系统或者内核。如果你希望详细了解操作系统的概念，请查看操作系统教程。用户通过Shell与Linux内核交互。Shell是一个命令行解释工具（是一个软件），它将用户输入的命令转换为内核能够理解的语言（命令）。Linux下，很多工作都是通过命令完成的，学好Linux，首先要掌握常用命令。 Linux版本**内核版本指的是在 Linus 领导下的开发小组开发出的系统内核的版本号。Linux 的每个内核版本使用形式为 x.y.zz-www 的一组数字来表示。其中： · x.y：为linux的主版本号。通常y若为奇数，表示此版本为测试版，系统会有较多bug，主要用途是提供给用户测试。· zz：为次版本号。· www：代表发行号（注意，它与发行版本号无关）。当内核功能有一个飞跃时，主版本号升级，如 Kernel2.2、2.4、2.6等。如果内核增加了少量补丁时，常常会升级次版本号，如Kernel2.6.15、2.6.20等。 一些组织或厂家将 Linux 内核与GNU软件（系统软件和工具）整合起来，并提供一些安装界面和系统设定与管理工具，这样就构成了一个发型套件，例如Ubuntu、Red Hat、Centos、Fedora、SUSE、Debian、FreeBSD等。相对于内核版本，发行套件的版本号随着发布者的不同而不同，与系统内核的版本号是相对独立的。因此把Red Hat等直接说成是Linux是不确切的，它们是Linux的发行版本，更确切地说，应该叫做“以linux为核心的操作系统软件包”。 Linux体系结构**下面是Linux体系结构的示意图： img 在所有Linux版本中，都会涉及到以下几个重要概念： · 内核：内核是操作系统的核心。内核直接与硬件交互，并处理大部分较低层的任务，如内存管理、进程调度、文件管理等。 · Shell：Shell是一个处理用户请求的工具，它负责解释用户输入的命令，调用用户希望使用的程序。 · 命令和工具：日常工作中，你会用到很多系统命令和工具，如cp、mv、cat和grep等。在Linux系统中，有250多个命令，每个命令都有多个选项；第三方工具也有很多，他们也扮演着重要角色。 · 文件和目录：Linux系统中所有的数据都被存储到文件中，这些文件被分配到各个目录，构成文件系统。Linux的目录与Windows的文件夹是类似的概念。 系统启动（开机）**如果你有一台装有Linux的电脑，通电后系统会自动启动，然后提示你登录系统，只有登录后才能进行其他操作。 登录Linux**第一次使用Linux，会看到登录的提示，如下所示： 1login: 登录步骤：**· 登录Linux必须有用户名（用户ID）和密码，如果没有，可以向管理员所要。· 在登录提示处输入用户名并回车；用户名是区分大小写的，输入时要注意。· 然后会提示你输入密码，密码也是区分大小写的。· 如果用户名和密码正确，那么会成功登录，并看到上次登录信息。1234login : amroodamrood&apos;s password:Last login: Sun Jun 14 09:32:32 2009 from 62.61.164.73$ 登录后会出现命令提示符($)，你可以输入任何命令。下面通过 cal 命令来查看日历：123456789$ cal​ June 2009Su Mo Tu We Th Fr Sa​ 1 2 3 4 5 67 8 9 10 11 12 1314 15 16 17 18 19 2021 22 23 24 25 26 2728 29 30$ 修改密码**Linux系统通过密码来保证数据和文件的安全，防止黑客破解和攻击。你可以通过以下方法来修改密码：· 输入 password 命令。· 输入你现在使用的密码。· 输入新密码。注意密码不要过于简单，简单的密码往往会为入侵者大开便利之门。· 确认密码，再输入一遍刚才的密码。1234567$ passwdChanging password for amrood(current) Linux password:******New Linux password:*******Retype new Linux password:*******passwd: all authentication tokens updated successfully$ 注意：输入的密码是看不到的，只会看到一个占位符(*)。 查看目录和文件**在Linux中，所有的数据都被保存在文件中，所有的文件又被分配到不同的目录；目录是一种类似树的结构，称为文件系统。你可以使用 ls 命令来查看当前目录下的文件和目录。下面的例子，使用了 ls 命令的 -l 选项：12345678910111213$ ls -ltotal 19621drwxrwxr-x 2 amrood amrood 4096 Dec 25 09:59 uml-rw-rw-r-- 1 amrood amrood 5341 Dec 25 08:38 uml.jpgdrwxr-xr-x 2 amrood amrood 4096 Feb 15 2006 univdrwxr-xr-x 2 root root 4096 Dec 9 2007 urlspedia-rw-r--r-- 1 root root 276480 Dec 9 2007 urlspedia.tardrwxr-xr-x 8 root root 4096 Nov 25 2007 usr-rwxr-xr-x 1 root root 3192 Nov 25 2007 webthumb.php-rw-rw-r-- 1 amrood amrood 20480 Nov 25 2007 webthumb.tar-rw-rw-r-- 1 amrood amrood 5654 Aug 9 2007 yourfile.mid-rw-rw-r-- 1 amrood amrood 166255 Aug 9 2007 yourfile.swf$ 注意：以d* 开头的为目录，如 uml、univ、urlspedia等；其他的都是文件。 查看当前用户信息**登录系统后，如果你希望知道自己的用户名（用户ID），可以使用 whoami 命令：123$ whoamiamrood$ 如果你希望了解更多关于当前用户的信息，可以使用 who am i 命令，读者可以自己尝试一下。 查看当前在线用户**如果你希望知道当前在线的用户（同时登录到系统的用户），可以使用 users、who 和 w 命令：1234567$ usersamrood bablu qadir$ whoamrood ttyp0 Oct 8 14:10 (limbo)bablu ttyp2 Oct 4 09:08 (calliope)qadir ttyp4 Oct 8 12:09 (dent)$ w 命令可以看到在线用户的更多信息，读者可以自己尝试。 退出登录**完成工作后，你需要退出系统，防止他人使用你的账户。使用 logout 命令即可退出登录，系统会清理有关信息并断开连接。 关闭系统（关机）**关系Linux系统可以使用下列命令：| 命令** | 说明** || ———- | —————————- || halt | 直接关闭系统 || init 0 | 使用预先定义的脚本关闭系统，关闭前可以清理和更新有关信息 || init 6 | 重新启动系统 || poweroff | 通过断电来关闭系统 || reboot | 重新启动系统 || shutdown | 安全关闭系统 |注意：一般情况下只有超级用户和root用户（Linux系统中的最高特权用户）才有关闭系统的权限，但是给普通用户赋予相应权限也可以关闭系统。 Linux文件管理**Linux中的所有数据都被保存在文件中，所有的文件被分配到不同的目录。目录是一种类似于树的结构，称为文件系统。当你使用Linux时，大部分时间都会和文件打交道，通过本节可以了解基本的文件操作，如创建文件、删除文件、复制文件、重命名文件以及为文件创建链接等。在Linux中，有三种基本的文件类型： 1) 普通文件**普通文件是以字节为单位的数据流，包括文本文件、源码文件、可执行文件等。文本和二进制对Linux来说并无区别，对普通文件的解释由处理该文件的应用程序进行。 2) 目录**目录可以包含普通文件和特殊文件，目录相当于Windows和Mac OS中的文件夹。 3) 设备文件**有些教程中称特殊文件，是一个含义。Linux 与外部设备（例如光驱，打印机，终端，modern等）是通过一种被称为设备文件的文件来进行通信。Linux 输入输出到外部设备的方式和输入输出到一个文件的方式是相同的。Linux 和一个外部设备通讯之前，这个设备必须首先要有一个设备文件存在。例如，每一个终端都有自己的设备文件来供 Linux 写数据（出现在终端屏幕上）和读取数据（用户通过键盘输入）。设备文件和普通文件不一样，设备文件中并不包含任何数据。 设备文件有两种类型：字符设备文件和块设备文件。· 字符设备文件以字母&quot;c&quot;开头。字符设备文件向设备传送数据时，一次传送一个字符。典型的通过字符传送数据的设备有终端、打印机、绘图仪、modern等。字符设备文件有时也被称为”raw”设备文件。· 块设备文件以字母&quot;b&quot;开头。块设备文件向设备传送数据时，先从内存中的buffer中读或写数据，而不是直接传送数据到物理磁盘。磁盘和CD-ROMS既可以使用字符设备文件也可以使用块设备文件。 查看文件**查看当前目录下的文件和目录可以使用 ls 命令，例如：12345$lsbin hosts lib res.03ch07 hw1 pub test_resultsch07.bak hw2 res.01 usersdocs hw3 res.02 work 通过 ls 命令的 -l 选项，你可以获取更多文件信息，例如：123456789101112131415$ls -ltotal 1962188drwxrwxr-x 2 amrood amrood 4096 Dec 25 09:59 uml-rw-rw-r-- 1 amrood amrood 5341 Dec 25 08:38 uml.jpgdrwxr-xr-x 2 amrood amrood 4096 Feb 15 2006 univdrwxr-xr-x 2 root root 4096 Dec 9 2007 urlspedia-rw-r--r-- 1 root root 276480 Dec 9 2007 urlspedia.tardrwxr-xr-x 8 root root 4096 Nov 25 2007 usrdrwxr-xr-x 2 200 300 4096 Nov 25 2007 webthumb-1.01-rwxr-xr-x 1 root root 3192 Nov 25 2007 webthumb.php-rw-rw-r-- 1 amrood amrood 20480 Nov 25 2007 webthumb.tar-rw-rw-r-- 1 amrood amrood 5654 Aug 9 2007 yourfile.mid-rw-rw-r-- 1 amrood amrood 166255 Aug 9 2007 yourfile.swfdrwxr-xr-x 11 amrood amrood 4096 May 29 2007 zlib-1.2.3$ 每一列的含义如下：· 第一列：文件类型。· 第二列：表示文件个数。如果是文件，那么就是1；如果是目录，那么就是该目录中文件的数目。· 第三列：文件的所有者，即文件的创建者。· 第四列：文件所有者所在的用户组。在Linux中，每个用户都隶属于一个用户组。· 第五列：文件大小（以字节计）。· 第六列：文件被创建或上次被修改的时间。· 第七列：文件名或目录名。注意：每一个目录都有一个指向它本身的子目录. 和指向它上级目录的子目录..，所以对于一个空目录，第二列应该为 2。 通过 ls -l 列出的文件，每一行都是以 a、d、- 或 l 开头，这些字符表示文件类型：| 前缀** | 描述** || ———- | —————————————- || - | 普通文件。如文本文件、二进制可执行文件、源代码等。 || b | 块设备文件。硬盘可以使用块设备文件。 || c | 字符设备文件。硬盘也可以使用字符设备文件。 || d | 目录文件。目录可以包含文件和其他目录。 || l | 符号链接（软链接）。可以链接任何普通文件，类似于 Windows 中的快捷方式。 || p | 具名管道。管道是进程间的一种通信机制。 || s | 用于进程间通信的套接字。 |提示：通俗的讲软连接就是windows的快捷方式，原来文件删了，快捷方式虽然在但是不起作用了。 元字符**元字符是具有特殊含义的字符。* 和 ? 都是元字符：· * 可以匹配 0 个或多个任意字符；· ? 匹配一个字符。例如:1$ls ch*.doc 可以显示所有以 ch 开头，以.doc 结尾的文件：123ch01-1.doc ch010.doc ch02.doc ch03-2.docch04-1.doc ch040.doc ch05.doc ch06-2.docch01-2.doc ch02-1.doc c 这里，* 匹配任意一个字符。如果你希望显示所有以 .doc 结尾的文件，可以使用1$ls *.doc。 隐藏文件**隐藏文件的第一个字符为英文句号或点号(.)，Linux程序（包括Shell）通常使用隐藏文件来保存配置信息。下面是一些常见的隐藏文件：.profile：Bourne shell (sh) 初始化脚本.kshrc：Korn shell (ksh) 初始化脚本.cshrc：C shell (csh) 初始化脚本.rhosts：Remote shell (rsh) 配置文件 查看隐藏文件需要使用 ls 命令的 -a 选项：1234567$ ls -a. .profile docs lib test_results.. .rhosts hosts pub users.emacs bin hw1 res.01 work.exrc ch07 hw2 res.02.kshrc ch07.bak hw3 res.03$ 一个点号(.)表示当前目录，两个点号(..)表示上级目录注意：输入密码时，星号(*)作为占位符，代表你输入的字符个数。 创建文件**在Linux中，可以使用 vi 编辑器创建一个文本文件，例如：1$ vi filename 上面的命令会创建文件 filename 并打开，按下 i 键即可进入编辑模式，你可以向文件中写入内容。例如：12This is Linux file....I created it for the first time.....I&apos;m going to save this content in this file. 完成编辑后，可以按 esc 键退出编辑模式，也可以按组合键 Shift + ZZ 完全退出文件。这样，就完成了文件的创建。12$ vi filename$ 编辑文件**vi 编辑器可以用来编辑文件。由于篇幅限制，这里仅作简单介绍，将在后面章节进行详细讲解。如下可以打开一个名为 filename 的文件：1$ vi filename 当文件被打开后，可以按 i 键进入编辑模式，按照自己的方式编辑文件。如果想移动光标，必须先按 esc 键退出编辑模式，然后使用下面的按键在文件内移动光标：· l 键向右移动· h 键向左移动· k 键向上移动· j 键向下移动 使用上面的按键，可以将光标快速定位到你想编辑的地方。定位好光标后，按 i 键再次进入编辑模式。编辑完成后按 esc 键退出编辑模式或者按组合键Shift+ZZ 退出当前文件。 查看文件内容**可以使用 cat 命令来查看文件内容，下面是一个简单的例子：1234$ cat filenameThis is Linux file....I created it for the first time.....I&apos;m going to save this content in this file.$ 可以通过 cat 命令的 -b 选项来显示行号，例如：1234$ cat -b filename1 This is Linux file....I created it for the first time.....2 I&apos;m going to save this content in this file.$ 统计单词数目**可以使用 wc 命令来统计当前文件的行数、单词数和字符数，下面是一个简单的例子：123$ wc filename2 19 103 filename$ 每一列的含义如下：· 第一列：文件的总行数· 第二列：单词数目· 第三列：文件的字节数，即文件的大小· 第四列：文件名 也可以一次查看多个文件的内容，例如：1$ wc filename1 filename2 filename3 复制文件**可以使用 cp 命令来复制文件。cp 命令的基本语法如下：1$ cp source_file destination_file 下面的例子将会复制 filename 文件：12$ cp filename copyfile$ 现在在当前目录中会多出一个和 filename 一模一样的 copyfile 文件。 重命名文件**重命名文件可以使用 mv 命令，语法为：1$ mv old_file new_file 下面的例子将会把 filename 文件重命名为 newfile：12$ mv filename newfile$ 现在在当前目录下，只有一个 newfile 文件。mv 命令其实是一个移动文件的命令，不但可以更改文件的路径，也可以更改文件名。 删除文件**rm命令可以删除文件，语法为：1$ rm filename 注意：删除文件是一种危险的行为，因为文件内可能包含有用信息，建议结合 -i 选项来使用 rm 命令。下面的例子会彻底删除一个文件：12$ rm filename$ 你也可以一次删除多个文件：12$ rm filename1 filename2 filename3$ 标准的Linux流**一般情况下，每个Linux程序运行时都会创建三个文件流（三个文件）：· 标准输入流(stdin)：stdin的文件描述符为0，Linux程序默认从stdin读取数据。· 标准输出流(stdout)：stdout 的文件描述符为1，Linux程序默认向stdout输出数据。· 标准错误流(stderr)：stderr的文件描述符为2，Linux程序会向stderr流中写入错误信息。 Linux目录**目录也是一个文件，它的唯一功能是用来保存文件及其相关信息。所有的文件，包括普通文件、设备文件和目录文件，都会被保存到目录中。 主目录**登录后，你所在的位置就是你的主目录（或登录目录），接下来你主要是在这个目录下进行操作，如创建文件、删除文件等。使用下面的命令可以随时进入主目录：12$cd ~$ 这里~ 就表示主目录。如果你希望进入其他用户的主目录，可以使用下面的命令：12$cd ~username$ 返回进入当前目录前所在的目录可以使用下面的命令：12$cd -$ 绝对路径和相对路径**Linux 的目录有清晰的层次结构，/ 代表根目录，所有的目录都位于/下面；文件在层次结构中的位置可以用路径来表示。如果一个路径以/ 开头，就称为绝对路径；它表示当前文件与根目录的关系。举例如下：123/etc/passwd/users/sjones/chem/notes/dev/rdsk/Os3 不以 / 开头的路径称为相对路径，它表示文件与当前目录的关系。例如：12chem/notespersonal/res 获取当前所在的目录可以使用 pwd 命令：123$pwd/user0/home/amrood$ 查看目录中的文件可以使用 ls 命令：1$ls dirname 下面的例子将遍历 /usr/local 目录下的文件：1234$ls /usr/localX11 bin gimp jikes sbinace doc include lib shareatalk etc info man ami 创建目录**可以使用 mkdir 命令来创建目录，语法为：1$mkdir dirname dirname 可以为绝对路径，也可以为相对路径。例如12$mkdir mydir$ 会在当前目录下创建 mydir 目录。又如12$mkdir /tmp/test-dir$ 会在/tmp 目录下创建 test-dir 目录。mkdir 成功创建目录后不会输出任何信息。也可以使用 mkdir 命令同时创建多个目录，例如12$mkdir docs pub$ 会在当前目录下创建 docs 和 pub 两个目录。 创建父目录**使用 mkdir 命令创建目录时，如果上级目录不存在，就会报错。下面的例子中，mkdir 会输出错误信息：1234$mkdir /tmp/amrood/testmkdir: Failed to make directory &quot;/tmp/amrood/test&quot;;No such file or directory$ 为 mkdir 命令增加 -p 选项，可以一级一级创建所需要的目录，即使上级目录不存在也不会报错。例如12$mkdir -p /tmp/amrood/test$ 会创建所有不存在的上级目录。 删除目录**可以使用 rmdir 命令来删除目录，例如：12$rmdir dirname$ 注意：删除目录时请确保目录为空，不会包含其他文件或目录。也可以使用 rmdir 命令同时删除多个目录：12$rmdir dirname1 dirname2 dirname3$ 如果 dirname1、dirname2、dirname3 为空，就会被删除。rmdir 成功删除目录后不会输出任何信息。 改变所在目录**可以使用 cd 命令来改变当前所在目录，进入任何有权限的目录，语法为：1$cd dirname dirname 为路径，可以为相对路径，也可以为绝对路径。例如12$cd /usr/local/bin$ 可以进入/usr/local/bin 目录。可以使用相对路径从这个目录进入 /usr/home/amrood 目录：12$cd ../../home/amrood$ 重命名目录**mv (move) 命令也可以用来重命名目录，语法为：1$mv olddir newdir 下面的例子将会把 mydir 目录重命名为 yourdir 目录：12$mv mydir yourdir$ 点号(.)**一个点号(.)表示当前目录，两个点号(..)表示上级目录（父目录）。ls 命令的 -a 选项可以查看所有文件，包括隐藏文件；-l 选项可以查看文件的所有信息，共有7列。例如：123456$ls -ladrwxrwxr-x 4 teacher class 2048 Jul 16 17.56 .drwxr-xr-x 60 root 1536 Jul 13 14:18 ..---------- 1 teacher class 4210 May 1 08:27 .profile-rwxr-xr-x 1 teacher class 1948 May 12 13:42 memo$ Linux文件权限和访问模式**为了更加安全的存储文件，Linux为不同的文件赋予了不同的权限，每个文件都拥有下面三种权限：· 所有者权限：文件所有者能够进行的操作· 组权限：文件所属用户组能够进行的操作· 外部权限（其他权限）：其他用户可以进行的操作。 查看文件权限** ???使用 ls -l 命令可以查看与文件权限相关的信息：123$ls -l /home/amrood-rwxr-xr-- 1 amrood users 1024 Nov 2 00:10 myfiledrwxr-xr--- 1 amrood users 1024 Nov 2 00:10 mydir 第一列就包含了文件或目录的权限。第一列的字符可以分为三组，每一组有三个，每个字符都代表不同的权限，分别为读取(r)、写入(w)和执行(x)：· 第一组字符(2-4)表示文件所有者的权限，-rwxr-xr– 表示所有者拥有读取(r)、写入(w)和执行(x)的权限。· 第二组字符(5-7)表示文件所属用户组的权限，-rwxr-xr– 表示该组拥有读取(r)和执行(x)的权限，但没有写入权限。· 第三组字符(8-10)表示所有其他用户的权限，rwxr-xr– 表示其他用户只能读取(r)文件。 文件访问模式**文件权限是Linux系统的第一道安全防线，基本的权限有读取(r)、写入(w)和执行(x)：· 读取：用户能够读取文件信息，查看文件内容。· 写入：用户可以编辑文件，可以向文件写入内容，也可以删除文件内容。· 执行：用户可以将文件作为程序来运行。 目录访问模式**目录的访问模式和文件类似，但是稍有不同：· 读取：用户可以查看目录中的文件· 写入：用户可以在当前目录中删除文件或创建文件· 执行：执行权限赋予用户遍历目录的权利，例如执行 cd 和 ls 命令。 改变权限**可以使用 chmod (change mode) 命令来改变文件或目录的访问权限，权限可以使用符号或数字来表示。 使用符号表示权限**对于初学者来说最简单的就是使用符号来改变文件或目录的权限，你可以增加(+)和删除(-)权限，也可以指定特定权限。| 符号** | 说明** || ———- | ———- || + | 为文件或目录增加权限 || - | 删除文件或目录的权限 || = | 设置指定的权限 |下面的例子将会修改 testfile 文件的权限：1234567891011$ls -l testfile-rwxrwxr-- 1 amrood users 1024 Nov 2 00:10 testfile$chmod o+wx testfile$ls -l testfile-rwxrwxrwx 1 amrood users 1024 Nov 2 00:10 testfile$chmod u-x testfile$ls -l testfile-rw-rwxrwx 1 amrood users 1024 Nov 2 00:10 testfile$chmod g=rx testfile$ls -l testfile-rw-r-xrwx 1 amrood users 1024 Nov 2 00:10 testfile 也可以同时使用多个符号：123$chmod o+wx,u-x,g=rx testfile$ls -l testfile-rw-r-xrwx 1 amrood users 1024 Nov 2 00:10 testfile 使用数字表示权限**除了符号，也可以使用八进制数字来指定具体权限，如下表所示：| 数字** | 说明** | 权限** || ———- | ———————————- | ———- || 0 | 没有任何权限 | — || 1 | 执行权限 | –x || 2 | 写入权限 | -w- || 3 | 执行权限和写入权限：1 (执行) + 2 (写入) = 3 | -wx || 4 | 读取权限 | r– || 5 | 读取和执行权限：4 (读取) + 1 (执行) = 5 | r-x || 6 | 读取和写入权限：4 (读取) + 2 (写入) = 6 | rw- || 7 | 所有权限: 4 (读取) + 2 (写入) + 1 (执行) = 7 | rwx |下面的例子，首先使用 ls -1 命令查看 testfile 文件的权限，然后使用 chmod 命令更改权限：1234567891011$ls -l testfile-rwxrwxr-- 1 amrood users 1024 Nov 2 00:10 testfile$ chmod 755 testfile$ls -l testfile-rwxr-xr-x 1 amrood users 1024 Nov 2 00:10 testfile$chmod 743 testfile$ls -l testfile-rwxr---wx 1 amrood users 1024 Nov 2 00:10 testfile$chmod 043 testfile$ls -l testfile----r---wx 1 amrood users 1024 Nov 2 00:10 testfile 更改所有者和用户组**在Linux中，每添加一个新用户，就会为它分配一个用户ID和群组ID，上面提到的文件权限也是基于用户和群组来分配的。有两个命令可以改变文件的所有者或群组：· chown：chown 命令是”change owner”的缩写，用来改变文件的所有者。· chgrp：chgrp 命令是”change group”的缩写，用来改变文件所在的群组。 chown 命令用来更改文件所有者，其语法如下：1$ chown user filelist user 可以是用户名或用户ID，例如12$ chown amrood testfile$ 将 testfile 文件的所有者改为 amrood。注意：超级用户 root 可以不受限制的更改文件的所有者和用户组，但是普通用户只能更改所有者是自己的文件或目录。 chgrp 命令用来改变文件所属群组，其语法为：1$ chgrp group filelist group可以是群组名或群组ID，例如12$ chgrp special testfile$ 将文件 testfile 的群组改为 special。 SUID和SGID位**在Linux中，一些程序需要特殊权限才能完成用户指定的操作。例如，用户的密码保存在/etc/shadow 文件中，出于安全考虑，一般用户没有读取和写入的权限。但是当我们使用passwd 命令来更改密码时，需要对/etc/shadow 文件有写入权限。这就意味着，passwd 程序必须要给我们一些特殊权限，才可以向 /etc/shadow 文件写入内容。Linux 通过给程序设置SUID(Set User ID)和SGID(Set Group ID)位来赋予普通用户特殊权限。当我们运行一个带有SUID位的程序时，就会继承该程序所有者的权限；如果程序不带SUID位，则会根据程序使用者的权限来运行。SGID也是一样。一般情况下程序会根据你的组权限来运行，但是给程序设置SGID后，就会根据程序所在组的组权限运行。如果程序设置了SUID位，就会在表示文件所有者可执行权限的位置上出现’s’字母；同样，如果设置了SGID，就会在表示文件群组可执行权限的位置上出现’s’字母。如下所示：123$ ls -l /usr/bin/passwd-r-sr-xr-x 1 root bin 19031 Feb 7 13:47 /usr/bin/passwd*$ 上面第一列第四个字符不是’x’或’-‘，而是’s’，说明 /usr/bin/passwd 文件设置了SUID位，这时普通用户会以root用户的权限来执行passwd程序。注意：小写字母’s’说明文件所有者有执行权限(x)，大写字母’S’说明程序所有者没有执行权限(x)。如果在表示群组权限的位置上出现SGID位，那么也仅有三类用户可以删除该目录下的文件：目录所有者、文件所有者、超级用户 root。为一个目录设置SUID和SGID位可以使用下面的命令：1234$ chmod ug+s dirname$ ls -ldrwsr-sr-x 2 root root 4096 Jun 19 06:45 dirname$ Linux环境变量**在Linux中，环境变量是一个很重要的概念。环境变量可以由系统、用户、Shell以及其他程序来设定。变量就是一个可以被赋值的字符串，赋值范围包括数字、文本、文件名、设备以及其他类型的数据。下面的例子，我们将为变量 TEST 赋值，然后使用 echo 命令输出：123$TEST=&quot;Linux Programming&quot;$echo $TESTLinux Programming 注意：变量赋值时前面不能加 $ 符号，变量输出时必须要加 $ 前缀。退出 Shell 时，变量将消失。登录系统后，Shell会有一个初始化的过程，用来设置环境变量。这个阶段，Shell会读取 /etc/profile 和 .profile 两个文件，过程如下：· Shell首先检查 /etc/profile 文件是否存在，如果存在，就读取内容，否则就跳过，但是不会报错。· 然后检查你的主目录（登录目录）中是否存在 .profile 文件，如果存在，就读取内容，否则就跳过，也不会报错。读取完上面两个文件，Shell就会出现 $ 命令提示符：$出现这个提示符，就可以输入命令并调用相应的程序了。注意：上面是Bourne Shell的初始化过程，bash 和 ksh 在初始化过程中还会检查其他文件。 .profile文件**/etc/profile文件包含了通用的Shell初始化信息，由Linux管理员维护，一般用户无权修改。但是你可以修改主目录下的 .profile 文件，增加一些“私人定制”初始化信息，包括：· 设置默认终端类型和外观样式；· 设置 Shell 命令查找路径，即PATH变量；· 设置命令提示符。找到主目录下的 .profile 文件，使用 vi 编辑器打开并查看内容。 设置终端类型**一般情况下，我们使用的终端是由 login 或 getty 程序设置的，可能会不符合我们的习惯。对于没有使用过的终端，可能会比较生疏，不习惯命令的输出样式，交互起来略显吃力。所以，一般用户会将终端设置成下面的类型：12$TERM=vt100$ vt100 是 virtual terminate 100 的缩写。虚拟终端是一种假的终端，真正有自己的显示器和键盘的终端，会通过特殊电缆（如串口）连到计算机主机。vt100 是被绝大多数Linux系统所支持的一种虚拟终端规范，常用的还有ansi、xterm等。 设置PATH变量**在命令提示符下输入一个命令时，Shell 会根据 PATH 变量来查找该命令对应的程序，PATH变量指明了这些程序所在的路径。一般情况下PATH变量的设置如下：12$PATH=/bin:/usr/bin$ 多个路径使用冒号(:)分隔。如果用户输入的命令在PATH设置的路径下没有找到，就会报错，例如：123$hellohello: not found$ PS1和PS2变量**PS1变量用来保存命令提示符，可以随意修改，如果你不习惯使用 $ 作为提示符，也可以改成其他字符。PS1变量被修改后，提示符会立即改变。例如，把命令提示符设置成=&gt;：1234$PS1=&apos;=&gt;&apos;=&gt;=&gt;=&gt; 也可以将提示信息设置成当前目录，例如：123=&gt;PS1=&quot;[\\u@\\h \\w]\\$&quot;[root@ip-72-167-112-17 /var/www/tutorialspoint/Linux]$[root@ip-72-167-112-17 /var/www/tutorialspoint/Linux]$ 命令提示信息包含了用户名、主机名和当前目录。下表中的转义字符可以被用作PS1的参数，丰富命令提示符信息。| 转义字符** | 描述** || ———— | ————————– || \\t | 当前时间，格式为 HH:MM:SS || \\d | 当前日期，格式为Weekday Month Date || \\n | 换行 || \\W | 当前所在目录 || \\w | 当前所在目录的完整路径 || \\u | 用户名 || \\h | 主机名（IP地址） || # | 输入的命令的个数，每输入一个新的命令就会加1 || \\$ | 如果是超级用户 root，提示符为#，否则为$。 |你可以在每次登录的时候修改提示符，也可以在 .profile 文件中增加 PS1 变量，这样每次登录时会自动修改提示符。如果用户输入的命令不完整，Shell还会使用第二提示符来等待用户完成命令的输入。默认的第二命令提示符是 &gt;，保存在 PS2 变量，可以随意修改。下面的例子使用默认的第二命令提示符：12345$ echo &quot;this is a&gt; test&quot;this is atest$ 下面的例子通过PS2变量改变提示符：123456$ PS2=&quot;secondary prompt-&gt;&quot;$ echo &quot;this is asecondary prompt-&gt;test&quot;this is atest$ 常用环境变量**下表列出了部分重要的环境变量，这些变量可以通过上面提到的方式修改。| 变量** | 描述** || ———- | —————————————- || DISPLAY | 用来设置将图形显示到何处。 || HOME | 当前用户的主目录。 || IFS | 内部域分隔符。 || LANG | LANG可以让系统支持多语言。例如，将LANG设为pt_BR，则可以支持(巴西)葡萄牙语。 || PATH | 指定Shell命令的路径。 || PWD | 当前所在目录，即 cd 到的目录。 || RANDOM | 生成一个介于 0 和 32767 之间的随机数。 || TERM | 设置终端类型。 || TZ | 时区。可以是AST(大西洋标准时间)或GMT(格林尼治标准时间)等。 || UID | 以数字形式表示的当前用户ID，shell启动时会被初始化。 |下面的例子中使用了部分环境变量：12345678$ echo $HOME/root]$ echo $DISPLAY$ echo $TERMxterm$ echo $PATH/usr/local/bin:/bin:/usr/bin:/home/amrood/bin:/usr/local/bin$ Linux打印文件和发送邮件**通过前面的介绍，相信你对 Linux 的命令和特性有了一个基本的认识，本节将介绍如果打印文件以及发送邮件。 文件打印**如果你希望打印文本文件，最好预先处理一下，包括调整边距、设置行高、设置标题等，这样打印出来的文件更加美观，易于阅读。当然，不处理也可以打印，但是可能会比较丑陋。大部分的Linux自带了 nroff 和 troff 两个强大的文本格式化工具，不过比较老旧，使用的人很少，有兴趣的读者可以可以自行学习，本教程不再进行深入讲解。 pr命令**pr 命令用来将文本文件转换成适合打印的格式，它可以把较大的文件分割成多个页面进行打印，并为每个页面添加标题。pr 命令的语法如下：pr option(s) filename(s)pr 命令仅仅改变文件在屏幕上的显示样式和打印输出样式，并不会更改文件本身。下表是 pr 命令的几个选项：| 选项** | 说明** || ————– | —————————- || -k | 分成几列打印，默认为1。 || -d | 两倍行距（并不是所有版本的 pr 都有效）。 || -h “header” | 设置每个页面的标题。 || -t | 不打印标题和上下边距。 || -l PAGE_LENGTH | 每页显示多少行。默认是每个页面一共66行，文本占56行。 || -o MARGIN | 每行缩进的空格数。 || -w PAGE_WIDTH | 多列输出时，设置页面宽度，默认是72个字符。 |例如，food 文件包含了很多食品的名字，使用 pr 命令分成两列打印，并设置每页的标题为“Restaurants”。首先查看文件内容：$cat foodSweet ToothBangkok WokMandalayAfghani CuisineIsle of JavaBig Apple DeliSushi and SashimiTio Pepe’s Peppers……..$然后使用 pr 命令打印：$pr -2 -h “Restaurants” foodNov 7 9:58 1997 Restaurants Page 1Sweet Tooth Isle of JavaBangkok Wok Big Apple DeliMandalay Sushi and SashimiAfghani Cuisine Tio Pepe’s Peppers……..$ lp和lpr命令**lp 和 lpr 命令将文件传送到打印机进行打印。使用 pr 命令将文件格式化后就可以使用这两个命令来打印。打印机一般由系统管理员来设置，下面的例子使用默认的打印机打印food文件：$lp foodrequest id is laserp-525 (1 file)$命令成功执行会返回一个表示打印任务的ID，通过这个ID可以取消打印或者查看打印状态。如果你希望打印多份文件，可以使用 lp 的 -nNum 选项，或者 lpr 命令的 -Num 选项。Num 是一个数字，可以随意设置。如果系统连接了多台打印机，可以使用 lp 命令的 -dprinter 选项，或者 lpr 命令的 -Pprinter 选项来选择打印机。printer 为打印机名称。 lpstat 和 lpq 命令**lpstat 命令可以查看打印机的缓存队列（有多少个文件等待打印），包括任务ID、所有者、文件大小、请求时间和请求状态。提示：等待打印的文件会被放到打印机的的缓存队列中。例如，使用 lpstat -o 命令查看打印机中所有等待打印的文件，包括你自己的：$lpstat -olaserp-573 john 128865 Nov 7 11:27 on laserplaserp-574 grace 82744 Nov 7 11:28laserp-575 john 23347 Nov 7 11:35$lpstat -o 命令按照打印顺序输出队列中的文件。lpq 命令显示的信息与 lpstat -o 稍有差异：$lpqlaserp is ready and printingRank Owner Job Files Total Sizeactive john 573 report.ps 128865 bytes1st grace 574 ch03.ps ch04.ps 82744 bytes2nd john 575 standard input 23347 bytes$第一行为打印机的状态。如果打印机无法使用或者纸被用完，将会输出其他信息。 cancel 和 lprm 命令**cancel 和 lprm 分别用来终止 lp 和 lpr 的打印请求。使用这两个命令，需要指定ID（由 lp 或 lpq 返回）或打印机名称。例如，通过ID取消打印请求：$cancel laserp-575request “laserp-575” cancelled$如果希望取消正在打印的文件，那么可以不指定ID，仅仅指定打印机名称即可：$cancel laserprequest “laserp-573” cancelled$lprm 命令用来取消当前用户的正在等待打印的文件，使用任务号作为参数可以取消指定文件，使用横线(-)作为参数可以取消所有文件。例如，取消575号打印任务：$lprm 575dfA575diamond dequeuedcfA575diamond dequeued$lprm 会返回被取消的文件名。 发送邮件**可以使用mail命令发送和接收邮件，语法如下：$mail [-s subject] [-c cc-addr] [-b bcc-addr] to-addr每个选项的含义如下：| 选项** | 描述** || ———- | ————————— || -s | 邮件标题。 || -c | 要发送的用户，多个用户以逗号(,)分隔。 || -b | 需要密件发送（密送）的用户，多个用户以逗号(,)分隔。 |例如，向admin@yahoo.com发送邮件：$mail -s “Test Message” admin@yahoo.comHello everyone,this is Linux tutorial and url is http://see.xidian.edu.cn/cpp/linux/.Cc:第一行是输入的命令，-s表示邮件的主题，后面的admin@yahoo.com则是邮件的接收人，输入完这行命令后回车，会进入邮件正文的编写，你可以输入任何文字，比如上面的两行。输入完邮件正文，需要按CTRL+D结束输入，此时会提示你输入Cc地址，即邮件抄送地址，没有直接回车就完成了邮件的发送。也可以通过重定向操作符 &lt; 来发送文件：$mail -s “Report 05/06/07” admin@yahoo.com &lt; demo.txt通过上面的命令，就可以把demol.txt文件的内容作为邮件的内容发送给admin@yahoo.com了。接收邮件不需要任何参数：$mailno email Linux管道和过滤器**有时候，我们可以把两个命令连起来使用，一个命令的输出作为另一个命令的输入，这就叫做管道。为了建立管道，需要在两个命令之间使用竖线(|)连接。管道是Linux进程之间一种重要的通信机制；除了管道，还有共享内存、消息队列、信号、套接字(socket) 等进程通信机制。管道使用竖线(|)将两个命令隔开，竖线左边命令的输出就会作为竖线右边命令的输入。连续使用竖线表示第一个命令的输出会作为第二个命令的输入，第二个命令的输出又会作为第三个命令的输入，依此类推。能够接受数据，过滤（处理或筛选）后再输出的工具，称为过滤器。 grep命令**grep 是一个强大的文本搜索工具，可以使用正则表达式，并返回匹配的行，语法为：$grep pattern file(s)“grep”源于 ed（Linux的一个行文本编辑器）的 g/re/p 命令，g/re/p 是“globally search for a regular expression and print all lines containing it”的缩写，意思是使用正则表达式进行全局检索，并把匹配的行打印出来。正则表达式是一个包含了若干特殊字符的字符串，每个字符都有特殊含义，可以用来匹配文本，更多信息请查看正则表达式教程。grep 可以看做是一个过滤器，如果没有为 grep 指定要检索的文件，那么它会从标准输入设备（一般是键盘）读取；其他过滤器也是如此。grep 命令最简单的使用就是检索包含固定字符的文本。例如，在管道中使用 grep 命令，只允许包含指定字符的行输出到显示器：$ls -l | grep “Aug”-rw-rw-rw- 1 john doc 11008 Aug 6 14:10 ch02-rw-rw-rw- 1 john doc 8515 Aug 6 15:30 ch07-rw-rw-r– 1 john doc 2488 Aug 15 10:51 intro-rw-rw-r– 1 carol doc 1605 Aug 23 07:35 macros$grep 命令有很多选项：| 选项** | 说明** || ———- | —————————————- || -v | 反转查询，输出不匹配的行。例如，grep -v “test” demo.txt 将输出不包含”test”的行。 || -n | 输出匹配的行以及行号。 || -l | 输出匹配的行所在的文件名。 || -c | 输出匹配的总行数。 || -i | 不区分大小写进行匹配。 |下面我们使用正则表达式来匹配这样的行：包含字符“carol”，然后包含任意数目（含零个）的其他字符，最后还要包含“Aug”。使用 -i 选项进行不区分大小写的匹配：$ls -l | grep -i “carol.*aug”-rw-rw-r– 1 carol doc 1605 Aug 23 07:35 macros$ sort命令**sort 命令在 Linux 中非常有用，它将文件中的各行按字母或数进行排序。sort命令既可以从特定的文件，也可以从stdin获取输入。例如，对 foot 文件的各行进行排序：$sort foodAfghani CuisineBangkok WokBig Apple DeliIsle of JavaMandalaySushi and SashimiSweet ToothTio Pepe’s Peppers$通过下面的选项可以控制排序规则：| 选项** | 描述** || ———- | ————————————— || -n | 按照数字大小排序，例如，10会排在2后面；-n 选项会忽略空格或 tab缩进。 || -r | 降序排序。sort 默认是升序排序。 || -f | 不区分大小写。 || +x | 对第x列（从0开始）进行排序。 |下面的例子通过管道将 ls、grep 和 sort 命令连起来使用，过滤包含“Aug”的行，并按照文件大小排序：$ls -l | grep “Aug” | sort +4n-rw-rw-r– 1 carol doc 1605 Aug 23 07:35 macros-rw-rw-r– 1 john doc 2488 Aug 15 10:51 intro-rw-rw-rw- 1 john doc 8515 Aug 6 15:30 ch07-rw-rw-rw- 1 john doc 11008 Aug 6 14:10 ch02$上面的命令，对当前目录中八月份修改的文件按照大小排序；+4n 表示对第5列按照数字大小排序。 pg和more命令**如果文件内容过多，全部显示会很乱，可以使用 pg 和 more 命令分页显示，每次只显示一屏。例如，通过管道，使用more命令显示目录中的文件：$ls -l | grep “Aug” | sort +4n | more-rw-rw-r– 1 carol doc 1605 Aug 23 07:35 macros-rw-rw-r– 1 john doc 2488 Aug 15 10:51 intro-rw-rw-rw- 1 john doc 8515 Aug 6 15:30 ch07-rw-rw-r– 1 john doc 14827 Aug 9 12:40 ch03...-rw-rw-rw- 1 john doc 16867 Aug 6 15:56 ch05–More–(74%)如上，一次只显示一屏文本，显示满后，停下来，并提示已显示全部内容的百分比，按空格键(space)可以查看下一屏，按 b 键可以查看上一屏。 Linux进程管理**当我们运行程序时，Linux会为程序创建一个特殊的环境，该环境包含程序运行需要的所有资源，以保证程序能够独立运行，不受其他程序的干扰。这个特殊的环境就称为进程。每个 Linux 命令都与系统中的程序对应，输入命令，Linux 就会创建一个新的进程。例如使用 ls 命令遍历目录中的文件时，就创建了一个进程。简而言之，进程就是程序的实例。系统通过一个五位数字跟踪程序的运行状态，这个数字称为 pid 或进程ID。每个进程都拥有唯一的 pid。理论上，五位数字是有限的，当数字被用完时，下一个 pid 就会重新开始，所以 pid 最终会重复。但是，两个 pid 一样的进程不能同时存在，因为Linux会使用 pid 来跟踪程序的运行状态。 创建进程**有两种方式来创建进程：前台进程和后台进程。 前台进程**默认情况下，用户创建的进程都是前台进程；前台进程从键盘读取数据，并把处理结果输出到显示器。我们可以看到前台进程的运行过程。例如，使用 ls 命令来遍历当前目录下的文件：$ls ch*.docch01-1.doc ch010.doc ch02.doc ch03-2.docch04-1.doc ch040.doc ch05.doc ch06-2.docch01-2.doc ch02-1.doc这个程序就运行在前台，它会直接把结果输出到显示器。如果 ls 命令需要数据（实际上不需要），那么它会等待用户从键盘输入。当程序运行在前台时，由于命令提示符($)还未出现，用户不能输入其他命令；即使程序需要运行很长时间，也必须等待程序运行结束才能输入其他命令。 后台进程**后台进程与键盘没有必然的关系。当然，后台进程也可能会等待键盘输入。后台进程的优点是不必等待程序运行结束就可以输入其他命令。创建后台进程最简单的方式就是在命令的末尾加 &amp;，例如：$ls ch*.doc &amp;ch01-1.doc ch010.doc ch02.doc ch03-2.docch04-1.doc ch040.doc ch05.doc ch06-2.docch01-2.doc ch02-1.doc如果 ls 命令需要输入（实际上不需要），那么它会暂停，直到用户把它调到前台并从键盘输入数据才会继续运行。 查看正在运行的进程**可以使用 ps 命令查看进程的运行状态，包括后台进程，例如：$psPID TTY TIME CMD18358 ttyp3 00:00:00 sh18361 ttyp3 00:01:31 abiword18789 ttyp3 00:00:00 ps还可以结合 -f 选项查看更多信息，f 是 full 的缩写，例如：$ps -fUID PID PPID C STIME TTY TIME CMDamrood 6738 3662 0 10:23:03 pts/6 0:00 first_oneamrood 6739 3662 0 10:22:54 pts/6 0:00 second_oneamrood 3662 3657 0 08:10:53 pts/6 0:00 -kshamrood 6892 3662 4 10:51:50 pts/6 0:00 ps -f每列的含义如下：| 列** | 描述** || ——— | ———————- || UID | 进程所属用户的ID，即哪个用户创建了该进程。 || PID | 进程ID。 || PPID | 父进程ID，创建该进程的进程称为父进程。 || C | CPU使用率。 || STIME | 进程被创建的时间。 || TTY | 与进程有关的终端类型。 || TIME | 进程所使用的CPU时间。 || CMD | 创建该进程的命令。 |ps 命令还有其他一些选项：| 选项** | 说明** || ———- | —————– || -a | 显示所有用户的所有进程。 || -x | 显示无终端的进程。 || -u | 显示更多信息，类似于 -f 选项。 || -e | 显示所有进程。 | 终止进程**当进程运行在前台时，可以通过 kill 命令或 Ctrl+C 组合键来结束进程。如果进程运行在后台，那么首先要通过 ps 命令来获取进程ID，然后使用 kill 命令“杀死”进程，例如：$ps -fUID PID PPID C STIME TTY TIME CMDamrood 6738 3662 0 10:23:03 pts/6 0:00 first_oneamrood 6739 3662 0 10:22:54 pts/6 0:00 second_oneamrood 3662 3657 0 08:10:53 pts/6 0:00 -kshamrood 6892 3662 4 10:51:50 pts/6 0:00 ps -f$kill 6738Terminated如上所示，kill 命令终结了 first_one 进程。如果进程忽略 kill 命令，那么可以通过 kill -9 来结束：$kill -9 6738Terminated 父进程和子进程**每个 Linux 进程会包含两个进程ID：当前进程ID(pid)和父进程ID(ppid)。可以暂时认为所有的进程都有父进程。由用户运行的大部分命令都将 Shell 作为父进程，使用 ps -f 命令可以查看当前进程ID和父进程ID。 僵尸进程和孤儿进程**正常情况下，子进程被终止时会通过 SIGCHLD 信号通知父进程，父进程可以做一些清理工作或者重新启动一个新的进程。但在某些情况下，父进程会在子进程之前被终止，那么这些子进程就没有了“父亲”，被称为孤儿进程。init 进程会成为所有孤儿进程的父进程。init 的 pid 为1，是Linux系统的第一个进程，也是所有进程的父进程。如果一个进程被终止了，但是使用 ps 命令仍然可以查看该进程，并且状态为 Z，那么这就是一个僵尸进程。僵尸进程虽然被终止了，但是仍然存在于进程列表中。一般僵尸进程很难杀掉，你可以先杀死他们的父进程，让他们变成孤儿进程，init 进程会自动清理僵尸进程。 常驻进程**常驻进程一般是系统级进程，以 root 权限运行在后台，可以处理其他进程的请求。常驻进程没有终端，不能访问 /dev/tty 文件，如果使用 ps -ef 查看该进程，tty 这一列会显示问号(?)。更确切地说，常驻进程通常运行在后台，等待指定事件发生，例如打印进程是一个常驻进程，它会等待用户输入打印相关的命令并进行处理。 top命令**top 命令是一个很有用的工具，它可以动态显示正在运行的进程，还可以按照指定条件对进程进行排序，与Windows的任务管理器类似。top 命令可以显示进程的很多信息，包括物理内存、虚拟内存、CPU使用率、平均负载以及繁忙的进程等。例如：$top这里仅给出一个示意图，读者最好亲自运行一下： img 任务和进程**任务(task)是最抽象的，是一个一般性的术语，指由软件完成的一个活动。一个任务既可以是一个进程，也可以是多个进程。简而言之，它指的是一系列共同达到某一目的的操作。例如，读取数据并将数据放入内存中。这个任务可以由一个进程来实现，也可以由多个进程来实现。 每个任务都有一个数字表示的任务号。进程(process)常常被定义为程序的执行。可以把一个进程看成是一个独立的程序，在内存中有其完备的数据空间和代码空间。一个进程所拥有的数据和变量只属于它自己。jobs 命令可以用来查看系统中正在运行的任务，包括后台运行的任务。该命令可以显示任务号及其对应的进程ID。一个任务可以对应于一个或者多个进程号。jobs 命令的 -l 选项可以查看当前任务包含的进程ID：$jobs -l[1] + 1903 running ls ch*.doc &amp;$其中，第一列表示任务号，第二列表示任务对应的进程ID，第三列表示任务的运行状态，第四列表示启动任务的命令。 前台任务和后台任务的切换**fg 命令可以将后台任务调到前台，语法为：$fg %jobnumberjobnumber 是通过 jobs 命令获取的后台任务的的序号，注意不是pid。如果后台只有一个任务，可以不指定 jobnumber。bg 命令可以将后台暂停的任务，调到前台继续运行，语法为：$bg %jobnumberjobnumber 同样是通过 jobs 命令获取的后台任务的的序号，注意不是pid。如果前台只有一个任务，可以不指定 jobnumber。如果希望将当前任务转移到后台，可以先 Ctrl+z 暂停任务，再使用 bg 命令。任务转移到后台可以空出终端，继续输入其他命令。 Linux网络通信工具**现在是一个互联网的时代，你不可避免的要和其他用户进行远程交流，连接到远程主机。 ping 命令**ping 命令会向网络上的主机发送应答请求，根据响应信息可以判断远程主机是否可用。ping 命令的语法：$ping hostname or ip-address如果网络畅通，很快就可以看到响应信息。例如，检测是否可以连接到谷歌的主机：$ping google.comPING google.com (74.125.67.100) 56(84) bytes of data.64 bytes from 74.125.67.100: icmp_seq=1 ttl=54 time=39.4 ms64 bytes from 74.125.67.100: icmp_seq=2 ttl=54 time=39.9 ms64 bytes from 74.125.67.100: icmp_seq=3 ttl=54 time=39.3 ms64 bytes from 74.125.67.100: icmp_seq=4 ttl=54 time=39.1 ms64 bytes from 74.125.67.100: icmp_seq=5 ttl=54 time=38.8 ms— google.com ping statistics —22 packets transmitted, 22 received, 0% packet loss, time 21017msrtt min/avg/max/mdev = 38.867/39.334/39.900/0.396 ms$如果主机没有响应，可以看到类似下面的信息：$ping giiiiiigle.comping: unknown host giiiiigle.com$ ftp 工具**ftp 是 File Transfer Protocol 的缩写，称为文件传输协议。通过 ftp 工具，能够将文件上传到远程服务器，也可以从远程服务器下载文件。ftp 工具有自己的命令（类似Linux命令），可以：· 连接并登录远程主机；· 查看目录，遍历目录下的文件；· 上传或下载文件，包括文本文件、二进制文件等。ftp 命令的用法如下：$ftp hostname or ip-address接下来会提示你输入用户名和密码，验证成功后会进入主目录，然后就可以使用 ftp 工具的命令进行操作了。| ftp命令** | 说明** || ————– | —————————————- || put filename | 将本地文件上传到远程主机。 || get filename | 将远程文件下载到本地。 || mput file list | 将多个本地文件上传到远程主机。 || mget file list | 将多个远程文件下载到本地。 || prompt off | 关闭提示。默认情况下，使用 mput 或 mget 命令会不断提示你确认文件的上传或下载。 || prompt on | 打开提示。 || dir | 列出远程主机当前目录下的所有文件。 || cd dirname | 改变远程主机目录。 || lcd dirname | 改变本地目录。 || quit | 退出登录。 |注意，所有的上传和下载都是针对本地主机和远程主机的当前目录，如果你希望上传指定目录下的文件，首先要 cd 到该目录，然后才能上传。ftp 工具使用举例：$ftp amrood.comConnected to amrood.com.220 amrood.com FTP server (Ver 4.9 Thu Sep 2 20:35:07 CDT 2009)Name (amrood.com:amrood): amrood331 Password required for amrood.Password:230 User amrood logged in.ftp&gt; dir200 PORT command successful.150 Opening data connection for /bin/ls.total 1464drwxr-sr-x 3 amrood group 1024 Mar 11 20:04 Maildrwxr-sr-x 2 amrood group 1536 Mar 3 18:07 Miscdrwxr-sr-x 5 amrood group 512 Dec 7 10:59 OldStuffdrwxr-sr-x 2 amrood group 1024 Mar 11 15:24 bindrwxr-sr-x 5 amrood group 3072 Mar 13 16:10 mpl-rw-r–r– 1 amrood group 209671 Mar 15 10:57 myfile.outdrwxr-sr-x 3 amrood group 512 Jan 5 13:32 publicdrwxr-sr-x 3 amrood group 512 Feb 10 10:17 pvm3226 Transfer complete.ftp&gt; cd mpl250 CWD command successful.ftp&gt; dir200 PORT command successful.150 Opening data connection for /bin/ls.total 7320-rw-r–r– 1 amrood group 1630 Aug 8 1994 dboard.f-rw-r—– 1 amrood group 4340 Jul 17 1994 vttest.c-rwxr-xr-x 1 amrood group 525574 Feb 15 11:52 wave_shift-rw-r–r– 1 amrood group 1648 Aug 5 1994 wide.list-rwxr-xr-x 1 amrood group 4019 Feb 14 16:26 fix.c226 Transfer complete.ftp&gt; get wave_shift200 PORT command successful.150 Opening data connection for wave_shift (525574 bytes).226 Transfer complete.528454 bytes received in 1.296 seconds (398.1 Kbytes/s)ftp&gt; quit221 Goodbye.$ telnet工具**Telnet 工具可以让我们连接并登录到远程计算机。一旦连接到了远程计算机，就可以在上面进行各种操作了，例如：C:&gt;telnet amrood.comTrying…Connected to amrood.com.Escape character is ‘^]’.login: amroodamrood’s Password: * \\ \\ WELCOME TO AMROOD.COM \\ \\ * Last unsuccessful login: Fri Mar 3 12:01:09 IST 2009Last login: Wed Mar 8 18:33:27 IST 2009 on pts/10 { do your work }$ logoutConnection closed.C:&gt; finger工具**finger 可以让我们查看本地主机或远程主机上的用户信息。有些系统为了安全会禁用 finger 命令。例如，查看本机在线用户：$ fingerLogin Name Tty Idle Login Time Officeamrood pts/0 Jun 25 08:03 (62.61.164.115)查看本机指定用户的信息：$ finger amroodLogin: amrood Name: (null)Directory: /home/amrood Shell: /bin/bashOn since Thu Jun 25 08:03 (MST) on pts/0 from 62.61.164.115No mail.No Plan.查看远程主机上的在线用户：$ finger @avtar.comLogin Name Tty Idle Login Time Officeamrood pts/0 Jun 25 08:03 (62.61.164.115)查看远程主机上某个用户的信息：$ finger amrood@avtar.comLogin: amrood Name: (null)Directory: /home/amrood Shell: /bin/bashOn since Thu Jun 25 08:03 (MST) on pts/0 from 62.61.164.115No mail.No Plan. 10分钟掌握Linux vi编辑器常见命令的使用，最简单的vi编辑器教程**Linux下的文本编辑器有很多种，vi 是最常用的，也是各版本Linux的标配。注意，vi 仅仅是一个文本编辑器，可以给字符着色，可以自动补全，但是不像 Windows 下的 word 有排版功能。vi 是十年磨一剑的产品，虽然命令繁多，并且大多数功能都是依靠键盘输入来完成，但是一旦你熟悉后，会发现 vi 的功能和效率是其他图形界面编辑器无法比拟的。Vim 是 Vi improved 的缩写，是 vi 的改进版。在Linux中，vi 被认为是事实上的标准编辑器，因为：· 所有版本的 Linux 都带有 vi 编辑器；· 占用资源少；· 与 ed、ex 等其他编辑器相比，vi 对用户更加友好。你可以使用 vi 编辑器编辑现有的文件，也可以创建一个新文件，还能以只读模式打开文本文件。 进入 vi 编辑器**可以通过以下方式进入 vi 编辑器：| 命令** | 描述** || ————– | ——————————- || vi filename | 如果filename存在，则打开；否则会创建一个新文件再打开。 || vi -R filename | 以只读模式（只能查看不能编辑）打开现有文件。 || view filename | 以只读模式打开现有文件。 |例如，使用 vi 编辑器创建一个新文件并打开：$vi testfile|~~~~~~~~~~~~“testfile” [New File]竖线(|)代表光标的位置；波浪号(~)代表该行没有任何内容。如果没有 ~，也看不到任何内容，那说明这一行肯定是有空白字符（空格、tab 缩进、换行符等）或不可见字符。 工作模式**进一步了解 vi 之前先来了解一下 vi 的工作模式，vi 有三种工作模式： 1) 普通模式**由Shell进入vi编辑器时，首先进入普通模式。在普通模式下，从键盘输入任何字符都被当作命令来解释。普通模式下没有任何提示符，输入命令后立即执行，不需要回车，而且输入的字符不会在屏幕上显示出来。普通模式下可以执行命令、保存文件、移动光标、粘贴复制等。 2) 编辑模式**编辑模式主要用于文本的编辑。该模式下用户输入的任何字符都被作为文件的内容保存起来，并在屏幕上显示出来。 3) 命令模式**命令模式下，用户可以对文件进行一些高级处理。尽管普通模式下的命令可以完成很多功能，但要执行一些如字符串查找、替换、显示行号等操作还是必须要进入命令模式。注意：有些教程中称有两种工作模式，是把命令模式合并到普通模式。工作模式切换：· 在普通模式下输入 i(插入)、c(修改)、o(另起一行) 命令时进入编辑模式；按 esc 键退回到普通模式。· 在普通模式下输入冒号(:)可以进入命令模式。输入完命令按回车，命令执行完后会自动退回普通模式。提示：如果不确定当前处于哪种模式，按两次 Esc 键将回到普通模式。 退出 vi 编辑器**一般在命令模式下退出 vi 编辑器。| 退出命令** | 说明** || ———— | —————————— || q | 如果文件未被修改，会直接退回到Shell；否则提示保存文件。 || q! | 强行退出，不保存修改内容。 || wq | w 命令保存文件，q 命令退出 vi，合起来就是保存并退出。 || ZZ | 保存并退出，相当于 wq，但是更加方便。 |退出之前，你也可以在 w 命令后面指定一个文件名，将文件另存为新文件，例如：w filename2将当前文件另存为 filename2。注意：vi 编辑文件时，用户的操作都是基于缓冲区中的副本进行的。如果退出时没有保存到磁盘，则缓冲区中的内容就会被丢失。 移动光标**为了不影响文件内容，必须在普通模式（按两次 Esc 键）下移动光标。使用下表中的命令每次可以移动一个字符：| 命令** | 描述** || ———- | ————– || k | 向上移动光标（移动一行） || j | 向下移动光标（移动一行） || h | 向左移动光标（移动一个字符） || l | 向右移动光标（移动一个字符） |两点提醒：· vi 是区分大小写的，输入命令时注意不要锁定大写。· 可以在命令前边添加一个数字作为前缀，例如，2j 将光标向下移动两行。当然，还有很多其他命令来移动光标，不过记住，一定要在普通模式（按两次 Esc 键）下。| 用来移动光标的命令 | || ———- | —————————— || 命令** | 说明** || 0 或 | | 将光标定位在一行的开头。 || $ | 将光标定位在一行的末尾。 || w | 定位到下一个单词。 || b | 定位到上一个单词。 || ( | 定位到一句话的开头，句子是以 ! . ? 三种符号来界定的。 || ) | 定位到一句话的结尾。 || { | 移动到段落开头。&amp;&amp;&amp;&amp;&amp;&amp; || } | 移动到段落结束。&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; || [[ | 回到段落的开头处。&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; || ]] | 向前移到下一个段落的开头处。&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; || n| | 移动到第 n 列（当前行）。 || 1G | 移动到文件第一行。 || G | 移动到文件最后一行。 || nG | 移动到文件第 n 行。 || :n | 移动到文件第 n 行。 || H | 移动到屏幕顶部。 || nH | 移动到距离屏幕顶部第 n 行的位置。 || M | 移动到屏幕中间。 || L | 移动到屏幕底部。 || nL | 移动到距离屏幕底部第 n 行的位置。 || :x | x 是一个数字，表示移动到行号为 x 的行。 | 控制命令**有一些控制命令可以与 Ctrl 键组合使用，如下：| 命令** | 描述** || ———- | ———- || CTRL+d | 向前滚动半屏 || CTRL+f | 向前滚动全屏 || CTRL+u | 向后滚动半屏 || CTRL+b | 向后滚动整屏 || CTRL+e | 向上滚动一行 || CTRL+y | 向下滚动一行 || CTRL+I | 刷新屏幕 | 编辑文件**切换到编辑模式下才能编辑文件。有很多命令可以从普通模式切换到编辑模式，如下所示：| 命令** | 描述** || ———- | ————- || i | 在当前光标位置之前插入文本 || I | 在当前行的开头插入文本 || a | 在当前光标位置之后插入文本 || A | 在当前行的末尾插入文本 || o | 在当前位置下面创建一行 || O | 在当前位置上面创建一行 | 删除字符**下面的命令，可以删除文件中的字符或行：| 命令** | 说明** || ———- | ————— || x | 删除当前光标下的字符 || X | 删除光标前面的字符 || dw | 删除从当前光标到单词结尾的字符 || d^ | 删除从当前光标到行首的字符 || d$ | 删除从当前光标到行尾的字符 || D | 删除从当前光标到行尾的字符 || dd | 删除当前光标所在的行 |可以在命令前面添加一个数字前缀，表示重复操作的次数，例如，2x 表示连续两次删除光标下的字符，2dd 表示连续两次删除光标所在的行。建议各位读者多加练习上面的命令，再进一步深入学习。 修改文本**如果你希望对字符、单词或行进行修改，可以使用下面的命令：| 命令** | 描述** || ———- | ———————- || cc | 删除当前行，并进入编辑模式。 || cw | 删除当前字（单词），并进入编辑模式。 || r | 替换当前光标下的字符。 || R | 从当前光标开始替换字符，按 Esc 键退出。 || s | 用输入的字符替换当前字符，并进入编辑模式。 || S | 用输入的文本替换当前行，并进入编辑模式。 | 粘贴复制**vi 中的复制粘贴命令：| 命令** | 描述** || ———- | ————- || yy | 复制当前行 || nyy | 复制n行 || yw | 复制一个字（单词） || nyw | 复制n行 || p | 将复制的文本粘贴到光标后面 || P | 将复制的文本粘贴到光标前面 | 高级命令**下面的一些命令虽然看起来有些古怪，但是会让你的工作更有效率，如果你是 vi 重度用户，就了解一下吧。| 命令** | 说明** || ———– | ———————————- || J | 将当前行和下一行连接为一行 || &lt;&lt; | 将当前行左移一个单位（一个缩进宽度） || &gt;&gt; | 将当前行右移一个单位（一个缩进宽度） || ~ | 改变当前字符的大小写 || ^G | Ctrl+G组合键可以显示当前文件名和状态 || U | 撤销对当前行所做的修改 || u | 撤销上次操作，再次按 ‘u’ 恢复该次操作 || :f | 以百分号(%)的形式显示当前光标在文件中的位置、文件名和文件的总行数 || :f filename | 将文件重命名为 filename || :w filename | 保存修改到 filename || :e filename | 打开另一个文件名为 filename 的文件 || :cd dirname | 改变当前工作目录到 dirname || :e # | 在两个打开的文件之间进行切换 || :n | 如果用 vi 打开了多个文件，可以使用 :n 切换到下一个文件 || :p | 如果用 vi 打开了多个文件，可以使用 :n 切换到上一个文件 || :N | 如果用 vi 打开了多个文件，可以使用 :n 切换到上一个文件 || :r file | 读取文件并在当前行的后边插入 || :nr file | 读取文件并在第 n 行后边插入 | 文本查找**如果希望进行全文件搜索，可以在普通模式（按两次 Esc 键）下输入 / 命令，这时状态栏（最后一行）出现”/“并提示输入要查找的字符串，回车即可。/ 命令是向下查找，如果希望向上查找，可以使用 ? 命令。这时，输入 n 命令可以按相同的方向继续查找，输入 N 命令可以按相反的方向继续查找。搜索的字符串中可以包含一些有特殊含义的字符，如果希望搜索这些字符本身，需要在前面加反斜杠()。| 部分特殊字符列表 | || ———- | ———- || 字符** | 说明** || ^ | 匹配一行的开头 || . | 匹配一个字符 || * | 匹配0个或多个字符 || $ | 匹配一行的结尾 || [ ] | 匹配一组字符 |如果希望搜索某行中的单个字符，可以使用 f 或 F 命令，f 向上搜索，F 向下搜索，并且会把光标定位到匹配的字符。也可以使用 t 或 T 命令：t 命令向上搜索，并把光标定位到匹配字符的前面；T 命令向下搜索，并把光标定位到匹配字符的后面。 set 命令**set 命令可以对 vi 编辑器进行一些设置。使用 set 命令需要进入命令模式。| :set 命令选项 | || ———- | ———————————— || 命令** | 说明** || :set ic | 搜索时忽略大小写。 || :set ai | 设置自动缩进（自动对齐）。 || :set noai | 取消自动缩进（自动对齐）。 || :set nu | 显示行号。 || :set sw | 设置缩进的空格数，例如，将缩进空格数设置为4：:set sw=4。 || :set ws | 循环搜索：如果直到文件末尾也没有查找到指定字符，那么会回到开头继续查找。 || :set wm | 设置自动换行，例如，设置距离边际2个字符时换行：:set wm=2 。 || :set ro | 将文件类型改为只读。 || :set term | 输出终端类型。 || :set bf | 忽略输入的控制字符，如 BEL(响铃)、BS(退格)、CR(回车)等。 | 运行命令**切换到命令模式，再输入 ! 命令即可运行 Linux 命令。例如，保存文件前，如果希望查看该文件是否存在，那么输入:! ls即可列出当前目录下的文件。按任意键回到 vi 编辑器。 文本替换**切换到命令模式，再输入 s/ 命令即可对文本进行替换。语法为：:s/search/replace/gsearch 为检索的文本，replace 为要替换的文本，g 表示全局替换。 几点提示**vi 编辑器的使用讲解完毕，但是请记住下面几点：· 输入冒号(:)进入命令模式，按两次 Esc 键进入普通模式。· 命令大小写的含义是不一样的。· 必须在编辑模式下才能输入内容。 Linux文件系统**文件系统就是分区或磁盘上的所有文件的逻辑集合。文件系统不仅包含着文件中的数据而且还有文件系统的结构，所有Linux 用户和程序看到的文件、目录、软连接及文件保护信息等都存储在其中。不同Linux发行版本之间的文件系统差别很少，主要表现在系统管理的特色工具以及软件包管理方式的不同，文件目录结构基本上都是一样的。文件系统有多种类型，如：· ext2 ： 早期linux中常用的文件系统；· ext3 ： ext2的升级版，带日志功能；· RAMFS ： 内存文件系统，速度很快；· iso9660：光盘或光盘镜像；· NFS ： 网络文件系统，由SUN发明，主要用于远程文件共享；· MS-DOS ： MS-DOS文件系统；· FAT ： Windows XP 操作系统采用的文件系统；· NTFS ： Windows NT/XP 操作系统采用的文件系统。 分区与目录**文件系统位于磁盘分区中；一个硬盘可以有多个分区，也可以只有一个分区；一个分区只能包含一个文件系统。Linux文件系统与Windows有较大的差别。Windows的文件结构是多个并列的树状结构，最顶部的是不同的磁盘（分区），如 C、D、E、F等。Linux的文件结构是单个的树状结构，根目录是“/”，其他目录都要位于根目录下。每次安装系统的时候我们都会进行分区，Linux下磁盘分区和目录的关系如下：· 任何一个分区都必须对应到某个目录上，才能进行读写操作，称为“挂载”。· 被挂载的目录可以是根目录，也可以是其他二级、三级目录，任何目录都可以是挂载点。· 目录是逻辑上的区分。分区是物理上的区分。· 根目录是所有Linux的文件和目录所在的地方，需要挂载上一个磁盘分区。下图是常见的目录和分区的对应关系： img 为什么要分区，如何分区？· 可以把不同资料，分别放入不同分区中管理，降低风险。· 大硬盘搜索范围大，效率低。· /home、/var、/usr/local 经常是单独分区，因为经常会操作，容易产生碎片。为了便于定位和查找，Linux中的每个目录一般都存放特定类型的文件，下表列出了各种Linux发行版本的常见目录：| 目录** | 说明** || ———- | —————————————- || / | 根目录，只能包含目录，不能包含具体文件。 || /bin | 存放可执行文件。很多命令就对应/bin目录下的某个程序，例如 ls、cp、mkdir。/bin目录对所有用户有效。 || /dev | 硬件驱动程序。例如声卡、磁盘驱动等，还有如 /dev/null、/dev/console、/dev/zero、/dev/full 等文件。 || /etc | 主要包含系统配置文件和用户、用户组配置文件。 || /lib | 主要包含共享库文件，类似于Windows下的DLL；有时也会包含内核相关文件。 || /boot | 系统启动文件，例如Linux内核、引导程序等。 || /home | 用户工作目录（主目录），每个用户都会分配一个目录。 || /mnt | 临时挂载文件系统。这个目录一般是用于存放挂载储存设备的挂载目录的，例如挂载CD-ROM的cdrom目录。 || /proc | 操作系统运行时，进程（正在运行中的程序）信息及内核信息（比如cpu、硬盘分区、内存信息等）存放在这里。/proc目录伪装的文件系统proc的挂载目录，proc并不是真正的文件系统。 || /tmp | 临时文件目录，系统重启后不会被保存。 || /usr | /user目下的文件比较混杂，包含了管理命令、共享文件、库文件等，可以被很多用户使用。 || /var | 主要包含一些可变长度的文件，会经常对数据进行读写，例如日志文件和打印队列里的文件。 || /sbin | 和 /bin 类似，主要包含可执行文件，不过一般是系统管理所需要的，不是所有用户都需要。 | 常用文件管理命令**你可以通过下面的命令来管理文件：| Command** | Description** || —————– | —————————- || cat filename | 查看文件内容。 || cd dirname | 改变所在目录。 || cp file1 file2 | 复制文件或目录。 || file filename | 查看文件类型(binary, text, etc)。 || find filename dir | 搜索文件或目录。 || head filename | 显示文件的开头，与tail命令相对。 || less filename | 查看文件的全部内容，可以分页显示，比more命令要强大。 || ls dirname | 遍历目录下的文件或目录。 || mkdir dirname | 创建目录。 || more filename | 查看文件的全部内容，可以分页显示。 || mv file1 file2 | 移动文件或重命名。 || pwd | 显示用户当前所在目录。 || rm filename | 删除文件。 || rmdir dirname | 删除目录。 || tail filename | 显示文件的结尾，与head命令相对。 || touch filename | 文件不存在时创建一个空文件，存在时修改文件时间戳。 || whereis filename | 查看文件所在位置。 || which filename | 如果文件在环境变量PATH中有定义，那么显示文件位置。 | df命令**管理磁盘分区时经常会使用 df (disk free) 命令，df -k 命令可以用来查看磁盘空间的使用情况（以千字节计），例如：$df -kFilesystem 1K-blocks Used Available Use% Mounted on/dev/vzfs 10485760 7836644 2649116 75% //devices 0 0 0 0% /devices$每一列的含义如下：| 列** | 说明** || ———- | —————————– || Filesystem | 代表文件系统对应的设备文件的路径名（一般是硬盘上的分区）。 || kbytes | 分区包含的数据块（1024字节）的数目。 || used | 已用空间。 || avail | 可用空间。 || capacity | 已用空间的百分比。 || Mounted on | 文件系统挂载点。 |某些目录（例如 /devices）的 kbytes、used、avail 列为0，use列为0%，这些都是特殊（或虚拟）文件系统，即使位于根目录下，也不占用硬盘空间。你可以结合 -h (human readable) 选项将输出信息格式化，让人更易阅读。 du 命令**du (disk usage) 命令可以用来查看特定目录的空间使用情况。du 命令会显示每个目录所占用数据块。根据系统的不同，一个数据块可能是 512 字节或 1024 字节。举例如下：$du /etc10 /etc/cron.d126 /etc/default6 /etc/dfs…$结合 -h 选项可以让信息显示的更加清晰：$du -h /etc5k /etc/cron.d63k /etc/default3k /etc/dfs…$ 挂载文件系统**挂载是指将一个硬件设备（例如硬盘、U盘、光盘等）对应到一个已存在的目录上。 若要访问设备中的文件，必须将文件挂载到一个已存在的目录上， 然后通过访问这个目录来访问存储设备。这样就为用户提供了统一的接口，屏蔽了硬件设备的细节。Linux将所有的硬件设备看做文件，对硬件设备的操作等同于对文件的操作。注意：挂载目录可以不为空，但挂载后这个目录下以前的内容将不可用。需要知道的是，光盘、软盘、其他操作系统使用的文件系统的格式与linux使用的文件系统格式是不一样的，挂载需要确认Linux是否支持所要挂载的文件系统格式。查看当前系统所挂载的硬件设备可以使用 mount 命令：$ mount/dev/vzfs on / type reiserfs (rw,usrquota,grpquota)proc on /proc type proc (rw,nodiratime)devpts on /dev/pts type devpts (rw)$一般约定，/mnt 为临时挂载目录，例如挂载CD-ROM、远程网络设备、软盘等。也可以通过mount命令来挂载文件系统，语法为：mount -t file_system_type device_to_mount directory_to_mount_to例如：$ mount -t iso9660 /dev/cdrom /mnt/cdrom将 CD-ROM 挂载到 /mnt/cdrom 目录。注意：file_system_type用来指定文件系统类型，通常可以不指定，Linux会自动正确选择文件系统类型。挂载文件系统后，就可以通过 cd、cat 等命令来操作对应文件。可以通过 umount 命令来卸载文件系统。例如，卸载 cdrom：$ umount /dev/cdrom不过，大部分现代的Linux系统都有自动挂载卸载功能，unmount 命令较少用到。 用户和群组配额**用户和群组配额可以让管理员为每个用户或群组分配固定的磁盘空间。管理员有两种方式来分配磁盘空间：· 软限制：如果用户超过指定的空间，会有一个宽限期，等待用户释放空间。· 硬限制：没有宽限期，超出指定空间立即禁止操作。下面的命令可以用来管理配额：| 命令** | 说明** || ———- | ————————— || quota | 显示磁盘使用情况以及每个用户组的配额。 || edquota | 编辑用户和群组的配额。 || quotacheck | 查看文件系统的磁盘使用情况，创建、检查并修复配额文件。 || setquota | 设置配额。 || quotaon | 开启用户或群组的配额功能。 || quotaoff | 关闭用户或群组的配额功能。 || repquota | 打印指定文件系统的配额。 | Linux文件存储结构，包括目录项、inode、数据块**大部分的Linux文件系统（如ext2、ext3）规定，一个文件由目录项、inode和数据块组成：· 目录项：包括文件名和inode节点号。· Inode：又称文件索引节点，包含文件的基础信息以及数据块的指针。· 数据块：包含文件的具体内容。 先说inode**理解inode，要从文件储存说起。文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector），每个扇区储存512字节（相当于0.5KB）。操作系统读取硬盘的时候，不会一个扇区一个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。inode包含文件的元信息，具体来说有以下内容：· 文件的字节数。· 文件拥有者的User ID。· 文件的Group ID。· 文件的读、写、执行权限。· 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。· 链接数，即有多少文件名指向这个inode。· 文件数据block的位置。可以用stat命令，查看某个文件的inode信息：stat demo.txt总之，除了文件名以外的所有文件信息，都存在inode之中。至于为什么没有文件名，下文会有详细解释。当查看某个文件时，会先从inode表中查出文件属性及数据存放点，再从数据块中读取数据。请看文件存储结构示意图： img inode的大小**inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。每个inode节点的大小，一般是128字节或256字节。inode节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个inode。假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，占整块硬盘的12.8%。查看每个硬盘分区的inode总数和已经使用的数量，可以使用df -i 命令。查看每个inode节点的大小，可以用如下命令：sudo dumpe2fs -h /dev/hda | grep “Inode size”由于每个文件都必须有一个inode，因此有可能发生inode已经用光，但是硬盘还未存满的情况。这时，就无法在硬盘上创建新文件。 inode号码**每个inode都有一个号码，操作系统用inode号码来识别不同的文件。这里值得重复一遍，Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：首先，系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。使用ls -i命令，可以看到文件名对应的inode号码，例如：ls -i demo.txt 目录项**Linux系统中，目录（directory）也是一种文件。打开目录，实际上就是打开目录文件。目录文件的结构非常简单，就是一系列目录项（dirent）的列表。每个目录项，由两部分组成：所包含文件的文件名，以及该文件名对应的inode号码。ls命令只列出目录文件中的所有文件名：ls /etcls -i命令列出整个目录文件，即文件名和inode号码：ls -i /etc如果要查看文件的详细信息，就必须根据inode号码，访问inode节点，读取信息。ls -l命令列出文件的详细信息。ls -l /etc 硬链接和软链接**硬链接**一般情况下，文件名和inode号码是”一一对应”关系，每个inode号码对应一个文件名。但是，Linux系统允许，多个文件名指向同一个inode号码。这意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访问。这种情况就被称为”硬链接”（hard link）。ln命令可以创建硬链接，语法为：ln source_file target_file运行上面这条命令以后，源文件与目标文件的inode号码相同，都指向同一个inode。inode信息中有一项叫做”链接数”，记录指向该inode的文件名总数，这时就会增加1。反过来，删除一个文件名，就会使得inode节点中的”链接数”减1。当这个值减到0，表明没有文件名指向这个inode，系统就会回收这个inode号码，以及其所对应block区域。这里顺便说一下目录文件的”链接数”。创建目录时，默认会生成两个目录项：”.”和”..”。前者的inode号码就是当前目录的inode号码，等同于当前目录的”硬链接”；后者的inode号码就是当前目录的父目录的inode号码，等同于父目录的”硬链接”。所以，任何一个目录的”硬链接”总数，总是等于2加上它的子目录总数（含隐藏目录）,这里的2是父目录对其的“硬链接”和当前目录下的”.硬链接“。 软链接**除了硬链接以外，还有一种特殊情况。文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的”软链接”（soft link）或者”符号链接（symbolic link）。这意味着，文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错：”No such file or directory”。这是软链接与硬链接最大的不同：文件A指向文件B的文件名，而不是文件B的inode号码，文件B的inode”链接数”不会因此发生变化。ln -s命令可以创建软链接，语法为：ln source_file target_file Linux用户管理**在Linux中，有三种用户：· Root 用户：也称为超级用户，对系统拥有完全的控制权限。超级用户可以不受限制的运行任何命令。Root 用户可以看做是系统管理员。· 系统用户：系统用户是Linux运行某些程序所必须的用户，例如 mail 用户、sshd 用户等。系统用户通常为系统功能所必须的，不建议修改这些用户。· 普通用户：一般用户都是普通用户，这些用户对系统文件的访问受限，不能执行全部Linux命令。Linux支持用户组，用户组就是具有相同特征的用户的集合。一个组可以包含多个用户，每个用户也可以属于不同的组。用户组在Linux中扮演着重要的角色，方便管理员对用户进行集中管理。 与用户和组有关的系统文件**与用户和组有关的系统文件：| 系统文件** | 说明** || ———— | —————————————- || /etc/passwd | 保存用户名和密码等信息，Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行。这个文件对所有用户都是可读的。 || /etc/shadow | /etc/shadow中的记录行和/etc/passwd中的相对应，他由pwconv命令根据/etc/passwd中的数据自动产生，它的格式和/etc/passwd类似，只是对密码进行了加密。并不是所有的系统都支持这个文件。 || /etc/group | 以记录行的形式保存了用户组的所有信息。 |来看一下/etc/passwd文件的结构：$cat /etc/passwdroot:x:0:0:Superuser:/:daemon:x:1:1:System daemons:/etc:bin:x:2:2:Owner of system commands:/bin:sys:x:3:3:Owner of system files:/usr/sys:adm:x:4:4:System accounting:/usr/adm:uucp:x:5:5:UUCP administrator:/usr/lib/uucp:auth:x:7:21:Authentication administrator:/tcb/files/auth:cron:x:9:16:Cron daemon:/usr/spool/cron:listen:x:37:4:Network daemon:/usr/net/nls:lp:x:71:18:printer administrator:/usr/spool/lp:sam:x:200:50:Sam san:/usr/sam:/bin/sh可以看到，/etc/passwd文件中一行记录对应着一个用户，每行记录又被冒号分隔为7个字段，其格式和具体含义如下图所示： img 对每个字段的说明：| 字段** | 说明** || ———- | —————————————- || 用户名 | 用户名是惟一的，长度根据不同的linux系统而定，一般是8位。 || 密码 | 由于系统中还有一个/etc/shadow文件用于存放加密后的口令，所以在这里这一项是“x”来表示，如果用户没有设置口令，则该项为空。如果passwd字段中的第一个字符是“*”的话，那么，就表示该账号被查封了，系统不允许持有该账号的用户登录。 || 用户ID | 系统内部根据用户ID而不是用户名来识别不同的用户，用户ID有以下几种：· 0代表系统管理员，如果你想建立一个系统管理员的话，可以建立一个普通帐户，然后将该账户的用户ID改为0即可。· 1~500系统预留的ID。· 500以上是普通用户使用。 || 组ID | 其实这个和用户ID差不多，用来管理群组，与/etc/group文件相关。 || 描述信息 | 这个字段几乎没有什么用，只是用来解释这个账号的意义。在不同的Linux系统中，这个字段的 格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用做finger命令的输出。 || 用户主目录 | 用户登录系统的起始目录。用户登录系统后将首先进入该目录。root用户默认是/，普通用户是/home/username。 || 用户Shell | 用户登录系统时使用的Shell。 | 管理用户和组**下面是一些常用的管理用户和组的命令：| 命令** | 说明** || ———- | ———- || useradd | 添加用户。 || usermod | 修改用户信息。 || userdel | 删除用户。 || groupadd | 添加用户组。 || groupmod | 修改用户组信息。 || groupdel | 删除用户组。 | 创建用户组**添加用户时，可以将用户添加到现有的用户组，或者创建一个新的用户组。可以在 /etc/groups 文件中看到所有的用户组信息。默认的用户组通常用来管理系统用户，不建议将普通用户添加到这些用户组。使用groupadd命令创建用户组的语法为：groupadd [-g gid [-o]] [-r] [-f] groupname每个选项的含义如下：| 选项** | 说明** || ———- | ————— || -g GID | 以数字表示的用户组ID。 || -o | 可以使用重复的组ID。 || -r | 建立系统组，用来管理系统用户。 || -f | 强制创建。 || groupname | 用户组的名称。 |如果不指定选项，系统将使用默认值。例如创建一个 developers 用户组：$ groupadd developers 修改用户组**groupmod命令可以用来修改用户组，语法为：$ groupmod -n new_modified_group_name old_group_name例如，将用户组 developers_2 重命名为 developer：$ groupmod -n developer developer_2将developer用户组的ID改为545：$ groupmod -g 545 developer 删除用户组**通过groupdel命令可以删除用户组。例如，删除developer组：$ groupdel developergroupdel 仅仅删除用户组，并不删除与之相关的文件，这些文件仍然可以被所有者访问。 添加用户**添加用户可以使用useradd命令，语法为：useradd -d homedir -g groupname -m -s shell -u userid accountname每个选项的含义如下：| 选项** | 描述** || ———— | ————- || -d homedir | 指定用户主目录。 || -g groupname | 指定用户组。 || -m | 如果主目录不存在，就创建。 || -s shell | 为用户指定默认Shell。 || -u userid | 指定用户ID。 || accountname | 用户名。 |如果不指定任何选项，系统将使用默认值。useradd 命令将会修改 /etc/passwd、/etc/shadow、and /etc/group 三个文件，并创建用户主目录。下面的例子将会添加用户 mcmohd，并设置主目录为 /home/mcmohd，用户组为 developers，默认 Shell 为 Korn Shell：$ useradd -d /home/mcmohd -g developers -s /bin/ksh mcmohd注意：添加用户前请确认 developers 用户组存在。用户被创建后，可以使用 passwd 命令来设置密码，例如：$ passwd mcmohd20Changing password for user mcmohd20.New Linux password:**Retype new UNIX password:**passwd: all authentication tokens updated successfully.注意：如果你是管理员，输入 $ passwd username 可以修改你所管理的用户的密码；否则只能修改你自己的密码（不需要提供username）。 修改用户**usermod 命令可以修改现有用户的信息。usermod 命令的选项和 useradd 相同，不过可以增加 -l 选项来更改用户名。下面的例子将用户 mcmohd 的用户名修改为 mcmohd20，主目录修改为 /home/mcmohd20：$ usermod -d /home/mcmohd20 -m -l mcmohd mcmohd20 删除用户**userdel 命令可以用来删除现有用户。userdel 是一个危险的命令，请谨慎使用。userdel 命令仅有一个选项 -r，用来删除用户主目录和本地邮件。例如，删除用户 mcmohd20：$ userdel -r mcmohd20为了便于恢复被误删的用户，可以忽略 -r 选项，保留用户主目录，之后确认无误可以随时删除主目录。 Linux系统性能分析**这篇教程的目的是向大家介绍一些免费的系统性能分析工具（命令），使用这些工具可以监控系统资源使用情况，便于发现性能瓶颈。系统的整体性能取决于各种资源的平衡，类似木桶理论，某种资源的耗尽会严重阻碍系统的性能。 img Linux中需要监控的资源主要有 CPU、主存（内存）、硬盘空间、I/O时间、网络时间、应用程序等。影响系统性能的主要因素有：| 因素** | 说明** || ———– | —————————————- || 用户态CPU | CPU在用户态运行用户程序所花费的时间，包括库调用，但是不包括内核花费的时间。 || 内核态CPU | CPU在内核态运行系统服务所花费的时间。所有的 I/O 操作都需要调用系统服务，程序员可以通过阻塞 I/O 传输来影响这部分的时间。 || I/O 时间和网络时间 | 响应 I/O 请求、处理网络连接所花费的时间。 || 内存 | 切换上下文和交换数据（虚拟内存页导入和导出）花费的时间。 || 应用程序 | 程序等待运行的时间——CPU正在运行其他程序，等待切换到当前程序。 |说明：一般认为用户态CPU和内核态CPU花费的时间小于70%时是良好状态。下面的命令可以用来监控系统性能并作出相应调整：| 命令** | 说明** || ———- | —————————————- || nice | 启动程序时指定进程优先级。 || renice | 调整现有进程的优先级。 || netstat | 显示各种网络相关信息，包括网络连接情况、路由表、接口状态(Interface Statistics)、masquerade 连接、多播成员 (Multicast Memberships)等。实际上，netstat 用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。 || time | 检测一个命令运行时间以及资源（CPU、内存、I/O等）使用情况。 || uptime | 查看系统负载情况。 || ps | 查看系统中进程的资源使用情况（瞬时状态，不是动态监控）。 || vmstat | 报告虚拟内存使用情况。 || gprof | 精确分析程序的性能，能给出函数调用时间、调用次数、调用关系等。 || top | 实时监控系统中各个进程资源的资源使用情况。 |常用命令组合：· vmstat、sar、mpstat检测是否存在CPU瓶颈；· vmstat、free检测是否存在内存瓶颈；· iostat检测是否存在磁盘I/O瓶颈；· netstat检测是否存在网络I/O瓶颈。 Linux系统日志及日志分析**Linux系统拥有非常灵活和强大的日志功能，可以保存几乎所有的操作记录，并可以从中检索出我们需要的信息。大部分Linux发行版默认的日志守护进程为 syslog，位于 /etc/syslog 或 /etc/syslogd，默认配置文件为 /etc/syslog.conf，任何希望生成日志的程序都可以向 syslog 发送信息。Linux系统内核和许多程序会产生各种错误信息、警告信息和其他的提示信息，这些信息对管理员了解系统的运行状态是非常有用的，所以应该把它们写到日志文件中去。完成这个过程的程序就是syslog。syslog可以根据日志的类别和优先级将日志保存到不同的文件中。例如，为了方便查阅，可以把内核信息与其他信息分开，单独保存到一个独立的日志文件中。默认配置下，日志文件通常都保存在“/var/log”目录下。 日志类型**下面是常见的日志类型，但并不是所有的Linux发行版都包含这些类型：| 类型** | 说明** || ————- | —————————————- || auth | 用户认证时产生的日志，如login命令、su命令。 || authpriv | 与 auth 类似，但是只能被特定用户查看。 || console | 针对系统控制台的消息。 || cron | 系统定期执行计划任务时产生的日志。 || daemon | 某些守护进程产生的日志。 || ftp | FTP服务。 || kern | 系统内核消息。 || local0.local7 | 由自定义程序使用。 || lpr | 与打印机活动有关。 || mail | 邮件日志。 || mark | 产生时间戳。系统每隔一段时间向日志文件中输出当前时间，每行的格式类似于 May 26 11:17:09 rs2 – MARK –，可以由此推断系统发生故障的大概时间。 || news | 网络新闻传输协议(nntp)产生的消息。 || ntp | 网络时间协议(ntp)产生的消息。 || user | 用户进程。 || uucp | UUCP子系统。 | 日志优先级**常见的日志优先级请见下标：| 优先级** | 说明** || ———– | —————————– || emerg | 紧急情况，系统不可用（例如系统崩溃），一般会通知所有用户。 || alert | 需要立即修复，例如系统数据库损坏。 || crit | 危险情况，例如硬盘错误，可能会阻碍程序的部分功能。 || err | 一般错误消息。 || warning | 警告。 || notice | 不是错误，但是可能需要处理。 || info | 通用性消息，一般用来提供有用信息。 || debug | 调试程序产生的信息。 || none | 没有优先级，不记录任何日志消息。 | 常见日志文件**所有的系统应用都会在 /var/log 目录下创建日志文件，或创建子目录再创建日志文件。例如：| 文件/目录** | 说明** || —————– | ————————————— || /var/log/boot.log | 开启或重启日志。 || /var/log/cron | 计划任务日志 || /var/log/maillog | 邮件日志。 || /var/log/messages | 该日志文件是许多进程日志文件的汇总，从该文件可以看出任何入侵企图或成功的入侵。 || /var/log/httpd 目录 | Apache HTTP 服务日志。 || /var/log/samba 目录 | samba 软件日志 | /etc/syslog.conf 文件**/etc/syslog.conf 是 syslog 的配置文件，会根据日志类型和优先级来决定将日志保存到何处。典型的 syslog.conf 文件格式如下所示：.err;kern.debug;auth.notice /dev/consoledaemon,auth.notice /var/log/messageslpr.info /var/log/lpr.logmail. /var/log/mail.logftp. /var/log/ftp.logauth. @see.xidian.edu.cnauth. root,amroodnetinfo.err /var/log/netinfo.loginstall. /var/log/install.log.emerg .alert |program_namemark. /dev/console第一列为日志类型和日志优先级的组合，每个类型和优先级的组合称为一个选择器；后面一列为保存日志的文件、服务器，或输出日志的终端。syslog 进程根据选择器决定如何操作日志。对配置文件的几点说明：· 日志类型和优先级由点号(.)分开，例如 kern.debug 表示由内核产生的调试信息。· kern.debug 的优先级大于 debug。· 星号()表示所有，例如 .debug 表示所有类型的调试信息，kern.* 表示由内核产生的所有消息。· 可以使用逗号(,)分隔多个日志类型，使用分号(;)分隔多个选择器。对日志的操作包括：· 将日志输出到文件，例如 /var/log/maillog 或 /dev/console。· 将消息发送给用户，多个用户用逗号(,)分隔，例如 root, amrood。· 通过管道将消息发送给用户程序，注意程序要放在管道符(|)后面。· 将消息发送给其他主机上的 syslog 进程，这时 /etc/syslog.conf 文件后面一列为以@开头的主机名，例如@see.xidian.edu.cn。 logger 命令**logger 是Shell命令，可以通过该命令使用 syslog 的系统日志模块，还可以从命令行直接向系统日志文件写入一行信息。logger命令的语法为：logger [-i] [-f filename] [-p priority] [-t tag] [message…]每个选项的含义如下：| 选项** | 说明** || ———– | —————————————- || -f filename | 将 filename 文件的内容作为日志。 || -i | 每行都记录 logger 进程的ID。 || -p priority | 指定优先级；优先级必须是形如 facility.priority 的完整的选择器，默认优先级为 user.notice。 || -t tag | 使用指定的标签标记每一个记录行。 || message | 要写入的日志内容，多条日志以空格为分隔；如果没有指定日志内容，并且 -f filename 选项为空，那么会把标准输入作为日志内容。 |例如，将ping命令的结果写入日志：$ ping 192.168.0.1 | logger -it logger_test -p local3.notice&amp;$ tail -f /var/log/userlogOct 6 12:48:43 kevein logger_test[22484]: PING 192.168.0.1 (192.168.0.1) 56(84) bytes of data.Oct 6 12:48:43 kevein logger_test[22484]: 64 bytes from 192.168.0.1: icmp_seq=1 ttl=253 time=49.7 msOct 6 12:48:44 kevein logger_test[22484]: 64 bytes from 192.168.0.1: icmp_seq=2 ttl=253 time=68.4 msOct 6 12:48:45 kevein logger_test[22484]: 64 bytes from 192.168.0.1: icmp_seq=3 ttl=253 time=315 msOct 6 12:48:46 kevein logger_test[22484]: 64 bytes from 192.168.0.1: icmp_seq=4 ttl=253 time=279 msOct 6 12:48:47 kevein logger_test[22484]: 64 bytes from 192.168.0.1: icmp_seq=5 ttl=253 time=347 msOct 6 12:48:49 kevein logger_test[22484]: 64 bytes from 192.168.0.1: icmp_seq=6 ttl=253 time=701 msOct 6 12:48:50 kevein logger_test[22484]: 64 bytes from 192.168.0.1: icmp_seq=7 ttl=253 time=591 msOct 6 12:48:51 kevein logger_test[22484]: 64 bytes from 192.168.0.1: icmp_seq=8 ttl=253 time=592 msOct 6 12:48:52 kevein logger_test[22484]: 64 bytes from 192.168.0.1: icmp_seq=9 ttl=253 time=611 msOct 6 12:48:53 kevein logger_test[22484]: 64 bytes from 192.168.0.1: icmp_seq=10 ttl=253 time=931 msping命令的结果成功输出到 /var/log/userlog 文件。命令 logger -it logger_test -p local3.notice 各选项的含义：· -i：在每行都记录进程ID；· -t logger_test：每行记录都加上“logger_test”这个标签；· -p local3.notice：设置日志类型和优先级。 日志转储**日志转储也叫日志回卷或日志轮转。Linux中的日志通常增长很快，会占用大量硬盘空间，需要在日志文件达到指定大小时分开存储。syslog 只负责接收日志并保存到相应的文件，但不会对日志文件进行管理，因此经常会造成日志文件过大，尤其是WEB服务器，轻易就能超过1G，给检索带来困难。大多数Linux发行版使用 logrotate 或 newsyslog 对日志进行管理。logrotate 程序不但可以压缩日志文件，减少存储空间，还可以将日志发送到指定 E-mail，方便管理员及时查看日志。例如，规定邮件日志 /var/log/maillog 超过1G时转储，每周一次，那么每隔一周 logrotate 进程就会检查 /var/log/maillog 文件的大小：· 如果没有超过1G，不进行任何操作。· 如果在1G~2G之间，就会创建新文件 /var/log/maillog.1，并将多出的1G日志转移到该文件，以给 /var/log/maillog 文件瘦身。· 如果在2G~3G之间，会继续创建新文件 /var/log/maillog.2，并将 /var/log/maillog.1 的内容转移到该文件，将 /var/log/maillog 的内容转移到 /var/log/maillog.1，以保持 /var/log/maillog 文件不超过1G。可以看到，每次转存都会创建一个新文件（如果不存在），命名格式为日志文件名加一个数字（从1开始自动增长），以保持当前日志文件和转存后的日志文件不超过指定大小。logrotate 的主要配置文件是 /etc/logrotate.conf，/etc/logrotate.d 目录是对 /etc/logrotate.conf 的补充，或者说为了不使 /etc/logrotate.conf 过大而设置。可以通过 cat 命令查看它的内容：$cat /etc/logrotate.conf# see “man logrotate” for details //可以查看帮助文档# rotate log files weeklyweekly //设置每周转储一次# keep 4 weeks worth of backlogsrotate 4 //最多转储4次# create new (empty) log files after rotating old onescreate //当转储后文件不存储时创建它# uncomment this if you want your log files compressed#compress //以压缩方式转储# RPM packages drop log rotation information into this directoryinclude /etc/logrotate.d //其他日志文件的转储方式，包含在该目录下# no packages own wtmp – we’ll rotate them here/var/log/wtmp { //设置/var/log/wtmp日志文件的转储参数​ monthly //每月转储​ create 0664 root utmp //转储后文件不存在时创建它，文件所有者为root，所属组为utmp，对应的权限为0664​ rotate 1 //最多转储一次}注意：include 允许管理员把多个分散的文件集中到一个，类似于C语言的 #include，将其他文件的内容包含进当前文件。include 非常有用，一些程序会把转储日志的配置文件放在 /etc/logrotate.d 目录，这些配置文件会覆盖或增加 /etc/logrotate.conf 的配置项，如果没有指定相关配置，那么采用 /etc/logrotate.conf 的默认配置。所以，建议将 /etc/logrotate.conf 作为默认配置文件，第三方程序在 /etc/logrotate.d 目录下自定义配置文件。logrotate 也可以作为命令直接运行来修改配置文件。 Linux信号机制与信号处理**信号(signal)是Linux进程间通信的一种机制，全称为软中断信号，也被称为软中断。信号本质上是在软件层次上对硬件中断机制的一种模拟。与其他进程间通信方式（例如管道、共享内存等）相比，信号所能传递的信息比较粗糙，只是一个整数。但正是由于传递的信息量少，信号也便于管理和使用，可以用于系统管理相关的任务，例如通知进程终结、中止或者恢复等。每种信号用一个整型常量宏表示，以SIG开头，比如SIGCHLD、SIGINT等，它们在系统头文件中定义。信号由内核(kernel)管理，产生方式多种多样：· 可以由内核自身产生，比如出现硬件错误、内存读取错误，分母为0的除法等，内核需要通知相应进程。· 也可以由其他进程产生并发送给内核，再由内核传递给目标进程。信号传递的过程：· 内核中针对每一个进程都有一个表来保存信号。· 当内核需要将信号传递给某个进程时，就在该进程对应的表中写入信号，这样就生成了信号。· 当该进程由用户态陷入内核态，再次切换到用户态之前，会查看表中的信号。如果有信号，进程就会首先执行信号对应的操作，此时叫做执行信号。· 从生成信号到将信号传递给对应进程这段时间，信号处于等待状态。· 我们可以编写代码，让进程阻塞(block)某些信号，也就是让这些信号始终处于等待的状态，直到进程取消阻塞(unblock)或者忽略信号。 信号种类**下表列出了一些常见信号：| 信号名称** | 数字表示** | 说明** || ———— | ———— | —————————————- || SIGHUP | 1 | 终端挂起或控制进程终止。当用户退出Shell时，由该进程启动的所有进程都会收到这个信号，默认动作为终止进程。 || SIGINT | 2 | 键盘中断。当用户按下组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号。默认动作为终止进程。 || SIGQUIT | 3 | 键盘退出键被按下。当用户按下或组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号。默认动作为退出程序。 || SIGFPE | 8 | 发生致命的运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为0等所有的算法错误。默认动作为终止进程并产生core文件。 || SIGKILL | 9 | 无条件终止进程。进程接收到该信号会立即终止，不进行清理和暂存工作。该信号不能被忽略、处理和阻塞，它向系统管理员提供了可以杀死任何进程的方法。 || SIGALRM | 14 | 定时器超时，默认动作为终止进程。 || SIGTERM | 15 | 程序结束信号，可以由 kill 命令产生。与SIGKILL不同的是，SIGTERM 信号可以被阻塞和终止，以便程序在退出前可以保存工作或清理临时文件等。 |通过 kill -l 命令可以查看系统支持的所有信号：$ kill -l1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE9) SIGKILL 10) SIGUSR1 11) SIGSEGV 12) SIGUSR213) SIGPIPE 14) SIGALRM 15) SIGTERM 16) SIGSTKFLT17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU25) SIGXFSZ 26) SIGVTALRM 27) SIGPROF 28) SIGWINCH29) SIGIO 30) SIGPWR 31) SIGSYS 34) SIGRTMIN35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+3 38) SIGRTMIN+439) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+843) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+1247) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-1451) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-1055) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-7 58) SIGRTMAX-659) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-263) SIGRTMAX-1 64) SIGRTMAX上面仅是一个演示，不同的Linux发行版支持的信号可能不同。每种信号都会有一个默认动作。默认动作就是脚本或程序接收到该信号所做出的默认操作。常见的默认动作有终止进程、退出程序、忽略信号、重启暂停的进程等，上表中也对部分默认动作进行了说明。 发送信号**有多种方式可以向程序或脚本发送信号，例如按下组合键会发送SIGINT信号，终止当前进程。还可以通过 kill 命令发送信号，语法为：$ kill -signal pidsignal为要发送的信号，可以是信号名称或数字；pid为接收信号的进程ID。例如：$ kill -1 1001将SIGHUP信号发送给进程ID为1001的程序，程序会终止执行。又如，强制杀死ID为1001的进程：$ kill -9 1001 捕获信号**通常情况下，直接终止进程并不是我们所希望的。例如，按下，进程被立即终止，不会清理创建的临时文件，带来系统垃圾，也不会保存正在进行的工作，导致需要重做。可以通过编程来捕获这些信号，当终止信号出现时，可以先进行清场和保存处理，再退出程序。用户程序可以通过C/C++等代码捕获信号，这将在Linux C编程中进行讲解，这里仅介绍如果通过Linux命令捕获信号。通过 trap 命令就可以捕获信号，语法为：$ trap commands signalscommands为Linux系统命令或用户自定义命令；signals为要捕获的信号，可以为信号名称或数字。捕获到信号后，可以有三种处理：· 执行一段脚本来做一些处理工作，例如清理临时文件；· 接受（恢复）信号的默认操作；· 忽略当前信号。 1) 清理临时文件**脚本捕获到终止信号后一个常见的动作就是清理临时文件。例如：$ trap “rm -f $WORKDIR/work1$$ $WORKDIR/dataout$$; exit” 2当用户按下后，脚本先清理临时文件 work1$$ 和 dataout$$ 再退出。注意：exit 命令是必须的，否则脚本捕获到信号后会继续执行而不是退出。修改上面的脚本，使接收到 SIGHUP 时进行同样的操作：$ trap “rm $WORKDIR/work1$$ $WORKDIR/dataout$$; exit” 1 2几点注意：· 如果执行多个命令，需要将命令用引号包围；· 只有脚本执行到 trap 命令时才会捕获信号；· 再次接收到信号时还会执行同样的操作。上面的脚本，执行到 trap 命令时就会替换 WORKDIR 和 $$ 的值。如果希望接收到 SIGHUP 或 SIGINT 信号时再替换其值，那么可以将命令放在单引号内，例如：$ trap ‘rm $WORKDIR/work1$$ $WORKDIR/dataout$$; exit’ 1 2 2) 忽略信号**如果 trap 命令的 commands 为空，将会忽略接收到的信号，即不做任何处理，也不执行默认动作。例如：$ trap ‘’ 2也可以同时忽略多个信号：$ trap ‘’ 1 2 3 15注意：必须被引号包围，不能写成下面的形式：$ trap 2 3) 恢复默认动作**如果希望改变信号的默认动作后再次恢复默认动作，那么省略 trap 命令的 commands 即可，例如：$ trap 1 2将恢复SIGHUP 和 SIGINT 信号的默认动作。","categories":[],"tags":[]},{"title":"C语言中文网：Shell教程","slug":"shell-base","date":"2017-07-03T16:00:00.000Z","updated":"2017-07-05T02:10:22.538Z","comments":true,"path":"2017/07/04/shell-base/","link":"","permalink":"http://yoursite.com/2017/07/04/shell-base/","excerpt":"","text":"Shell简介：什么是Shell，Shell命令的两种执行方式 **Shell本身是一个用C语言编写的程序，它是用户使用Unix/Linux的桥梁，用户的大部分工作都是通过Shell完成的。Shell既是一种命令语言，又是一种程序设计语言。作为命令语言，它交互式地解释和执行用户输入的命令；作为程序设计语言，它定义了各种变量和参数，并提供了许多在高级语言中才具有的控制结构，包括循环和分支。它虽然不是Unix/Linux系统内核的一部分，但它调用了系统核心的大部分功能来执行程序、建立文件并以并行的方式协调各个程序的运行。因此，对于用户来说，shell是最重要的实用程序，深入了解和熟练掌握shell的特性极其使用方法，是用好Unix/Linux系统的关键。可以说，shell使用的熟练程度反映了用户对Unix/Linux使用的熟练程度。注意：单独地学习 Shell 是没有意义的，请先参考Unix/Linux入门教程，了解 Unix/Linux 基础。 Shell有两种执行命令的方式：**· 交互式（Interactive）：解释执行用户的命令，用户输入一条命令，Shell就解释执行一条。 · 批处理（Batch）：用户事先写一个Shell脚本(Script)，其中有很多条命令，让Shell一次把这些命令执行完，而不必一条一条地敲命令。 Shell脚本和编程语言很相似，也有变量和流程控制语句，但Shell脚本是解释执行的，不需要编译，Shell程序从脚本中一行一行读取并执行这些命令，相当于一个用户把脚本中的命令一行一行敲到Shell提示符下执行。Shell初学者请注意，在平常应用中，建议不要用 root 帐号运行 Shell 。作为普通用户，不管您有意还是无意，都无法破坏系统；但如果是 root，那就不同了，只要敲几个字母，就可能导致灾难性后果。 几种常见的Shell**上面提到过，Shell是一种脚本语言，那么，就必须有解释器来执行这些脚本。Unix/Linux上常见的Shell脚本解释器有bash、sh、csh、ksh等，习惯上把它们称作一种Shell。我们常说有多少种Shell，其实说的是Shell脚本解释器。 bash**bash是Linux标准默认的shell，本教程也基于bash讲解。bash由Brian Fox和Chet Ramey共同完成，是BourneAgain Shell的缩写，内部命令一共有40个。Linux使用它作为默认的shell是因为它有诸如以下的特色： · 可以使用类似DOS下面的doskey的功能，用方向键查阅和快速输入并修改命令。 · 自动通过查找匹配的方式给出以某字符串开头的命令。 · 包含了自身的帮助功能，你只要在提示符下面键入help就可以得到相关的帮助。 sh**sh 由Steve Bourne开发，是Bourne Shell的缩写，sh 是Unix 标准默认的shell。 ash**ash shell 是由Kenneth Almquist编写的，Linux中占用系统资源最少的一个小shell，它只包含24个内部命令，因而使用起来很不方便。 csh**csh 是Linux比较大的内核，它由以William Joy为代表的共计47位作者编成，共有52个内部命令。该shell其实是指向/bin/tcsh这样的一个shell，也就是说，csh其实就是tcsh。 ksh**ksh 是Korn shell的缩写，由Eric Gisin编写，共有42条内部命令。该shell最大的优点是几乎和商业发行版的ksh完全兼容，这样就可以在不用花钱购买商业版本的情况下尝试商业版本的性能了。注意：bash是 Bourne Again Shell 的缩写，是linux标准的默认shell ，它基于Bourne shell，吸收了C shell和Korn shell的一些特性。bash完全兼容sh，也就是说，用sh写的脚本可以不加修改的在bash中执行。 Shell脚本语言与编译型语言的差异**大体上，可以将程序设计语言可以分为两类：编译型语言和解释型语言。 编译型语言**很多传统的程序设计语言，例如Fortran、Ada、Pascal、C、C++和Java，都是编译型语言。这类语言需要预先将我们写好的源代码(source code)转换成目标代码(object code)，这个过程被称作“编译”。运行程序时，直接读取目标代码(object code)。由于编译后的目标代码(object code)非常接近计算机底层，因此执行效率很高，这是编译型语言的优点。但是，由于编译型语言多半运作于底层，所处理的是字节、整数、浮点数或是其他机器层级的对象，往往实现一个简单的功能需要大量复杂的代码。例如，在C++里，就很难进行“将一个目录里所有的文件复制到另一个目录中”之类的简单操作。 解释型语言**解释型语言也被称作“脚本语言”。执行这类程序时，解释器(interpreter)需要读取我们编写的源代码(source code)，并将其转换成目标代码(object code)，再由计算机运行。因为每次执行程序都多了编译的过程，因此效率有所下降。使用脚本编程语言的好处是，它们多半运行在比编译型语言还高的层级，能够轻易处理文件与目录之类的对象；缺点是它们的效率通常不如编译型语言。不过权衡之下，通常使用脚本编程还是值得的：花一个小时写成的简单脚本，同样的功能用C或C++来编写实现，可能需要两天，而且一般来说，脚本执行的速度已经够快了，快到足以让人忽略它性能上的问题。脚本编程语言的例子有awk、Perl、Python、Ruby与Shell。 什么时候使用Shell**因为Shell似乎是各UNIX系统之间通用的功能，并且经过了POSIX的标准化。因此，Shell脚本只要“用心写”一次，即可应用到很多系统上。因此，之所以要使用Shell脚本是基于： · 简单性：Shell是一个高级语言；通过它，你可以简洁地表达复杂的操作。 · 可移植性：使用POSIX所定义的功能，可以做到脚本无须修改就可在不同的系统上执行。 · 开发容易：可以在短时间内完成一个功能强大又妤用的脚本。 但是，考虑到Shell脚本的命令限制和效率问题，下列情况一般不使用Shell： 资源密集型的任务，尤其在需要考虑效率时（比如，排序，hash等等）。 需要处理大任务的数学操作，尤其是浮点运算，精确运算，或者复杂的算术运算（这种情况一般使用C++或FORTRAN 来处理）。 有跨平台（操作系统）移植需求（一般使用C 或Java）。 复杂的应用，在必须使用结构化编程的时候（需要变量的类型检查，函数原型，等等）。 对于影响系统全局性的关键任务应用。 对于安全有很高要求的任务，比如你需要一个健壮的系统来防止入侵、破解、恶意破坏等等。 项目由连串的依赖的各个部分组成。 需要大规模的文件操作。 需要多维数组的支持。 需要数据结构的支持，比如链表或数等数据结构。 需要产生或操作图形化界面 GUI。 需要直接操作系统硬件。 需要 I/O 或socket 接口。 需要使用库或者遗留下来的老代码的接口。 私人的、闭源的应用（shell 脚本把代码就放在文本文件中，全世界都能看到）。 如果你的应用符合上边的任意一条，那么就考虑一下更强大的语言吧——或许是Perl、Tcl、Python、Ruby——或者是更高层次的编译语言比如C/C++，或者是Java。即使如此，你会发现，使用shell来原型开发你的应用，在开发步骤中也是非常有用的。 第一个Shell脚本**打开文本编辑器，新建一个文件，扩展名为sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用php写shell 脚本，扩展名就用php好了。输入一些代码： 12#!/bin/bashecho \"Hello World !\" “#!” 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种Shell。echo命令用于向窗口输出文本。运行Shell脚本有两种方法。 作为可执行程序**将上面的代码保存为test.sh，并 cd 到相应目录： 12$ chmod +x ./test.sh #使脚本具有执行权限$ ./test.sh #执行脚本 注意，一定要写成./test.sh，而不是test.sh。运行其它二进制的程序也一样，直接写test.sh，linux系统会去PATH里寻找有没有叫test.sh的，而只有/bin, /sbin, /usr/bin，/usr/sbin等在PATH里，你的当前目录通常不在PATH里，所以写成test.sh是会找不到命令的，要用./test.sh告诉系统说，就在当前目录找。通过这种方式运行bash脚本，第一行一定要写对，好让系统查找到正确的解释器。这里的”系统”，其实就是shell这个应用程序（想象一下Windows Explorer），但我故意写成系统，是方便理解，既然这个系统就是指shell，那么一个使用/bin/sh作为解释器的脚本是不是可以省去第一行呢？是的。 作为解释器参数**这种运行方式是，直接运行解释器，其参数就是shell脚本的文件名，如： 12$ /bin/sh test.sh$ /bin/php test.php 这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。再看一个例子。下面的脚本使用 read 命令从 stdin 获取输入并赋值给 PERSON 变量，最后在 stdout 上输出： 1234567#!/bin/bash# Author : mozhiyan# Copyright (c) http://see.xidian.edu.cn/cpp/linux/# Script follows here:echo \"What is your name?\"read PERSONecho \"Hello, $PERSON\" 运行脚本： 123456$ chmod +x ./test.sh$ ./test.shWhat is your name?mozhiyanHello, mozhiyan$ Shell变量：Shell变量的定义、删除变量、只读变量、变量类型**Shell支持自定义变量。 定义变量**定义变量时，变量名不加美元符号（$），如： 1variableName=\"value\" 注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则： · 首个字符必须为字母（a-z，A-Z）。 · 中间不能有空格，可以使用下划线（_）。 · 不能使用标点符号。 · 不能使用bash里的关键字（可用help命令查看保留关键字）。 变量定义举例： 12myUrl=\"http://see.xidian.edu.cn/cpp/linux/\"myNum=100 使用变量**使用一个定义过的变量，只要在变量名前面加美元符号（$）即可，如： 123your_name=\"mozhiyan\"echo $your_nameecho $&#123;your_name&#125; 变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况： 1234for skill in Ada Coffe Action Java do echo \"I am good at $&#123;skill&#125;Script\"done 如果不给skill变量加花括号，写成echo &quot;I am good at $skillScript&quot;，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。推荐给所有变量加上花括号，这是个好的编程习惯。 重新定义变量**已定义的变量，可以被重新定义，如： 1234myUrl=\"http://see.xidian.edu.cn/cpp/linux/\"echo $&#123;myUrl&#125;myUrl=\"http://see.xidian.edu.cn/cpp/shell/\"echo $&#123;myUrl&#125; 这样写是合法的，但注意，第二次赋值的时候不能写 $myUrl=&quot;http://see.xidian.edu.cn/cpp/shell/&quot;，使用变量的时候才加美元符（$）。 只读变量**使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。下面的例子尝试更改只读变量，结果报错： 123myUrl=\"http://see.xidian.edu.cn/cpp/shell/\"readonly myUrlmyUrl=\"http://see.xidian.edu.cn/cpp/danpianji/\" 运行脚本，结果如下： 1/bin/sh: NAME: This variable is read only. 删除变量**使用 unset 命令可以删除变量。语法： 1unset variable_name 变量被删除后不能再次使用；unset 命令不能删除只读变量。举个例子： 1234#!/bin/shmyUrl=\"http://see.xidian.edu.cn/cpp/u/xitong/\"unset myUrlecho $myUrl 上面的脚本没有任何输出。 变量类型**运行shell时，会同时存在三种变量： 1) 局部变量**局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。 2) 环境变量**所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。 3) shell变量**shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行 Shell特殊变量：Shell $0, $#, $*, $@, $?, `# 和命令行参数**前面已经讲到，变量名只能包含数字、字母和下划线，因为某些包含其他字符的变量有特殊含义，这样的变量被称为特殊变量。例如，$ 表示当前Shell进程的ID，即pid，看下面的代码： $echo $$ 运行结果 29949 特殊变量列表 变量** 含义** $0 当前脚本的文件名 $n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。 $# 传递给脚本或函数的参数个数。 $* 传递给脚本或函数的所有参数。 $@ 传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 $* 稍有不同，下面将会讲到。 $? 上个命令的退出状态，或函数的返回值。 $$ 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。 命令行参数**运行脚本时传递给脚本的参数称为命令行参数。命令行参数用$n表示，例如，$1表示第一个参数，$2 表示第二个参数，依次类推。请看下面的脚本： 1234567#!/bin/bashecho \"File Name: $0\"echo \"First Parameter : $1\"echo \"First Parameter : $2\"echo \"Quoted Values: $@\"echo \"Quoted Values: $*\"echo \"Total Number of Parameters : $#\" 运行结果： 1234567$./test.sh Zara AliFile Name : ./test.shFirst Parameter : ZaraSecond Parameter : AliQuoted Values: Zara AliQuoted Values: Zara AliTotal Number of Parameters : 2 $* 和 $@ 的区别**$* 和$@都表示传递给函数或脚本的所有参数， 不被双引号(“ “)包含时，都以&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot;的形式输出所有参数。但是当它们被双引号(“ “)包含时，&quot;$*&quot;会将所有的参数作为一个整体，以&quot;$1 $2 … $n&quot;的形式输出所有参数；&quot;$@&quot; 会将各个参数分开，以&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数。 下面的例子可以清楚的看到$*和$@ 的区别： 123456789101112131415161718192021222324252627282930#!/bin/bashecho \"$*=\" $*echo \"\\\"$*\\\"=\" \"$*\"echo \"$@=\" $@echo \"\\\"$@\\\"=\" \"$@\"echo \"print each param from $*\"for var in $*do echo \"$var\"doneecho \"print each param from $@\"for var in $@do echo \"$var\"doneecho \"print each param from \\\"$*\\\"\"for var in \"$*\"do echo \"$var\"doneecho \"print each param from \\\"$@\\\"\"for var in \"$@\"do echo \"$var\"done 执行 ./test.sh “a” “b” “c” “d”，看到下面的结果： 123456789101112131415161718192021$*= a b c d\"$*\"= a b c d$@= a b c d\"$@\"= a b c dprint each param from $*abcdprint each param from $@abcdprint each param from \"$*\"a b c dprint each param from \"$@\"abcd 退出状态**$?可以获取上一个命令的退出状态。所谓退出状态，就是上一个命令执行后的返回结果。退出状态是一个数字，一般情况下，大部分命令执行成功会返回 0，失败返回 1。不过，也有一些命令返回其他值，表示不同类型的错误。下面例子中，命令成功执行： 12345678910$./test.sh Zara AliFile Name : ./test.shFirst Parameter : ZaraSecond Parameter : AliQuoted Values: Zara AliQuoted Values: Zara AliTotal Number of Parameters : 2echo ?0$ $? 也可以表示函数的返回值，后续将会讲解。 Shell替换：Shell变量替换，命令替换，转义字符**如果表达式中包含特殊字符，Shell 将会进行替换。例如，在双引号中使用变量就是一种替换，转义字符也是一种替换。举个例子： 1234#!/bin/basha=10echo -e \"Value of a is $a \\n\" 运行结果： Value of a is 10 这里 -e表示对转义字符进行替换。如果不使用 -e 选项，将会原样输出： Value of a is 10\\n 下面的转义字符都可以用在echo中： 转义字符** 含义** \\ 反斜杠 \\a 警报，响铃 \\b 退格（删除键） \\f 换页(FF)，将当前位置移到下页开头 \\n 换行 \\r 回车 \\t 水平制表符（tab键） \\v 垂直制表符 可以使用echo命令的 -E选项禁止转义，默认也是不转义的；使用-n选项可以禁止插入换行符。 命令替换**命令替换是指Shell可以先执行命令，将输出结果暂时保存，在适当的地方输出。命令替换的语法： 1`command` 注意是反引号，不是单引号，这个键位于 Esc` 键下方。下面的例子中，将命令执行结果保存在变量中： 12345678910#!/bin/bashDATE=dateecho \"Date is $DATE\"USERS=who | wc -lecho \"Logged in user are $USERS\"UP=date ; uptimeecho \"Uptime is $UP\" 运行结果： 1234Date is Thu Jul 2 03:59:57 MST 2009Logged in user are 1Uptime is Thu Jul 2 03:59:57 MST 200903:59:57 up 20 days, 14:03, 1 user, load avg: 0.13, 0.07, 0.15 变量替换**变量替换可以根据变量的状态（是否为空、是否定义等）来改变它的值可以使用的变量替换形式： 形式** 说明** ${var} 变量本来的值 ${var:-word} 如果变量 var 为空或已被删除(unset)，那么返回 word，但不改变 var 的值。 ${var:=word} 如果变量 var 为空或已被删除(unset)，那么返回 word，并将 var 的值设置为 word。 ${var:?message} 如果变量 var 为空或已被删除(unset)，那么将消息 message 送到标准错误输出，可以用来检测变量 var 是否可以被正常赋值。若此替换出现在Shell脚本中，那么脚本将停止运行。 ${var:+word} 如果变量 var 被定义，那么返回 word，但不改变 var 的值。 请看下面的例子： 123456789101112131415161718#!/bin/bashecho $&#123;var:-\"Variable is not set\"&#125;echo \"1 - Value of var is $&#123;var&#125;\"echo $&#123;var:=\"Variable is not set\"&#125;echo \"2 - Value of var is $&#123;var&#125;\"unset varecho $&#123;var:+\"This is default value\"&#125;echo \"3 - Value of var is $var\"var=\"Prefix\"echo $&#123;var:+\"This is default value\"&#125;echo \"4 - Value of var is $var\"echo $&#123;var:?\"Print this message\"&#125;echo \"5 - Value of var is $&#123;var&#125;\" 运行结果： 12345678910Variable is not set1 - Value of var isVariable is not set2 - Value of var is Variable is not set3 - Value of var isThis is default value4 - Value of var is PrefixPrefix5 - Value of var is Prefix Shell运算符：Shell算数运算符、关系运算符、布尔运算符、字符串运算符等**Bash 支持很多运算符，包括算数运算符、关系运算符、布尔运算符、字符串运算符和文件测试运算符。原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。expr 是一款表达式计算工具，使用它能完成表达式的求值操作。例如，两个数相加： 123#!/bin/bashval=`expr 2 + 2`echo \"Total value : $val\" 运行脚本输出： Total value : 4 两点注意： · 表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。 · 完整的表达式要被(``)包含，注意这个字符不是常用的单引号，在 Esc 键下边。 算术运算符**先来看一个使用算术运算符的例子： 12345678910111213141516171819202122232425262728#!/bin/sh# 加法a=10b=20val=`expr $a + $b`echo \"a + b : $val\"# 减法val=`expr $a - $b`echo \"a - b : $val\"# 乘法val=`expr $a \\* $b`echo \"a * b : $val\"# 除法val=`expr $b / $a`echo \"b / a : $val\"# 取余val=`expr $b % $a`echo \"b % a : $val\"# 相等if [ $a == $b ]then echo \"a is equal to b\"fi# 不相等if [ $a != $b ]then echo \"a is not equal to b\"fi 运行结果： 123456a + b : 30a - b : -10a * b : 200b / a : 2b % a : 0a is not equal to b 注意： · 乘号(*)前边必须加反斜杠(\\)才能实现乘法运算； · if...then...fi是条件语句，后续将会讲解。 算术运算符列表 运算符** 说明** 举例** + 加法 expr $a + $b 结果为 30。 - 减法 expr $a - $b 结果为 10。 * 乘法 expr $a \\* $b 结果为 200。 / 除法 expr $b / $a 结果为 2。 % 取余 expr $b % $a 结果为 0。 = 赋值 a=$b 将把变量 b 的值赋给 a。 == 相等。用于比较两个数字，相同则返回 true。 [ $a == $b ] 返回 false。 != 不相等。用于比较两个数字，不相同则返回 true。 [ $a != $b ] 返回 true。 注意：条件表达式要放在方括号之间，并且要有空格，例如[$a==$b]是错误的，必须写成[ $a == $b ]。 关系运算符**关系运算符只支持数字，不支持字符串，除非字符串的值是数字。先来看一个关系运算符的例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#!/bin/sha=10b=20# 相等if [ $a -eq $b ]then echo \"$a -eq $b : a is equal to b\"else echo \"$a -eq $b: a is not equal to b\"fi# 不相等if [ $a -ne $b ]then echo \"$a -ne $b: a is not equal to b\"else echo \"$a -ne $b : a is equal to b\"fi# 大于if [ $a -gt $b ]then echo \"$a -gt $b: a is greater than b\"else echo \"$a -gt $b: a is not greater than b\"fi# 小于if [ $a -lt $b ]then echo \"$a -lt $b: a is less than b\"else echo \"$a -lt $b: a is not less than b\"fi# 大于等于if [ $a -ge $b ]then echo \"$a -ge $b: a is greater or equal to b\"else echo \"$a -ge $b: a is not greater or equal to b\"fi# 小于等于if [ $a -le $b ]then echo \"$a -le $b: a is less or equal to b\"else echo \"$a -le $b: a is not less or equal to b\"fi 运行结果： 12345610 -eq 20: a is not equal to b10 -ne 20: a is not equal to b10 -gt 20: a is not greater than b10 -lt 20: a is less than b10 -ge 20: a is not greater or equal to b10 -le 20: a is less or equal to b 关系运算符列表 运算符** 说明** 举例** -eq 检测两个数是否相等，相等返回 true。 [ $a -eq $b ]返回 true。 -ne 检测两个数是否相等，不相等返回 true。 [ $a -ne $b ]返回 true。 -gt 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ]返回 false。 -lt 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ]返回 true。 -ge 检测左边的数是否大等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。 -le 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ]返回 true。 布尔运算符**先来看一个布尔运算符的例子： 1234567891011121314151617181920212223242526272829303132#!/bin/sha=10b=20if [ $a != $b ]then echo \"$a != $b : a is not equal to b\"else echo \"$a != $b: a is equal to b\"fi# -a 与运算 andif [ $a -lt 100 -a $b -gt 15 ]then echo \"$a -lt 100 -a $b -gt 15 : returns true\"else echo \"$a -lt 100 -a $b -gt 15 : returns false\"fi# -o 或运算 orif [ $a -lt 100 -o $b -gt 100 ]then echo \"$a -lt 100 -o $b -gt 100 : returns true\"else echo \"$a -lt 100 -o $b -gt 100 : returns false\"fi# -o 或运算 orif [ $a -lt 5 -o $b -gt 100 ]then echo \"$a -lt 100 -o $b -gt 100 : returns true\"else echo \"$a -lt 100 -o $b -gt 100 : returns false\"fi 运行结果： 123410 != 20 : a is not equal to b10 -lt 100 -a 20 -gt 15 : returns true10 -lt 100 -o 20 -gt 100 : returns true10 -lt 5 -o 20 -gt 100 : returns false 布尔运算符列表 运算符** 说明** 举例** ! 非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ]返回 true。 -o 或运算，有一个表达式为 true 则返回 true。 [ $a -lt 20 -o $b -gt 100 ]返回 true。 -a 与运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 返回 false。 字符串运算符**先来看一个例子： 123456789101112131415161718192021222324252627282930313233343536373839#!/bin/sha=\"abc\"b=\"efg\"# 相等返回trueif [ $a = $b ]then echo \"$a = $b : a is equal to b\"else echo \"$a = $b: a is not equal to b\"fi# 不相等返回trueif [ $a != $b ]then echo \"$a != $b : a is not equal to b\"else echo \"$a != $b: a is equal to b\"fi# -z 长度为0返回true if [ -z $a ]then echo \"-z $a : string length is zero\"else echo \"-z $a : string length is not zero\"fi# -n 长度不为0返回true if [ -n $a ]then echo \"-n $a : string length is not zero\"else echo \"-n $a : string length is zero\"fi# 检测字符串是否为空，不为空返回 trueif [ $a ]then echo \"$a : string is not empty\"else echo \"$a : string is empty\"fi 运行结果： 12345abc = efg: a is not equal to babc != efg : a is not equal to b-z abc : string length is not zero-n abc : string length is not zeroabc : string is not empty 字符串运算符列表 运算符** 说明** 举例** = 检测两个字符串是否相等，相等返回 true。 [ $a = $b ]返回 false。 != 检测两个字符串是否相等，不相等返回 true。 [ $a != $b ]返回 true。 -z 检测字符串长度是否为0，为0返回 true。 [ -z $a ]返回 false。 -n 检测字符串长度是否为0，不为0返回 true。 [ -z $a ] 返回 true。 str 检测字符串是否为空，不为空返回 true。 [ $a ]返回 true。 文件测试运算符**文件测试运算符用于检测 Unix 文件的各种属性。例如，变量 file 表示文件“/var/www/tutorialspoint/unix/test.sh”，它的大小为100字节，具有 rwx 权限。下面的代码，将检测该文件的各种属性： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#!/bin/shfile=\"/var/www/tutorialspoint/unix/test.sh\"# 检测文件是否可读 readif [ -r $file ]then echo \"File has read access\"else echo \"File does not have read access\"fi# 检测文件是否可写 whiteif [ -w $file ]then echo \"File has write permission\"else echo \"File does not have write permission\"fi# 检测文件是否可执行if [ -x $file ]then echo \"File has execute permission\"else echo \"File does not have execute permission\"fi# 检测文件是否是普通文件（既不是目录，也不是设备文件） fileif [ -f $file ]then echo \"File is an ordinary file\"else echo \"This is sepcial file\"fi# 检测文件是否是目录 dirif [ -d $file ]then echo \"File is a directory\"else echo \"This is not a directory\"fi# 检测文件是否为空（文件大小是否大于0）spaceif [ -s $file ]then echo \"File size is zero\"else echo \"File size is not zero\"fi# 检测文件（包括目录）是否存在if [ -e $file ]then echo \"File exists\"else echo \"File does not exist\"fi 运行结果： 1234567File has read accessFile has write permissionFile has execute permissionFile is an ordinary fileThis is not a directoryFile size is zeroFile exists 文件测试运算符列表 操作符** 说明** 举例** -b file 检测文件是否是块设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。 -c file 检测文件是否是字符设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。 -d file 检测文件是否是目录，如果是，则返回 true。 [ -d $file ] 返回 false。 -f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 [ -f $file ] 返回 true。 -g file 检测文件是否设置了 SGID 位，如果是，则返回 true。 [ -g $file ] 返回 false。 -k file 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 [ -k $file ] 返回 false。 -p file 检测文件是否是具名管道，如果是，则返回 true。 [ -p $file ]返回 false。 -u file 检测文件是否设置了 SUID 位，如果是，则返回 true。 [ -u $file ] 返回 false。 -r file 检测文件是否可读，如果是，则返回 true。 [ -r $file ] 返回 true。 -w file 检测文件是否可写，如果是，则返回 true。 [ -w $file ] 返回 true。 -x file 检测文件是否可执行，如果是，则返回 true。 [ -x $file ]返回 true。 -s file 检测文件是否为空（文件大小是否大于0），不为空返回 true。 [ -s $file ]返回 true。 -e file 检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 返回 true。 Shell注释** 以“#”开头的行就是注释，会被解释器忽略。sh里没有多行注释，只能每一行加一个#号。只能像这样： 12345678910111213#--------------------------------------------# 这是一个自动打ipa的脚本，基于webfrogs的ipa-build书写：# https://github.com/webfrogs/xcode_shell/blob/master/ipa-build# 功能：自动为etao ios app打包，产出物为14个渠道的ipa包# 特色：全自动打包，不需要输入任何参数#--------------------------------------------##### 用户配置区 开始 ######## 项目根目录，推荐将此脚本放在项目的根目录，这里就不用改了# 应用名，确保和Xcode里Product下的target_name.app名字一致###### 用户配置区 结束 ##### 如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。 Shell字符串**字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似。 单引号**1str='this is a string' 单引号字符串的限制： · 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的； · 单引号字串中不能出现单引号（对单引号使用转义符后也不行）。 双引号**12your_name='qinjx'str=\"Hello, I know your are \\\"$your_name\\\"! \\n\" 双引号的优点： · 双引号里可以有变量 · 双引号里可以出现转义字符 拼接字符串**12345your_name=\"qinjx\"greeting=\"hello, \"$your_name\" !\"greeting_1=\"hello, $&#123;your_name&#125; !\"echo $greeting $greeting_1 获取字符串长度**12string=\"abcd\"echo $&#123;#string&#125; #输出 4 提取子字符串**12string=\"alibaba is a great company\"echo $&#123;string:1:4&#125; #输出liba 查找子字符串**12string=\"alibaba is a great company\"echo `expr index \"$string\" is` Shell数组：shell数组的定义、数组长度**Shell在编程方面比Windows批处理强大很多，无论是在循环、运算。bash支持一维数组（不支持多维数组），并且没有限定数组的大小。类似与C语言，数组元素的下标由0开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于0。 定义数组**在Shell中，用括号来表示数组，数组元素用“空格”符号分割开。定义数组的一般形式为： 1array_name=(value1 ... valuen) 例如： 1array_name=(value0 value1 value2 value3) 或者 123456array_name=(value0value1value2value3) 还可以单独定义数组的各个分量： 123array_name[0]=value0array_name[1]=value1array_name[2]=value2 可以不使用连续的下标，而且下标的范围没有限制。 读取数组**读取数组元素值的一般格式是： 1$&#123;array_name[index]&#125; 例如： 1valuen=$&#123;array_name[2]&#125; 举个例子： 123456789#!/bin/shNAME[0]=\"Zara\"NAME[1]=\"Qadir\"NAME[2]=\"Mahnaz\"NAME[3]=\"Ayan\"NAME[4]=\"Daisy\"echo \"First Index: $&#123;NAME[0]&#125;\"echo \"Second Index: $&#123;NAME[1]&#125;\" 运行脚本，输出： 123$./test.shFirst Index: ZaraSecond Index: Qadir 使用@ 或 * 可以获取数组中的所有元素，例如： 12$&#123;array_name[*]&#125;$&#123;array_name[@]&#125; 举个例子： 123456789#!/bin/shNAME[0]=\"Zara\"NAME[1]=\"Qadir\"NAME[2]=\"Mahnaz\"NAME[3]=\"Ayan\"NAME[4]=\"Daisy\"echo \"First Method: $&#123;NAME[*]&#125;\"echo \"Second Method: $&#123;NAME[@]&#125;\" 运行脚本，输出： 123$./test.shFirst Method: Zara Qadir Mahnaz Ayan DaisySecond Method: Zara Qadir Mahnaz Ayan Daisy 获取数组的长度**获取数组长度的方法与获取字符串长度的方法相同，例如： 123456# 取得数组元素的个数length=$&#123;#array_name[@]&#125;# 或者length=$&#123;#array_name[*]&#125;# 取得数组单个元素的长度lengthn=$&#123;#array_name[n]&#125; Shell echo命令**echo是Shell的一个内部指令，用于在屏幕上打印出指定的字符串。命令格式： 1echo arg 您可以使用echo实现更复杂的输出格式控制。 显示转义字符**1echo \"\\\"It is a test\\\"\" 结果将是： 1\"It is a test\" 双引号也可以省略。 显示变量**12name=\"OK\"echo \"$name It is a test\" 结果将是： 1OK It is a test 同样双引号也可以省略。如果变量与其它字符相连的话，需要使用大括号（{ }）： 12mouth=8echo \"$&#123;mouth&#125;-1-2009\" 结果将是： 18-1-2009 显示换行**12echo \"OK!\\n\"echo \"It is a test\" 输出： 12OK!It is a test 显示不换行**12echo \"OK!\\c\"echo \"It is a test\" 输出： 1OK!It si a test 显示结果重定向至文件**1echo \"It is a test\" &gt; myfile 原样输出字符串**若需要原样输出字符串（不进行转义），请使用单引号。例如： 1echo '$name\\\"' 显示命令执行结果**1echo `date` 结果将显示当前日期 从上面可看出，双引号可有可无，单引号主要用在原样输出中。 shell printf命令：格式化输出语句**printf 命令用于格式化输出， 是echo命令的增强版。它是C语言printf()库函数的一个有限的变形，并且在语法上有些不同。注意：printf 由 POSIX 标准所定义，移植性要比 echo 好。如同 echo 命令，printf命令也可以输出简单的字符串： 123$printf \"Hello, Shell\\n\"Hello, Shell$ printf 不像echo 那样会自动换行，必须显式添加换行符(\\n)。printf命令的语法： 1printf format-string [arguments...] format-string为格式控制字符串，arguments为参数列表。printf()在C语言入门教程中已经讲到，功能和用法与 printf 命令类似，请查看：C语言格式输出函数printf()详解这里仅说明与C语言printf()函数的不同： · printf 命令不用加括号 · format-string 可以没有引号，但最好加上，单引号双引号均可。 · 参数多于格式控制符(%)时，format-string 可以重用，可以将所有参数都转换。 · arguments 使用空格分隔，不用逗号。 请看下面的例子： 12345678910111213141516171819202122232425262728# format-string为双引号$ printf \"%d %s\\n\" 1 \"abc\"1 abc# 单引号与双引号效果一样 $ printf '%d %s\\n' 1 \"abc\" 1 abc# 没有引号也可以输出$ printf %s abcdefabcdef# 格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用$ printf %s abc defabcdef$ printf \"%s\\n\" abc defabcdef$ printf \"%s %s %s\\n\" a b c d e f g h i ja b cd e fg h ij# 如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替$ printf \"%s and %d \\n\" and 0# 如果以 %d 的格式来显示字符串，那么会有警告，提示无效的数字，此时默认置为 0$ printf \"The first program always prints'%s,%d\\n'\" Hello Shell-bash: printf: Shell: invalid numberThe first program always prints 'Hello,0'$ 注意，根据POSIX标准，浮点格式%e、%E、%f、%g与%G是“不需要被支持”。这是因为awk支持浮点预算，且有它自己的printf语句。这样Shell程序中需要将浮点数值进行格式化的打印时，可使用小型的awk程序实现。然而，内建于bash、ksh93和zsh中的printf命令都支持浮点格式。 Shell if else语句**if语句通过关系运算符判断表达式的真假来决定执行哪个分支。Shell 有三种if … else 语句： · if … fi 语句； · if … else … fi 语句； · if … elif … else … fi 语句。 1) if … else 语句**if … else 语句的语法： 1234if [ expression ]then Statement(s) to be executed if expression is truefi 如果 expression 返回 true，then后边的语句将会被执行；如果返回 false，不会执行任何语句。最后必须以 fi 来结尾闭合 if，fi 就是 if 倒过来拼写，后面也会遇见。注意：expression 和方括号([ ])之间必须有空格，否则会有语法错误。举个例子： 1234567891011121314#!/bin/sha=10b=20if [ $a == $b ]then echo \"a is equal to b\"fiif [ $a != $b ]then echo \"a is not equal to b\"fi 运行结果： 1a is not equal to b 2) if … else … fi 语句**if … else … fi 语句的语法： 123456if [ expression ]then Statement(s) to be executed if expression is trueelse Statement(s) to be executed if expression is not truefi 如果 expression 返回 true，那么 then 后边的语句将会被执行；否则，执行 else 后边的语句。举个例子： 1234567891011#!/bin/sha=10b=20if [ $a == $b ]then echo \"a is equal to b\"else echo \"a is not equal to b\"fi 执行结果： 1a is not equal to b 3) if … elif … fi 语句**if … elif … fi 语句可以对多个条件进行判断，语法为： 123456789101112if [ expression 1 ]then Statement(s) to be executed if expression 1 is trueelif [ expression 2 ]then Statement(s) to be executed if expression 2 is trueelif [ expression 3 ]then Statement(s) to be executed if expression 3 is trueelse Statement(s) to be executed if no expression is truefi 哪一个 expression 的值为 true，就执行哪个 expression 后面的语句；如果都为 false，那么不执行任何语句。举个例子： 1234567891011121314151617#!/bin/sha=10b=20if [ $a == $b ]then echo \"a is equal to b\"elif [ $a -gt $b ]then echo \"a is greater than b\"elif [ $a -lt $b ]then echo \"a is less than b\"else echo \"None of the condition met\"fi 运行结果： 1a is less than b if … else 语句也可以写成一行，以命令的方式来运行，像这样： 1if test $[2*3] -eq $[1+5]; then echo 'The two numbers are equal!'; fi; if … else 语句也经常与 test 命令结合使用，如下所示： 12345678num1=$[2*3]num2=$[1+5]if test $[num1] -eq $[num2]then echo 'The two numbers are equal!'else echo 'The two numbers are not equal!'fi 输出： 1The two numbers are equal! test 命令用于检查某个条件是否成立，与方括号([ ])类似。 Shell test命令**Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。 数值测试** 参数** 说明** -eq 等于则为真 -ne 不等于则为真 -gt 大于则为真 -ge 大于等于则为真 -lt 小于则为真 -le 小于等于则为真 例如： 12345678num1=100num2=100if test $[num1] -eq $[num2]then echo 'The two numbers are equal!'else echo 'The two numbers are not equal!'fi 输出：1The two numbers are equal! 字符串测试** 参数** 说明** = 等于则为真 != 不相等则为真 -z 字符串 字符串长度为0则为真 -n 字符串 字符串长度不为0则为真 例如： 12345678num1=100num2=100if test num1=num2then echo 'The two strings are equal!'else echo 'The two strings are not equal!'fi 输出：1The two strings are equal! 文件测试** 参数** 说明** -e 文件名 如果文件存在则为真 -r 文件名 如果文件存在且可读则为真 -w 文件名 如果文件存在且可写则为真 -x 文件名 如果文件存在且可执行则为真 -s 文件名 如果文件存在且至少有一个字符则为真 -d 文件名 如果文件存在且为目录则为真 -f 文件名 如果文件存在且为普通文件则为真 -c 文件名 如果文件存在且为字符型特殊文件则为真 -b 文件名 如果文件存在且为块特殊文件则为真 例如： 1234567cd /binif test -e ./bashthen echo 'The file already exists!'else echo 'The file does not exists!'fi 输出：1The file already exists! 另外，Shell还提供了与(-a )、或( -o )、非( ! )三个逻辑操作符用于将测试条件连接起来，其优先级为：“!”最高，“-a”次之，“-o”最低。例如： 1234567cd /binif test -e ./notFile -o ./bashthen echo 'One file exists at least!'else echo 'Both dose not exists!'fi 输出：1One file exists at least! Shell case esac语句**case … esac 与其他语言中的 switch … case 语句类似，是一种多分枝选择结构。case 语句匹配一个值或一个模式，如果匹配成功，执行相匹配的命令。case语句格式如下： 1234567891011121314151617case 值 in模式1) command1 command2 command3 ;;模式2） command1 command2 command3 ;;*) command1 command2 command3 ;;esac case工作方式如上所示。取值后面必须为关键字 in，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。;; 与其他语言中的 break 类似，意思是跳到整个 case 语句的最后。取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。下面的脚本提示输入1到4，与每一种模式进行匹配： 123456789101112131415echo 'Input a number between 1 to 4'echo 'Your number is:\\c'read aNumcase $aNum in 1) echo 'You select 1' ;; 2) echo 'You select 2' ;; 3) echo 'You select 3' ;; 4) echo 'You select 4' ;; *) echo 'You do not select a number between 1 to 4' ;;esac 输入不同的内容，会有不同的结果，例如： 123Input a number between 1 to 4Your number is:3You select 3 再举一个例子： 123456789101112131415#!/bin/bashoption=\"$&#123;1&#125;\"case $&#123;option&#125; in -f) FILE=\"$&#123;2&#125;\" echo \"File name is $FILE\" ;; -d) DIR=\"$&#123;2&#125;\" echo \"Dir name is $DIR\" ;; *) echo \"`basename $&#123;0&#125;`:usage: [-f file] | [-d directory]\" exit 1 # Command to come out of the program with status 1 ;;esac 运行结果： 123456789$./test.shtest.sh: usage: [ -f filename ] | [ -d directory ]$ ./test.sh -f index.htm$ vi test.sh$ ./test.sh -f index.htmFile name is index.htm$ ./test.sh -d unixDir name is unix$ Shell for循环**与其他编程语言类似，Shell支持for循环。for循环一般格式为： 1234567for 变量 in 列表do command1 command2 ... commandNdone 列表是一组值（数字、字符串等）组成的序列，每个值通过空格分隔。每循环一次，就将列表中的下一个值赋给变量。in 列表是可选的，如果不用它，for 循环使用命令行的位置参数。例如，顺序输出当前列表中的数字： 1234for loop in 1 2 3 4 5do echo \"The value is: $loop\"done 运行结果： 12345The value is: 1The value is: 2The value is: 3The value is: 4The value is: 5 顺序输出字符串中的字符： 1234for str in 'This is a string'do echo $strdone 运行结果： 1This is a string 显示主目录下以 .bash 开头的文件： 123456#!/bin/bashfor FILE in $HOME/.bash*do echo $FILEdone 运行结果： 1234/root/.bash_history/root/.bash_logout/root/.bash_profile/root/.bashrc Shell while循环**while循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。其格式为： 1234while commanddo Statement(s) to be executed if command is truedone 命令执行完毕，控制返回循环顶部，从头开始直至测试条件为假。以下是一个基本的while循环，测试条件是：如果COUNTER小于5，那么返回 true。COUNTER从0开始，每次循环处理时，COUNTER加1。运行上述脚本，返回数字1到5，然后终止。 123456COUNTER=0while [ $COUNTER -lt 5 ]do COUNTER='expr $COUNTER+1' echo $COUNTERdone 运行脚本，输出： 1234512345 while循环可用于读取键盘信息。下面的例子中，输入信息被设置为变量FILM，按Ctrl-D结束循环。 123456echo 'type &lt;CTRL-D&gt; to terminate'echo -n 'enter your most liked film: 'while read FILMdo echo \"Yeah! great film the $FILM\"done 运行脚本，输出类似下面： 123type &lt;CTRL-D&gt; to terminateenter your most liked film: Sound of MusicYeah! great film the Sound of Music Shell until循环**until 循环执行一系列命令直至条件为 true 时停止。until 循环与 while 循环在处理方式上刚好相反。一般while循环优于until循环，但在某些时候，也只是极少数情况下，until 循环更加有用。until 循环格式为： 1234until commanddo Statement(s) to be executed until command is truedone command 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。例如，使用 until 命令输出 0 ~ 9 的数字： 123456789#!/bin/basha=0until [ ! $a -lt 10 ]do echo $a a=`expr $a + 1`done 运行结果： 123456789100123456789 Shell break和continue命令**在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，像大多数编程语言一样，Shell也使用 break 和 continue 来跳出循环。 break命令**break命令允许跳出所有循环（终止执行后面的所有循环）。下面的例子中，脚本进入死循环直至用户输入数字大于5。要跳出这个循环，返回到shell提示符下，就要使用break命令。 1234567891011121314#!/bin/bashwhile :do echo -n \"Input a number between 1 to 5: \" read aNum case $aNum in 1|2|3|4|5) echo \"Your number is $aNum!\" ;; *) echo \"You do not select a number between 1 to 5, game is over!\" break ;; esacdone 在嵌套循环中，break 命令后面还可以跟一个整数，表示跳出第几层循环。例如： 1break n 表示跳出第 n 层循环。下面是一个嵌套循环的例子，如果 var1 等于 2，并且 var2 等于 0，就跳出循环： 1234567891011121314#!/bin/bashfor var1 in 1 2 3do for var2 in 0 5 do if [ $var1 -eq 2 -a $var2 -eq 0 ] then break 2 else echo \"$var1 $var2\" fi donedone 如上，break 2 表示直接跳出外层循环。运行结果： 121 01 5 continue命令**continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。对上面的例子进行修改： 1234567891011121314#!/bin/bashwhile :do echo -n \"Input a number between 1 to 5: \" read aNum case $aNum in 1|2|3|4|5) echo \"Your number is $aNum!\" ;; *) echo \"You do not select a number between 1 to 5!\" continue echo \"Game is over!\" ;; esacdone 运行代码发现，当输入大于5的数字时，该例中的循环不会结束，语句 1echo \"Game is over!\" 永远不会被执行。同样，continue 后面也可以跟一个数字，表示跳出第几层循环。再看一个 continue 的例子： 1234567891011121314#!/bin/bashNUMS=\"1 2 3 4 5 6 7\"for NUM in $NUMSdo Q=`expr $NUM % 2` if [ $Q -eq 0 ] then echo \"Number is an even number!!\" continue fi echo \"Found odd number\"done 运行结果： 1234567Found odd numberNumber is an even number!!Found odd numberNumber is an even number!!Found odd numberNumber is an even number!!Found odd number Shell函数：Shell函数返回值、删除函数、在终端调用函数**函数可以让我们将一个复杂功能划分成若干模块，让程序结构更加清晰，代码重复利用率更高。像其他编程语言一样，Shell 也支持函数。Shell 函数必须先定义后使用。Shell 函数的定义格式如下：1234function_name () &#123; list of commands [ return value ]&#125; 如果你愿意，也可以在函数名前加上关键字 function： 1234function function_name () &#123; list of commands [ return value ]&#125; 函数返回值，可以显式增加return语句；如果不加，会将最后一条命令运行结果作为返回值。Shell 函数返回值只能是整数，一般用来表示函数执行成功与否，0表示成功，其他值表示失败。如果 return 其他数据，比如一个字符串，往往会得到错误提示：“numeric argument required”。如果一定要让函数返回字符串，那么可以先定义一个变量，用来接收函数的计算结果，脚本在需要的时候访问这个变量来获得函数返回值。先来看一个例子： 123456789#!/bin/bash# Define your function hereHello () &#123; echo \"Url is http://see.xidian.edu.cn/cpp/shell/\"&#125;# Invoke your functionHello 运行结果：?? 123$./test.shHello World$ 调用函数只需要给出函数名，不需要加括号。再来看一个带有return语句的函数： 123456789101112131415#!/bin/bashfunWithReturn()&#123; echo \"The function is to get the sum of two numbers...\" echo -n \"Input first number: \" read aNum echo -n \"Input another number: \" read anotherNum echo \"The two numbers are $aNum and $anotherNum !\" return $(($aNum+$anotherNum))&#125;funWithReturn# Capture value returnd by last commandret=$?echo \"The sum of two numbers is $ret !\" 运行结果： 12345The function is to get the sum of two numbers...Input first number: 25Input another number: 50The two numbers are 25 and 50 !The sum of two numbers is 75 ! 函数返回值在调用该函数后通过 $?来获得。再来看一个函数嵌套的例子： 12345678910111213#!/bin/bash# Calling one function from anothernumber_one () &#123; echo \"Url_1 is http://see.xidian.edu.cn/cpp/shell/\" number_two&#125;number_two () &#123; echo \"Url_2 is http://see.xidian.edu.cn/cpp/u/xitong/\"&#125;number_one 运行结果： 12Url_1 is http://see.xidian.edu.cn/cpp/shell/Url_2 is http://see.xidian.edu.cn/cpp/u/xitong/ 像删除变量一样，删除函数也可以使用 unset 命令，不过要加上.f选项，如下所示： 1$unset .f function_name 如果你希望直接从终端调用函数，可以将函数定义在主目录下的 .profile 文件，这样每次登录后，在命令提示符后面输入函数名字就可以立即调用。 Shell函数参数**在Shell中，调用函数时可以向其传递参数。在函数体内部，通过$n的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数…带参数的函数示例： 123456789101112#!/bin/bashfunWithParam()&#123; echo \"The value of the first parameter is $1 !\" echo \"The value of the second parameter is $2 !\" echo \"The value of the tenth parameter is $10 !\" echo \"The value of the tenth parameter is $&#123;10&#125; !\" echo \"The value of the eleventh parameter is $&#123;11&#125; !\" echo \"The amount of the parameters is $# !\" # 参数个数 echo \"The string of the parameters is $* !\" # 传递给函数的所有参数&#125;funWithParam 1 2 3 4 5 6 7 8 9 34 73 运行脚本： 1234567The value of the first parameter is 1 !The value of the second parameter is 2 !The value of the tenth parameter is 10 !The value of the tenth parameter is 34 !The value of the eleventh parameter is 73 !The amount of the parameters is 12 !The string of the parameters is 1 2 3 4 5 6 7 8 9 34 73 !\" 注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n&gt;=10时，需要使用${n}来获取参数。另外，还有几个特殊变量用来处理参数，前面已经提到： 特殊变量** 说明** $# 传递给函数的参数个数。 $* 显示所有传递给函数的参数。 $@ 与$*相同，但是略有区别，请查看Shell特殊变量。 $? 函数的返回值。 Shell输入输出重定向：Shell Here Document，/dev/null文件**Unix 命令默认从标准输入设备(stdin)获取输入，将结果输出到标准输出设备(stdout)显示。一般情况下，标准输入设备就是键盘，标准输出设备就是终端，即显示器。 输出重定向**命令的输出不仅可以是显示器，还可以很容易的转移向到文件，这被称为输出重定向。命令输出重定向的语法为： 1$ command &gt; file 这样，输出到显示器的内容就可以被重定向到文件。例如，下面的命令在显示器上不会看到任何输出： 1$ who &gt; users 打开 users 文件，可以看到下面的内容： 1234567$ cat usersoko tty01 Sep 12 07:30ai tty15 Sep 12 13:32ruth tty21 Sep 12 10:10pat tty24 Sep 12 13:07steve tty25 Sep 12 13:03$ 输出重定向会覆盖文件内容，请看下面的例子： 1234$ echo line 1 &gt; users$ cat usersline 1$ 如果不希望文件内容被覆盖，可以使用 &gt;&gt; 追加到文件末尾，例如： 12345$ echo line 2 &gt;&gt; users$ cat usersline 1line 2$ 输入重定向**和输出重定向一样，Unix 命令也可以从文件获取输入，语法为： 1command &lt; file 这样，本来需要从键盘获取输入的命令会转移到文件读取内容。注意：输出重定向是大于号(&gt;)，输入重定向是小于号(&lt;)。例如，计算 users 文件中的行数，可以使用下面的命令： 123$ wc -l users2 users$ 也可以将输入重定向到 users 文件： 123$ wc -l &lt; users2$ 注意：上面两个例子的结果不同：第一个例子，会输出文件名；第二个不会，因为它仅仅知道从标准输入读取内容。 重定向深入讲解**一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件： · 标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。 · 标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。 · 标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。 默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。如果希望 stderr 重定向到 file，可以这样写： 1$command 2 &gt; file 如果希望 stderr 追加到 file 文件末尾，可以这样写： 1$command 2 &gt;&gt; file 2 表示标准错误文件(stderr)。如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写： 1$command &gt; file 2&gt;&amp;1 或 1$command &gt;&gt; file 2&gt;&amp;1 如果希望对 stdin 和 stdout 都重定向，可以这样写： 1$command &lt; file1 &gt;file2 command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。 全部可用的重定向命令列表 命令** 说明** command &gt; file 将输出重定向到 file。 command &lt; file 将输入重定向到 file。 command &gt;&gt; file 将输出以追加的方式重定向到 file。 n &gt; file 将文件描述符为 n 的文件重定向到 file。 n &gt;&gt; file 将文件描述符为 n 的文件以追加的方式重定向到 file。 n &gt;&amp; m 将输出文件 m 和 n 合并。 n &lt;&amp; m 将输入文件 m 和 n 合并。 &lt;&lt; tag 将开始标记 tag 和结束标记 tag 之间的内容作为输入。 Here Document**Here Document 目前没有统一的翻译，这里暂译为”嵌入文档“。Here Document 是 Shell 中的一种特殊的重定向方式，它的基本的形式如下： 123command &lt;&lt; delimiter documentdelimiter 它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。注意： · 结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。 · 开始的delimiter前后的空格会被忽略掉。 下面的例子，通过 wc -l 命令计算 document 的行数： 1234567$wc -l &lt;&lt; EOF This is a simple lookup program for good (and bad) restaurants in Cape Town.EOF3$ 也可以 将 Here Document 用在脚本中，例如： 1234567#!/bin/bashcat &lt;&lt; EOFThis is a simple lookup programfor good (and bad) restaurantsin Cape Town.EOF 运行结果： 123This is a simple lookup programfor good (and bad) restaurantsin Cape Town. 下面的脚本通过 vi 编辑器将 document 保存到 test.txt 文件： 12345678910#!/bin/shfilename=test.txtvi $filename &lt;&lt;EndOfCommandsiThis file was created automatically froma shell script^[ZZEndOfCommands 运行脚本： 123$ sh test.shVim: Warning: Input is not from a terminal$ 打开 test.txt，可以看到下面的内容： 1234$ cat test.txtThis file was created automatically froma shell script$ /dev/null 文件**如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null： 1$ command &gt; /dev/null /dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到”禁止输出“的效果。如果希望屏蔽 stdout 和 stderr，可以这样写：1$ command &gt; /dev/null 2&gt;&amp;1 Shell文件包含**像其他语言一样，Shell 也可以包含外部脚本，将外部脚本的内容合并到当前脚本。Shell 中包含脚本可以使用： 1. filename 或1source filename 两种方式的效果相同，简单起见，一般使用点号(.)，但是注意点号(.)和文件名中间有一空格。例如，创建两个脚本，一个是被调用脚本 subscript.sh，内容如下： 1url=\"http://see.xidian.edu.cn/cpp/view/2738.html\" 一个是主文件 main.sh，内容如下： 123#!/bin/bash. ./subscript.shecho $url 执行脚本： 1234$chomd +x main.sh./main.shhttp://see.xidian.edu.cn/cpp/view/2738.html$ 注意：被包含脚本不需要有执行权限。","categories":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/categories/shell/"}],"tags":[]},{"title":"webpack3.0 配置","slug":"webpack-setting","date":"2017-06-25T16:00:00.000Z","updated":"2017-06-26T07:10:49.135Z","comments":true,"path":"2017/06/26/webpack-setting/","link":"","permalink":"http://yoursite.com/2017/06/26/webpack-setting/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372const path = require('path');module.exports = &#123; entry: \"./app/entry\", // string | object | array entry: [\"./app/entry1\", \"./app/entry2\"], entry: &#123; a: \"./app/entry-a\", b: [\"./app/entry-b1\", \"./app/entry-b2\"] &#125;, // 这里应用程序开始执行 // webpack 开始打包 output: &#123; // webpack 如何输出结果的相关选项 path: path.resolve(__dirname, \"dist\"), // string // 所有输出文件的目标路径 // 必须是绝对路径（使用 Node.js 的 path 模块） filename: \"bundle.js\", // string filename: \"[name].js\", // 用于多个入口点(entry point)（出口点？） filename: \"[chunkhash].js\", // 用于长效缓存 // 「入口分块(entry chunk)」的文件名模板（出口分块？） publicPath: \"/assets/\", // string publicPath: \"\", publicPath: \"https://cdn.example.com/\", // 输出解析文件的目录，url 相对于 HTML 页面 library: \"MyLibrary\", // string, // 导出库(exported library)的名称 libraryTarget: \"umd\", // 通用模块定义 libraryTarget: \"umd2\", // 通用模块定义 libraryTarget: \"commonjs2\", // exported with module.exports libraryTarget: \"commonjs-module\", // 使用 module.exports 导出 libraryTarget: \"commonjs\", // 作为 exports 的属性导出 libraryTarget: \"amd\", // 使用 AMD 定义方法来定义 libraryTarget: \"this\", // 在 this 上设置属性 libraryTarget: \"var\", // 变量定义于根作用域下 libraryTarget: \"assign\", // 盲分配(blind assignment) libraryTarget: \"window\", // 在 window 对象上设置属性 libraryTarget: \"global\", // property set to global object libraryTarget: \"jsonp\", // jsonp wrapper // 导出库(exported library)的类型 /* 高级输出配置（点击显示） */ pathinfo: true, // boolean // 在生成代码时，引入相关的模块、导出、请求等有帮助的路径信息。 chunkFilename: \"[id].js\", chunkFilename: \"[chunkhash].js\", // 长效缓存(/guides/caching) // 「附加分块(additional chunk)」的文件名模板 jsonpFunction: \"myWebpackJsonp\", // string // 用于加载分块的 JSONP 函数名 sourceMapFilename: \"[file].map\", // string sourceMapFilename: \"sourcemaps/[file].map\", // string // 「source map 位置」的文件名模板 devtoolModuleFilenameTemplate: \"webpack:///[resource-path]\", // string // 「devtool 中模块」的文件名模板 devtoolFallbackModuleFilenameTemplate: \"webpack:///[resource-path]?[hash]\", // string // 「devtool 中模块」的文件名模板（用于冲突） umdNamedDefine: true, // boolean // 在 UMD 库中使用命名的 AMD 模块 crossOriginLoading: \"use-credentials\", // 枚举 crossOriginLoading: \"anonymous\", crossOriginLoading: false, // 指定运行时如何发出跨域请求问题 /* 专家级输出配置（自行承担风险） */ &#125;, module: &#123; // 关于模块配置 rules: [ // 模块规则（配置 loader、解析器等选项） &#123; test: /\\.jsx?$/, include: [ path.resolve(__dirname, \"app\") ], exclude: [ path.resolve(__dirname, \"app/demo-files\") ], // 这里是匹配条件，每个选项都接收一个正则表达式或字符串 // test 和 include 具有相同的作用，都是必须匹配选项 // exclude 是必不匹配选项（优先于 test 和 include） // 最佳实践： // - 只在 test 和 文件名匹配 中使用正则表达式 // - 在 include 和 exclude 中使用绝对路径数组 // - 尽量避免 exclude，更倾向于使用 include issuer: &#123; test, include, exclude &#125;, // issuer 条件（导入源） enforce: \"pre\", enforce: \"post\", // 标识应用这些规则，即使规则覆盖（高级选项） loader: \"babel-loader\", // 应该应用的 loader，它相对上下文解析 // 为了更清晰，`-loader` 后缀在 webpack 2 中不再是可选的 // 查看 webpack 1 升级指南。 options: &#123; presets: [\"es2015\"] &#125;, // loader 的可选项 &#125;, &#123; test: \"\\.html$\" use: [ // 应用多个 loader 和选项 \"htmllint-loader\", &#123; loader: \"html-loader\", options: &#123; /* ... */ &#125; &#125; ] &#125;, &#123; oneOf: [ /* rules */ ] &#125;, // 只使用这些嵌套规则之一 &#123; rules: [ /* rules */ ] &#125;, // 使用所有这些嵌套规则（合并可用条件） &#123; resource: &#123; and: [ /* 条件 */ ] &#125; &#125;, // 仅当所有条件都匹配时才匹配 &#123; resource: &#123; or: [ /* 条件 */ ] &#125; &#125;, &#123; resource: [ /* 条件 */ ] &#125;, // 任意条件匹配时匹配（默认为数组） &#123; resource: &#123; not: /* 条件 */ &#125; &#125; // 条件不匹配时匹配 ], /* 高级模块配置（点击展示） */ noParse: [ /special-library\\.js$/ ], // 不解析这里的模块 unknownContextRequest: \".\", unknownContextRecursive: true, unknownContextRegExp: /^\\.\\/.*$/, unknownContextCritical: true, exprContextRequest: \".\", exprContextRegExp: /^\\.\\/.*$/, exprContextRecursive: true, exprContextCritical: true, wrappedContextRegExp: /.*/, wrappedContextRecursive: true, wrappedContextCritical: false, // specifies default behavior for dynamic requests &#125;, resolve: &#123; // 解析模块请求的选项 // （不适用于对 loader 解析） modules: [ \"node_modules\", path.resolve(__dirname, \"app\") ], // 用于查找模块的目录 extensions: [\".js\", \".json\", \".jsx\", \".css\"], // 使用的扩展名 alias: &#123; // 模块别名列表 \"module\": \"new-module\", // 起别名：\"module\" -&gt; \"new-module\" 和 \"module/path/file\" -&gt; \"new-module/path/file\" \"only-module$\": \"new-module\", // 起别名 \"only-module\" -&gt; \"new-module\"，但不匹配 \"module/path/file\" -&gt; \"new-module/path/file\" \"module\": path.resolve(__dirname, \"app/third/module.js\"), // 起别名 \"module\" -&gt; \"./app/third/module.js\" 和 \"module/file\" 会导致错误 // 模块别名相对于当前上下文导入 &#125;, /* 可供选择的别名语法（点击展示） */ alias: [ &#123; name: \"module\", // 旧的请求 alias: \"new-module\", // 新的请求 onlyModule: true // 如果为 true，只有 \"module\" 是别名 // 如果为 false，\"module/inner/path\" 也是别名 &#125; ], /* 高级解析选项（点击展示） */ symlinks: true, // 遵循符号链接(symlinks)到新位置 descriptionFiles: [\"package.json\"], // 从 package 描述中读取的文件 mainFields: [\"main\"], // 从描述文件中读取的属性 // 当请求文件夹时 aliasFields: [\"browser\"], // 从描述文件中读取的属性 // 以对此 package 的请求起别名 enforceExtension: false, // 如果为 true，请求必不包括扩展名 // 如果为 false，请求可以包括扩展名 moduleExtensions: [\"-module\"], enforceModuleExtension: false, // 类似 extensions/enforceExtension，但是用模块名替换文件 unsafeCache: true, unsafeCache: &#123;&#125;, // 为解析的请求启用缓存 // 这是不安全，因为文件夹结构可能会改动 // 但是性能改善是很大的 cachePredicate: (path, request) =&gt; true, // predicate function which selects requests for caching plugins: [ // ... ] // 应用于解析器的附加插件 &#125;, performance: &#123; hints: \"warning\", // 枚举 hints: \"error\", // 性能提示中抛出错误 hints: false, // 关闭性能提示 maxAssetSize: 200000, // 整数类型（以字节为单位） maxEntrypointSize: 400000, // 整数类型（以字节为单位） assetFilter: function(assetFilename) &#123; // 提供资源文件名的断言函数 return assetFilename.endsWith('.css') || assetFilename.endsWith('.js'); &#125; &#125;, devtool: \"source-map\", // enum devtool: \"inline-source-map\", // 嵌入到源文件中 devtool: \"eval-source-map\", // 将 SourceMap 嵌入到每个模块中 devtool: \"hidden-source-map\", // SourceMap 不在源文件中引用 devtool: \"cheap-source-map\", // 没有模块映射(module mappings)的 SourceMap 低级变体(cheap-variant) devtool: \"cheap-module-source-map\", // 有模块映射(module mappings)的 SourceMap 低级变体 devtool: \"eval\", // 没有模块映射，而是命名模块。以牺牲细节达到最快。 // 通过在浏览器调试工具(browser devtools)中添加元信息(meta info)增强调试 // 牺牲了构建速度的 `source-map' 是最详细的。 context: __dirname, // string（绝对路径！） // webpack 的主目录 // entry 和 module.rules.loader 选项 // 相对于此目录解析 target: \"web\", // 枚举 target: \"webworker\", // WebWorker target: \"node\", // node.js 通过 require target: \"async-node\", // Node.js 通过 fs and vm target: \"node-webkit\", // nw.js target: \"electron-main\", // electron，主进程(main process) target: \"electron-renderer\", // electron，渲染进程(renderer process) target: (compiler) =&gt; &#123; /* ... */ &#125;, // 自定义 // 包(bundle)应该运行的环境 // 更改 块加载行为(chunk loading behavior) 和 可用模块(available module) externals: [\"react\", /^@angular\\//], externals: \"react\", // string（精确匹配） externals: /^[a-z\\-]+($|\\/)/, // 正则 externals: &#123; // 对象 angular: \"this angular\", // this[\"angular\"] react: &#123; // UMD commonjs: \"react\", commonjs2: \"react\", amd: \"react\", root: \"React\" &#125; &#125;, externals: (request) =&gt; &#123; /* ... */ return \"commonjs \" + request &#125; // 不要遵循/打包这些模块，而是在运行时从环境中请求他们 stats: \"errors-only\", stats: &#123; //object assets: true, colors: true, errors: true, errorDetails: true, hash: true, // ... &#125;, // 精确控制要显示的 bundle 信息 devServer: &#123; proxy: &#123; // proxy URLs to backend development server '/api': 'http://localhost:3000' &#125;, contentBase: path.join(__dirname, 'public'), // boolean | string | array, static file location compress: true, // enable gzip compression historyApiFallback: true, // true for index.html upon 404, object for multiple paths hot: true, // hot module replacement. Depends on HotModuleReplacementPlugin https: false, // true for self-signed, object for cert authority noInfo: true, // only errors &amp; warns on hot reload // ... &#125;, plugins: [ // ... ], // 附加插件列表 /* 高级配置（点击展示） */ resolveLoader: &#123; /* 等同于 resolve */ &#125; // 独立解析选项的 loader profile: true, // boolean // 捕获时机信息 bail: true, //boolean // 在第一个错误出错时抛出，而不是无视错误。 cache: false, // boolean // 禁用/启用缓存 watch: true, // boolean // 启用观察 watchOptions: &#123; aggregateTimeout: 1000, // in ms // 将多个更改聚合到单个重构建(rebuild) poll: true, poll: 500, // 间隔单位 ms // 启用轮询观察模式 // 必须用在不通知更改的文件系统中 // 即 nfs shares（译者注：Network FileSystem，最大的功能就是可以透過網路，讓不同的機器、不同的作業系統、可以彼此分享個別的檔案 ( share file )） &#125;, node: &#123; /* TODO */ &#125;, recordsPath: path.resolve(__dirname, \"build/records.json\"), recordsInputPath: path.resolve(__dirname, \"build/records.json\"), recordsOutputPath: path.resolve(__dirname, \"build/records.json\"), // TODO&#125;","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"ES6中的模块介绍","slug":"es6-model","date":"2017-05-17T07:44:45.000Z","updated":"2017-05-19T09:38:39.257Z","comments":true,"path":"2017/05/17/es6-model/","link":"","permalink":"http://yoursite.com/2017/05/17/es6-model/","excerpt":"","text":"ES6在语言规格的层面上，实现了模块功能，而且实现得相当简单，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。 ES6模块主要有两个功能：export和import export用于对外输出本模块（一个文件可以理解为一个模块）变量的接口 import用于在一个模块中加载另一个含有export接口的模块。 以对象属性形式的export和import1234567//export.jslet var1=1;let var2=2;function method1()&#123;&#125;let method2=function()&#123;&#125;export &#123;var1,var2,method1,method2&#125; 12345//export.jsexport let var1=1;export let var2=2;export function method1()&#123;&#125;export let method2=function()&#123;&#125; 123456789//import.jsimport&#123;var1,var2,method1,method2&#125; from \"./export.js\"import * as myVar from \"./export.js\"console.log(var1,var2,method1,method2,myVar)//1//2 //method1() &#123;&#125; //method2() &#123;&#125; //Object &#123;var1: 1, var2: 2, method1:method1(),method2:method2(),default: \"aaaa\",__esModule: true&#125; 以模板形式的export和import123456//export.jsexport default let x=1;1212//import.jsimport x from \"./export.js\";console.log(x) //输出的是x 可以发现，通过export模板的话，输出的格式不是以对象的形式{x}，而是直接的x。","categories":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/categories/es6/"}],"tags":[]},{"title":"路由的配置项","slug":"react-router","date":"2017-05-17T07:35:12.000Z","updated":"2017-05-19T08:40:22.009Z","comments":true,"path":"2017/05/17/react-router/","link":"","permalink":"http://yoursite.com/2017/05/17/react-router/","excerpt":"","text":"路由的基本使用方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import React from 'react'import &#123; render &#125; from 'react-dom'import &#123; Router, Route, Link &#125; from 'react-router'const App = React.createClass(&#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;App&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=\"/about\"&gt;About&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/inbox\"&gt;Inbox&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &#123;this.props.children&#125; &lt;/div&gt; ) &#125;&#125;)const About = React.createClass(&#123; render() &#123; return &lt;h3&gt;About&lt;/h3&gt; &#125;&#125;)const Inbox = React.createClass(&#123; render() &#123; return ( &lt;div&gt; &lt;h2&gt;Inbox&lt;/h2&gt; &#123;this.props.children || \"Welcome to your Inbox\"&#125; &lt;/div&gt; ) &#125;&#125;)const Message = React.createClass(&#123; render() &#123; return &lt;h3&gt;Message &#123;this.props.params.id&#125;&lt;/h3&gt; &#125;&#125;)render(( &lt;Router&gt; &lt;Route path=\"/\" component=&#123;App&#125;&gt; &lt;Route path=\"about\" component=&#123;About&#125; /&gt; &lt;Route path=\"inbox\" component=&#123;Inbox&#125;&gt; &lt;Route path=\"messages/:id\" component=&#123;Message&#125; /&gt; &lt;/Route&gt; &lt;/Route&gt; &lt;/Router&gt;), document.body) 如果路由按这种配置，我们就可以得到路由与URL的映射表： URL Components / App /about App -&gt; About /inbox App -&gt; Inbox /inbox/messages/:id App -&gt; Inbox -&gt; Message Router的基础配置（1）路由默认首页（IndexRoute） 当URL为/的时候，我们需要增加一个默认的初始显示子组件。我们可以通过IndexRoute来设置默认页。 1234567891011121314151617181920import &#123; IndexRoute &#125; from 'react-router'const Dashboard = React.createClass(&#123; render() &#123; return &lt;div&gt;Welcome to the app!&lt;/div&gt; &#125;&#125;)render(( &lt;Router&gt; &lt;Route path=\"/\" component=&#123;App&#125;&gt; &#123;/* Show the dashboard at / */&#125; &lt;IndexRoute component=&#123;Dashboard&#125; /&gt; &lt;Route path=\"about\" component=&#123;About&#125; /&gt; &lt;Route path=\"inbox\" component=&#123;Inbox&#125;&gt; &lt;Route path=\"messages/:id\" component=&#123;Message&#125; /&gt; &lt;/Route&gt; &lt;/Route&gt; &lt;/Router&gt;), document.body) 通过这样的设置，现在我们就有了默认元素了，这种方式类似于apache的直接根目录（directorIndex）或 者是nginx的index.是对直接根路径匹配路由，下面我们来看现在这种方式下的路由与URL的关系： URL Components / App -&gt; Dashboard /about App -&gt; About /inbox App -&gt; Inbox /inbox/messages/:id App -&gt; Inbox -&gt; Message 我们发现与上面相比，这里多了默认的首页路由：url为：/，路由的组件为App -&gt;Dashboard （2）从URL中解耦UI 如果我们能从URL为/inbox/messages/:id 的路由中，移除/inbox使得路由的真正页面为：/message/:id 同时保留了JSX的页面结构，React-router允许我们使用这种缺省路径的方法。我们来看如下代码： 1234567891011121314render(( &lt;Router&gt; &lt;Route path=\"/\" component=&#123;App&#125;&gt; &lt;IndexRoute component=&#123;Dashboard&#125; /&gt; &lt;Route path=\"about\" component=&#123;About&#125; /&gt; &lt;Route path=\"inbox\" component=&#123;Inbox&#125; /&gt; &#123;/* Use /messages/:id instead of /inbox/messages/:id */&#125; &lt;Route component=&#123;Inbox&#125;&gt; &lt;Route path=\"messages/:id\" component=&#123;Message&#125; /&gt; &lt;/Route&gt; &lt;/Route&gt; &lt;/Router&gt;), document.body) 注意：这里的message所在的父路由，缺省了path，这样实际上我们就将路由从/inbox/message/:id转化 成为了/message/:id，但是整体的JSX结构并没有发生变化，只是缺省了path而已。这种缺省的方式， 使得我们能够避免非常复杂的层层url的书写方式，这样使得我们整个路由的控制显得简单名了。这种方式 的访问结果如下： URl Components / App -&gt; Dashboard /about App -&gt; About /inbox App -&gt; Inbox /messages/:id App -&gt; Inbox -&gt; Message 上图中，值得注意的是我们只要通过url: /message/:id就可以访问到组件：App -&gt; Inbox -&gt; Message，大大的简化了url，但是访问结果却与inbox/message/:id完全相同。 （3）重定向路由（Redirect） 通过Redirect，我们可以重新定向路由。我们来看下面的例子： 12345678910111213141516171819import &#123; Redirect &#125; from 'react-router'render(( &lt;Router&gt; &lt;Route path=\"/\" component=&#123;App&#125;&gt; &lt;IndexRoute component=&#123;Dashboard&#125; /&gt; &lt;Route path=\"about\" component=&#123;About&#125; /&gt; &lt;Route path=\"inbox\" component=&#123;Inbox&#125;&gt; &#123;/* Redirect /inbox/messages/:id to /messages/:id */&#125; &lt;Redirect from=\"messages/:id\" to=\"/messages/:id\" /&gt; &lt;/Route&gt; &lt;Route component=&#123;Inbox&#125;&gt; &lt;Route path=\"messages/:id\" component=&#123;Message&#125; /&gt; &lt;/Route&gt; &lt;/Route&gt; &lt;/Router&gt;), document.body) 现在，当我们访问/inbox/message/:id的时候，路由会自动跳转到新的url：/message/:id，这样我们就实现了路由的重定向。 （4）路由的leave和enter,路由的进入和移除的过程 路由定义了进入和移除时的hook，也就是路由的移入或者移除的时候会触发一定的事件，这些hooks是非常 有用的，比如路由移入（进入访问）的时候需要做一个权限认证，或者说路由移除（移除访问）的时候需要 保存一些参数等，我们来看什么时候会触发leave hook，什么时候会触发enter hook。 举一个例子：当我们从url：/messages/5，跳转到新的url：/about的过程。 （a）首先触发/messages/:id 路由的leave hook （b）再次触发/inbox路由的leave hook （c）最后触发/about路由的enter hook （5）利用插件的方法来配置路由，并且同时根据leave和enter hook，在JS中实现Redirect 123456789101112131415161718192021222324const routes = &#123; path: '/', component: App, indexRoute: &#123; component: Dashboard &#125;, childRoutes: [ &#123; path: 'about', component: About &#125;, &#123; path: 'inbox', component: Inbox, childRoutes: [&#123; path: 'messages/:id', onEnter: (&#123; params &#125;, replace) =&gt; replace(`/messages/$&#123;params.id&#125;`) &#125;] &#125;, &#123; component: Inbox, childRoutes: [&#123; path: 'messages/:id', component: Message &#125;] &#125; ]&#125;render(&lt;Router routes=&#123;routes&#125; /&gt;, document.body) 这里通过onEnter中的方法来触发重定向，从而实现Redirect. 参考地址 Reacter-router（config）基础配置项","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[]},{"title":"react-scu","slug":"react-scu","date":"2017-05-17T07:20:09.000Z","updated":"2017-05-19T08:46:50.095Z","comments":true,"path":"2017/05/17/react-scu/","link":"","permalink":"http://yoursite.com/2017/05/17/react-scu/","excerpt":"","text":"shouldComponentUpdate，就是指明什么时候component（组件）需要进行更新。 常见的shouldComponentUpdate的用法（1）比如在下面的例子中，组件中只有2个值，props.color和state.count可以发生改变，我们可以这样 使用shouldComponentUpdate。 123456789101112131415161718192021222324class CounterButton extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;count: 1&#125;; &#125; shouldComponentUpdate(nextProps, nextState) &#123; if (this.props.color !== nextProps.color) &#123; return true; &#125; if (this.state.count !== nextState.count) &#123; return true; &#125; return false; &#125; render() &#123; &lt;button color=&#123;this.props.color&#125; onClick=&#123;() =&gt; this.setState(state =&gt; (&#123;count: state.count + 1&#125;))&#125;&gt; Count: &#123;this.state.count&#125; &lt;/button&gt; &#125;&#125; 在上述代码中，组件仅仅会校验prop.color和state.count,如果这些值都不会改变，那么组件就不会有更新。 （2）如果组件更加复杂，拥有的状态变量更多 当组件复杂化，拥有状态变多时，我们需要设计一种模式，对所有的props变量和state变量，做一个“shallow comparison(浅比较）”，这样会使得shouldComponentUpdate函数冗杂化，为了解决该问题，React给了我们提供了另一个继承方法——React.PureComponent： 1234567891011121314class CounterButton extends React.PureComponent &#123; constructor(props) &#123; super(props); this.state = &#123;count: 1&#125;; &#125; render() &#123; &lt;button color=&#123;this.props.color&#125; onClick=&#123;() =&gt; this.setState(state =&gt; (&#123;count: state.count + 1&#125;))&#125;&gt; Count: &#123;this.state.count&#125; &lt;/button&gt; &#125;&#125; 在大多数的情况下，”shallow comparison（浅比较）”是有意义的，因此在大部门情况下我们可以用React.PureComponent来代替shouldComponentUpdate，但是当props和state中的变量发生突变的情况下，“shallow comparison”会失效，因此在props和state的变量发生突变的情况下，不能通过React.PureComponent来更新组件。 shallow comparison失效的情况shallow comparion在js中： 1234var x=[1,2];var y=x;x.push(3);console.log(x==y)//输出true 1234var x=&#123;a:1&#125;;var y=x;x.b=2;console.log(x==y)//输出true 从上面我们可以看出，shallow comparison不能进行深层比较的原因是，js中数组和对象的本质都是Object，一旦赋值y=x后，无论x如何变化，x,y都会只想的是同一个对象。 如何解决shallow comparison失效的问题失效状态1： 123456handleClick() &#123; // This section is bad style and causes a bug const words = this.state.words; words.push('marklar'); this.setState(&#123;words: words&#125;); &#125; 解决方法： 12345handleClick() &#123; this.setState(prevState =&gt; (&#123; words: prevState.words.concat(['marklar']) &#125;));&#125; 失效状态2： 123function updateColorMap(colormap) &#123; colormap.right = 'blue';&#125; 解决方法： 123function updateColorMap(colormap) &#123; return Object.assign(&#123;&#125;, colormap, &#123;right: 'blue'&#125;);&#125; 本质:解决方法的本质是生成了一个新的对象，新对象与原对象比较一定返回的是false。 另一种方法是通过插件Immutable.js解决，不详细描述。 参考地址 React高级教程（es6）——（4）ShouldComponentUpdate的用法","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[]},{"title":"React中的Context","slug":"react-context","date":"2017-05-17T07:07:23.000Z","updated":"2017-05-17T07:11:32.077Z","comments":true,"path":"2017/05/17/react-context/","link":"","permalink":"http://yoursite.com/2017/05/17/react-context/","excerpt":"","text":"简介：在React中，数据可以以流的形式自上而下的传递，每当你使用一个组件的时候，你可以看到组件的props属性会自上而下的传递。但是，在某些情况下，我们不想通过父组件的props属性一级一级的往下传递，我们希望在某一级子组件中，直接得到上N级父组件中props中的值。 一般情况下通过props传值的情况1234567891011121314151617181920212223242526272829class Button extends React.Component &#123; render() &#123; return ( &lt;button style=&#123;&#123;background: this.props.color&#125;&#125;&gt; &#123;this.props.children&#125; &lt;/button&gt; ); &#125;&#125;class Message extends React.Component &#123; render() &#123; return ( &lt;div&gt; &#123;this.props.text&#125; &lt;Button color=&#123;this.props.color&#125;&gt;Delete&lt;/Button&gt; &lt;/div&gt; ); &#125;&#125;class MessageList extends React.Component &#123; render() &#123; const color = \"purple\"; const children = this.props.messages.map((message) =&gt; &lt;Message text=&#123;message.text&#125; color=&#123;color&#125; /&gt; ); return &lt;div&gt;&#123;children&#125;&lt;/div&gt;; &#125;&#125; 我们来分析一下这段代码，大致的组件分为3级: 顶层MessageLists——&gt;Message一级子类——&gt;Button底层子类 我们来看从父组件到子组件的值的传递情况： （1）text: 我们可以看到，在顶层组件MessageLists中的值，传递到一级子组件Message中，并在此组件中被使用。 （2）color: 再看props中的color的传递情况，在顶层组件MessageLists中的值，先传递到一级子组件Message中， 在传递到二级子组件Button中，最后在二级子组件中被使用。 综上：这就是一般在React中，所使用的通过props属性，在父组件与子组件中进行值传递。 如何利用React中的Context来进行值的越级传递。12345678910111213141516171819202122232425262728293031323334353637383940class Button extends React.Component &#123; render() &#123; return ( &lt;button style=&#123;&#123;background: this.context.color&#125;&#125;&gt; &#123;this.props.children&#125; &lt;/button&gt; ); &#125;&#125;Button.contextTypes = &#123; color: React.PropTypes.string&#125;;class Message extends React.Component &#123; render() &#123; return ( &lt;div&gt; &#123;this.props.text&#125; &lt;Button&gt;Delete&lt;/Button&gt; &lt;/div&gt; ); &#125;&#125;class MessageList extends React.Component &#123; getChildContext() &#123; return &#123;color: \"purple\"&#125;; &#125; render() &#123; const children = this.props.messages.map((message) =&gt; &lt;Message text=&#123;message.text&#125; /&gt; ); return &lt;div&gt;&#123;children&#125;&lt;/div&gt;; &#125;&#125;MessageList.childContextTypes = &#123; color: React.PropTypes.string&#125;; 上述代码，我们实现了通过React的Context实现了值——color的越级传递。我们来分析一下上述的方法。 （1）首先在顶层组件中： 123MessageList.childContextTypes = &#123; color: React.PropTypes.string&#125;; 定义了顶层组件所拥有的子类context对象——该顶层组件所拥有的的子类context对象为color，且必须为字符串。 然后通过getChildText方法，来给子context对象的属性赋值： 123getChildContext() &#123; return &#123;color: \"purple\"&#125;; &#125; 这样就完成了顶层组件中，context对象的赋值。 （2）越级传递，因为color属性只在最底层使用 我们来看color属性的越级传递，因为color属性，在一级子组件Message中并没有直接用到，因此我们可以 直接传递到最底层（越级），在Button组件中使用。 首先Button组件中，再次声明了所接受到的context的子组件color的类型，声明必须为字符串： 123Button.contextTypes = &#123; color: React.PropTypes.string&#125;; 然后可以通过this.context.color这种方式调用： 123&lt;button style=&#123;&#123;background: this.context.color&#125;&#125;&gt; &#123;this.props.children&#125;&lt;/button&gt;123123 综上：这样，我们发现通过Context，我们就能实现值得越级传递。 参考地址 React高级教程（es6）——（3）React中的Context","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[]},{"title":"JSX语法深入理解","slug":"react-jsx-syntax","date":"2017-05-17T06:51:31.000Z","updated":"2017-05-17T06:53:20.705Z","comments":true,"path":"2017/05/17/react-jsx-syntax/","link":"","permalink":"http://yoursite.com/2017/05/17/react-jsx-syntax/","excerpt":"","text":"简介：从根本上来说，JSX语法提供了一种创建React元素的语法糖，JSX语句可以编译成：React.createElement(component, props, …children)的形式，比如： 123&lt;MyButton color=\"blue\" shadowSize=&#123;2&#125;&gt; Click Me&lt;/MyButton&gt; 编译结果： 12345React.createElement( MyButton, &#123;color: 'blue', shadowSize: 2&#125;, 'Click Me') 指定React元素的类型JSX标签的头部，决定了React元素的类型，大写的标签，意味着JSX的标签与React的组件一一对应，比如 1&lt;Foo/&gt;标签就对应了Foo组件 （1）必须包裹在一定的范围内 1234567import React from 'react';import CustomButton from './CustomButton';function WarningButton() &#123; // return React.createElement(CustomButton, &#123;color: 'red'&#125;, null); return &lt;CustomButton color=\"red\" /&gt;;&#125; 比如这样，引入了2个组件，构成了一个新的组件WarningButton，组件的返回值的元素，必须包含在一定范围内，这里通过函数的’{ ‘, ’ } ‘实现包裹的效果。 （2）用户定义的组件必须大写 我们前面已经说过，JSX的标签与组件是一一对应的，当我们使用JSX语法，引用组件的时候，标签必须要大写（同时定义组件的函数名也必须是大写的）。 1234567function Hello()&#123; return &lt;h2&gt;Hello,World&lt;/h2&gt;&#125;//定义过程&lt;Hello/&gt;//使用过程 （3）不能在运行期间，动态的选择类型我们不能在JSX中，动态的规定组件的类型，举例来说： 123456789101112import React from 'react';import &#123; PhotoStory, VideoStory &#125; from './stories';const components = &#123; photo: PhotoStory, video: VideoStory&#125;;function Story(props) &#123; return &lt;components[props.storyType] story=&#123;props.story&#125; /&gt;; //这样写是不对的，我们在返回的组件中，动态定义了组件，这种动态的定义是无效的&#125; 应该改写为： 1234567891011121314import React from 'react';import &#123; PhotoStory, VideoStory &#125; from './stories';const components = &#123; photo: PhotoStory, video: VideoStory&#125;;function Story(props) &#123; const SpecificStory = components[props.storyType]; return &lt; SpecificStory story=&#123;props.story&#125; /&gt;; //这样就是正确的，我们不要在JSX的标签中使用动态定义&#125; JSX中的Props属性（1）JS表达式可以通过{}，包裹js的语法来使用。比如： 1&lt;MyComponent foo=&#123;1 + 2 + 3 + 4&#125; /&gt; 等价于： 1&lt;MyComponent foo=&#123;10&#125; /&gt; 如果不是js表达式，则不能包裹在{}中使用。 （2）Props属性的默认值Props上的属性可以有默认值，并且默认值为true，比如： 12&lt;MyTextBox autocomplete /&gt;&lt;MyTextBox autocomplete=&#123;true&#125; /&gt; 上面这两个式子是等价的，但是不推荐使用默认值，因为在ES6的语法中{foo}代表的意思是：{foo:foo}的意思，并不是{foo:true}。 （3）扩展属性可以通过ES6的…方法，给组件赋属性值，例如： 12345678function App1() &#123; return &lt;Greeting firstName=\"Ben\" lastName=\"Hector\" /&gt;;&#125;function App2() &#123; const props = &#123;firstName: 'Ben', lastName: 'Hector'&#125;; return &lt;Greeting &#123;...props&#125; /&gt;;&#125; 上面的这两种方式是等价的。 JSX中的children（1）children中的function 我们来考虑自定义组件中包含函数的情况： 1234567function ListOfTenThings() &#123; return ( &lt;Repeat numTimes=&#123;10&#125;&gt; &#123;(index) =&gt; &lt;div key=&#123;index&#125;&gt;This is item &#123;index&#125; in the list&lt;/div&gt;&#125; &lt;/Repeat&gt; );&#125; 那么何时调用这个children中的方法呢？ 1234567function Repeat(props) &#123; let items = []; for (let i = 0; i &lt; props.numTimes; i++) &#123; items.push(props.children(i)); &#125; return &lt;div&gt;&#123;items&#125;&lt;/div&gt;;&#125; 我们从上述的Repeat组件的定义中可以看出来，children中的方法按此定义会一直执行10次。 （2）忽略Boolean，Null以及Undefined false,null,undefined以及true是不能通过render()方法，呈现在页面上的，下面的这些div块的样式相同，都是空白块： 12345&lt;div /&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&#123;false&#125;&lt;/div&gt;&lt;div&gt;&#123;null&#125;&lt;/div&gt;&lt;div&gt;&#123;true&#125;&lt;/div&gt; 这种属性，在通过render呈现元素的时候，是十分有用的，比如我们只想在div元素中展现Head组件，例子如下： 1234&lt;div&gt; &#123;showHeader &amp;&amp; &lt;Header /&gt;&#125; &lt;Content /&gt;&lt;/div&gt; 这里的逻辑是，只有showHeader==true，在会在页面呈现Header组件，否则为null，即为不显示任何东西，这相当于一个if的判断了。 再举一个例子： 12345&lt;div&gt; &#123;props.messages.length &amp;&amp; &lt;MessageList messages=&#123;props.messages&#125; /&gt; &#125;&lt;/div&gt; 在这个div中，我们需要知道的是即使元素为0，0是能够呈现在页面中的。也就是说上述代码中，只要props.messages数组存在，不管长度是否为0都是存在的。（这里不同于js，js中的语法认为0==false） （3）如何显示Null，Undefined和Boolean 如果我们一定要再页面上显示Null等，可以将其先转化为字符串之后再显示。 123&lt;div&gt; My JavaScript variable is &#123;String(myVariable)&#125;.&lt;/div&gt; 通过String的转化后就能在页面上显示了。 参考地址http://blog.csdn.net/liwusen/article/details/53383922","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[]},{"title":"为什么文件名要小写？","slug":"name-the-file","date":"2017-05-12T01:26:21.000Z","updated":"2017-05-12T02:37:14.171Z","comments":true,"path":"2017/05/12/name-the-file/","link":"","permalink":"http://yoursite.com/2017/05/12/name-the-file/","excerpt":"","text":"为什么文件名要小写？ “文件名建议只使用小写字母，不使用大写字母。” “为了醒目，某些说明文件的文件名，可以使用大写字母，比如README、LICENSE。” 网友看见了，就提问为什么文件名要小写？ 说实话，虽然这是 Linux 传统，我却从没认真想过原因。赶紧查资料，结果发现四个很有说服力的理由，支持这样做。 下面就是这四个理由。另外，文后我还会发布一条前端培训的消息。 一、可移植性Linux 系统是大小写敏感的，而 Windows 系统和 Mac 系统正好相反，大小写不敏感。一般来说，这不是大问题。 但是，如果两个文件名只有大小写不同，其他都相同，跨平台就会出问题。 foobar Foobar FOOBAR fOObAr 上面四个文件名，Windows 系统会把它们都当作foobar。如果它们同时存在，你可能没办法打开后面三个文件。 另一方面，在 Mac 系统上开发时，有时会疏忽，写错大小写。 12// 正确文件名是 MyModule.jsconst module = require('./myModule'); 上面的代码在 Mac 上面可以运行，因为 Mac 认为MyModule.js和myModule.js是同一个文件。但是，一旦代码到服务器运行就会报错，因为 Linux 系统找不到myModule.js。 如果所有的文件名都采用小写，就不会出现上面的问题，可以保证项目有良好的可移植性。 二、易读性小写文件名通常比大写文件名更易读，比如accessibility.txt就比ACCESSIBILITY.TXT易读。 有人习惯使用驼峰命名法，单词的第一个字母大写，其他字母小写。这种方法的问题是，如果遇到全部是大写的缩略词，就会不适用。 比如，一个姓李的纽约特警，无论写成NYPoliceSWATLee还是NyPoliceSwatlee，都怪怪的，还是写成ny-police-swat-lee比较容易接受。 三、易用性某些系统会生成一些预置的用户目录，采用首字母大写的目录名。比如，Ubuntu 在用户主目录会默认生成Downloads、 Pictures、Documents等目录。 Mac 系统更过分，一部分系统目录也是大写的，比如/Library/Audio/Apple Loops/。 另外，某些常见的配置文件或说明文件，也采用大写的文件名，比如Makefile、INSTALL、CHANGELOG、.Xclients和.Xauthority等等。 所以，用户的文件都采用小写文件名，就很方便与上面这些目录或文件相区分。 如果你打破砂锅问到底，为什么操作系统会采用这样的大写文件名？原因也很简单，因为早期 Unix 系统上，ls命令先列出大写字母，再列出小写字母，大写的路径会排在前面。因此，如果目录名或文件名是大写的，就比较容易被用户首先看到。 img 四、便捷性文件名全部小写，还有利于命令行操作。比如，某些命令可以不使用-i参数了。 1234567# 大小写敏感的搜索$ find . -name abc$ locate \"*.htmL\"# 大小写不敏感的搜索$ find . -iname abc$ locate -i \"*.HtmL\" img 另外，大写字母需要按下 Shift 键，多多少少有些麻烦。如果文件名小写，就不用碰这个键了，不仅省事，还可以提高打字速度。 程序员长时间使用键盘，每分钟少按几次 Shift，一天下来就可以省掉很多手指动作。长年累月，也是对自己身体的一种保护。 综上所述，文件名全部使用小写字母和连词线（all-lowercase-with-dashes），是一种值得推广的正确做法。","categories":[],"tags":[{"name":"文件名","slug":"文件名","permalink":"http://yoursite.com/tags/文件名/"},{"name":"小写","slug":"小写","permalink":"http://yoursite.com/tags/小写/"}]},{"title":"CSS 变量","slug":"css-variable","date":"2017-05-12T01:25:09.000Z","updated":"2017-05-12T01:58:01.911Z","comments":true,"path":"2017/05/12/css-variable/","link":"","permalink":"http://yoursite.com/2017/05/12/css-variable/","excerpt":"","text":"CSS 变量今年三月，微软宣布 Edge 浏览器将支持 CSS 变量。 这个重要的 CSS 新功能，所有主要浏览器已经都支持了。本文全面介绍如何使用它，你会发现原生 CSS 从此变得异常强大。 img 一、变量的声明声明变量的时候，变量名前面要加两根连词线（--）。 12345&gt; body &#123;&gt; --foo: #7F583F;&gt; --bar: #F7EFD2;&gt; &#125;&gt; 上面代码中，body选择器里面声明了两个变量：--foo和--bar。 它们与color、font-size等正式属性没有什么不同，只是没有默认含义。所以 CSS 变量（CSS variable）又叫做“CSS 自定义属性”（CSS custom properties）。因为变量与自定义的 CSS 属性其实是一回事。 你可能会问，为什么选择两根连词线（--）表示变量？因为$foo被 Sass 用掉了，@foo被 Less 用掉了。为了不产生冲突，官方的 CSS 变量就改用两根连词线了。 各种值都可以放入 CSS 变量。 1234567891011121314&gt; :root&#123;&gt; --main-color: #4d4e53;&gt; --main-bg: rgb(255, 255, 255);&gt; --logo-border-color: rebeccapurple;&gt;&gt; --header-height: 68px;&gt; --content-padding: 10px 20px;&gt;&gt; --base-line-height: 1.428571429;&gt; --transition-duration: .35s;&gt; --external-link: &quot;external link&quot;;&gt; --margin-top: calc(2vh + 20px);&gt; &#125;&gt; 变量名大小写敏感，--header-color和--Header-Color是两个不同变量。 二、var() 函数var()函数用于读取变量。 12345&gt; a &#123;&gt; color: var(--foo);&gt; text-decoration-color: var(--bar);&gt; &#125;&gt; var()函数还可以使用第二个参数，表示变量的默认值。如果该变量不存在，就会使用这个默认值。 12&gt; color: var(--foo, #7F583F);&gt; 第二个参数不处理内部的逗号或空格，都视作参数的一部分。 123&gt; var(--font-stack, \"Roboto\", \"Helvetica\");&gt; var(--pad, 10px 15px 20px);&gt; var()函数还可以用在变量的声明。 12345&gt; :root &#123;&gt; --primary-color: red;&gt; --logo-text: var(--primary-color);&gt; &#125;&gt; 注意，变量值只能用作属性值，不能用作属性名。 123456&gt; .foo &#123;&gt; --side: margin-top;&gt; /* 无效 */&gt; var(--side): 20px;&gt; &#125;&gt; 上面代码中，变量--side用作属性名，这是无效的。 三、变量值的类型如果变量值是一个字符串，可以与其他字符串拼接。 123&gt; --bar: 'hello';&gt; --foo: var(--bar)' world';&gt; 利用这一点，可以 debug（例子）。 1234&gt; body:after &#123;&gt; content: '--screen-category : 'var(--screen-category);&gt; &#125;&gt; 如果变量值是数值，不能与数值单位直接连用。 123456&gt; .foo &#123;&gt; --gap: 20;&gt; /* 无效 */&gt; margin-top: var(--gap)px;&gt; &#125;&gt; 上面代码中，数值与单位直接写在一起，这是无效的。必须使用calc()函数，将它们连接。 12345&gt; .foo &#123;&gt; --gap: 20;&gt; margin-top: calc(var(--gap) * 1px);&gt; &#125;&gt; 如果变量值带有单位，就不能写成字符串。 123456789101112&gt; /* 无效 */&gt; .foo &#123;&gt; --foo: '20px';&gt; font-size: var(--foo);&gt; &#125;&gt;&gt; /* 有效 */&gt; .foo &#123;&gt; --foo: 20px;&gt; font-size: var(--foo);&gt; &#125;&gt; 四、作用域同一个 CSS 变量，可以在多个选择器内声明。读取的时候，优先级最高的声明生效。这与 CSS 的”层叠”（cascade）规则是一致的。 下面是一个例子。 1234567891011&gt; &lt;style&gt;&gt; :root &#123; --color: blue; &#125;&gt; div &#123; --color: green; &#125;&gt; #alert &#123; --color: red; &#125;&gt; * &#123; color: var(--color); &#125;&gt; &lt;/style&gt;&gt;&gt; &lt;p&gt;蓝色&lt;/p&gt;&gt; &lt;div&gt;绿色&lt;/div&gt;&gt; &lt;div id=\"alert\"&gt;红色&lt;/div&gt;&gt; 上面代码中，三个选择器都声明了--color变量。不同元素读取这个变量的时候，会采用优先级最高的规则，因此三段文字的颜色是不一样的。 这就是说，变量的作用域就是它所在的选择器的有效范围。 12345678&gt; body &#123;&gt; --foo: #7F583F;&gt; &#125;&gt;&gt; .content &#123;&gt; --bar: #F7EFD2;&gt; &#125;&gt; 上面代码中，变量--foo的作用域是body选择器的生效范围，--bar的作用域是.content选择器的生效范围。 由于这个原因，全局的变量通常放在根元素:root里面，确保任何选择器都可以读取它们。 1234&gt; :root &#123;&gt; --main-color: #06c;&gt; &#125;&gt; 五、响应式布局CSS 是动态的，页面的任何变化，都会导致采用的规则变化。 利用这个特点，可以在响应式布局的media命令里面声明变量，使得不同的屏幕宽度有不同的变量值。 1234567891011121314151617&gt; body &#123;&gt; --primary: #7F583F;&gt; --secondary: #F7EFD2;&gt; &#125;&gt;&gt; a &#123;&gt; color: var(--primary);&gt; text-decoration-color: var(--secondary);&gt; &#125;&gt;&gt; @media screen and (min-width: 768px) &#123;&gt; body &#123;&gt; --primary: #F7EFD2;&gt; --secondary: #7F583F;&gt; &#125;&gt; &#125;&gt; 六、兼容性处理对于不支持 CSS 变量的浏览器，可以采用下面的写法。 12345&gt; a &#123;&gt; color: #7F583F;&gt; color: var(--primary);&gt; &#125;&gt; 也可以使用@support命令进行检测。 12345678&gt; @supports ( (--a: 0)) &#123;&gt; /* supported */&gt; &#125;&gt;&gt; @supports ( not (--a: 0)) &#123;&gt; /* not supported */&gt; &#125;&gt; 七、JavaScript 操作JavaScript 也可以检测浏览器是否支持 CSS 变量。 1234567891011&gt; const isSupported =&gt; window.CSS &amp;&amp;&gt; window.CSS.supports &amp;&amp;&gt; window.CSS.supports('--a', 0);&gt;&gt; if (isSupported) &#123;&gt; /* supported */&gt; &#125; else &#123;&gt; /* not supported */&gt; &#125;&gt; JavaScript 操作 CSS 变量的写法如下。 12345678910&gt; // 设置变量&gt; document.body.style.setProperty('--primary', '#7F583F');&gt;&gt; // 读取变量&gt; document.body.style.getPropertyValue('--primary').trim();&gt; // '#7F583F'&gt;&gt; // 删除变量&gt; document.body.style.removeProperty('--primary');&gt; 这意味着，JavaScript 可以将任意值存入样式表。下面是一个监听事件的例子，事件信息被存入 CSS 变量。 1234567&gt; const docStyle = document.documentElement.style;&gt;&gt; document.addEventListener('mousemove', (e) =&gt; &#123;&gt; docStyle.setProperty('--mouse-x', e.clientX);&gt; docStyle.setProperty('--mouse-y', e.clientY);&gt; &#125;);&gt; 那些对 CSS 无用的信息，也可以放入 CSS 变量。 12&gt; --foo: if(x &gt; 5) this.width = 10;&gt; 上面代码中，--foo的值在 CSS 里面是无效语句，但是可以被 JavaScript 读取。这意味着，可以把样式设置写在 CSS 变量中，让 JavaScript 读取。 所以，CSS 变量提供了 JavaScript 与 CSS 通信的一种途径。 八、参考链接 Winning with CSS Variables CSS Variables: Why Should You Care? It’s Time To Start Using CSS Custom Properties Why I’m Excited About Native CSS Variables CSS变量教程","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"变量","slug":"变量","permalink":"http://yoursite.com/tags/变量/"}]},{"title":"linux vi 命令详解","slug":"linux-vi","date":"2017-05-11T02:33:03.000Z","updated":"2017-05-11T09:02:10.978Z","comments":true,"path":"2017/05/11/linux-vi/","link":"","permalink":"http://yoursite.com/2017/05/11/linux-vi/","excerpt":"","text":"vi编辑器是所有Unix及Linux系统下标准的编辑器，它的强大不逊色于任何最新的文本编辑器，这里只是简单地介绍一下它的用法和一小部分指 令。由于 对Unix及Linux系统的任何版本，vi编辑器是完全相同的，因此您可以在其他任何介绍vi的地方进一步了解它。vi也是Linux中最基本的文本编 辑器，学会它后，您将在Linux的世界里畅行无阻。 vi的基本概念基本上vi可以分为三种状态，分别是: 命令模式（command mode） 插入模式（Insert mode） 底行模式（last line mode） 各模式的功能区别如下： 命令行模式command mode） 控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入插入模式下，或者到底行模式。 插入模式（Insert mode） 只有在插入模式下，才可以做文字输入，按ESC键可回到命令行模式。 底行模式（last line mode） 将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。 不过一般我们在使用时把vi简化成两个模式，就是将底行模式也算入命令行模式。 vi的基本操作进入vi 在系统提示符号输入vi及文件名称后，就进入vi全屏幕编辑画面： 1$ vi myfile 不过有一点要特别注意，就是您进入vi之后，是处于「命令行模式」，您要切换到「插入模式」才能够输入文字。初次使用vi的人都会想先用上下左右键移动光标，结果电脑一直哔哔叫，把自己气个半死，所以进入vi后，先不要乱动，转换到 「插入模式」再说吧！ 切换至插入模式 编辑文件 在「命令行模式」下按一下字母 i 就可以进入「插入模式」，这时候你就可以开始输入文字了。 切换至命令行模式 您目前处于「插入模式」，您就只能一直输入文字。回到「命令行模式」，按一下 ESC 键就行啦。 切换至底行模式 退出vi及保存文件 在「命令行模式」下，按一下 : 冒号键进入「底行模式」，输入下面的命令： 123456# 将文章以指定的文件名filename保存: w filename # 存盘并退出vi: wq # 不存盘强制退出vi: q! 命令行模式（command mode）功能键插入模式 按i 进入插入模式后，是从光标当前位置开始输入文件； 按a进入插入模式后，是从目前光标所在位置的下一个位置开始输入文字； 按o进入插入模式后，是插入新的一行，从行首开始输入文字。 从插入模式切换为命令行模式 按ESC键 移动光标 vi可以直接用键盘上的光标来上下左右移动，但正规的vi是用小写英文字母h(左)、j(下)、k(上)、l(右)，分别控制光标左、下、上、右移一格。 key command Ctrl+B 屏幕往”后”移动一页 Ctrl+F 屏幕往”前”移动一页 Ctrl+U 屏幕往”后”移动半页 Ctrl+D 屏幕往”前”移动半页 0 移到文章的开头 g 移动到文章的最后 $ 移动到光标所在行的”行尾” ^ 移动到光标所在行的”行首” w 光标跳到下个字的开头 e 光标跳到下个字的字尾 b 光标回到上个字的开头 #l 光标移到该行的第#个位置，如：5l，56l 删除文字 key command x 每按一次，删除光标所在位置的”后面”一个字符 #x 例如，6x表示删除光标所在位置的”后面” 6 个字符 X 大写的 X ，每按一次，删除光标所在位置的”前面”一个字符 #X 例如，20X表示删除光标所在位置的”前面” 20 个字符 dd 删除光标所在行 #dd 从光标所在行开始删除#行 复制 key command yw 将光标所在之处到字尾的字符复制到缓冲区中 #yw 复制#个字到缓冲区 yy 复制光标所在行到缓冲区 #yy 例如，6yy表示拷贝从光标所在的该行”往下数”6行文字 p 将缓冲区内的字符贴到光标所在位置。注意：所有与”y”有关的复制命令都必须与”p”配合才能完成复制与粘贴功能 替换 key command r 替换光标所在处的字符 R 替换光标所到之处的字符，直到按下ESC键为止 回复上一次操作 key command u 如果您误执行一个命令，可以马上按下u，回到上一个操作。按多次”u”可以执行多次回复 更改 key command cw 更改光标所在处的字到字尾处 c#w 例如，c3w表示更改3个字 跳至指定的行 key command Ctrl+G 列出光标所在行的行号 #G 例如，15G，表示移动光标至文章的第15行行首 底行模式（last line mode）下命令简介在使用「底行模式」之前，请记住先按ESC键确定您已经处于「命令行模式」下后，再按:冒号即可进入「底行模式」。 列出行号 key command set nu 输入「set nu」后，会在文件中的每一行前面列出行号。 跳到文件中的某一行 key command # 「#」号表示一个数字，在冒号后输入一个数字，再按回车键就会跳到该行了，如输入数字15，再回车，就会跳到文章的第15行。 查找字符 key command /关键字 先按「/」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往后寻找到您要的关键字为止。 ?关键字 先按「?」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往前寻找到您要的关键字为止。 保存文件 key command w 在冒号输入字母「w」就可以将文件保存起来。 离开vi key command q 按「q」就是退出，如果无法离开vi，可以在「q」后跟一个「!」强制离开vi。 qw 一般建议离开时，搭配「w」一起使用，这样在退出的时候还可以保存文件。 参考地址http://www.cnblogs.com/mahang/archive/2011/09/01/2161672.html","categories":[],"tags":[]},{"title":"常用 Git 命令清单","slug":"git-commend","date":"2017-05-10T09:27:06.000Z","updated":"2017-05-11T09:42:15.755Z","comments":true,"path":"2017/05/10/git-commend/","link":"","permalink":"http://yoursite.com/2017/05/10/git-commend/","excerpt":"","text":"img 几个专用名词的译名如下： Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 新建代码库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name \"[name]\"$ git config [--global] user.email \"[email address]\" 增加/删除文件123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed]# 停止追踪指定文件(删除的文件追踪不了)，但该文件会保留在工作区$ git rm --cached [file] 代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 查看信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat \"@&#123;0 day ago&#125;\"# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 其他12# 生成一个可供发布的压缩包$ git archive 参考地址http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html","categories":[],"tags":[]},{"title":"使用svn客户端功能","slug":"svn-commend","date":"2017-05-05T06:23:58.000Z","updated":"2017-05-05T07:17:27.716Z","comments":true,"path":"2017/05/05/svn-commend/","link":"","permalink":"http://yoursite.com/2017/05/05/svn-commend/","excerpt":"","text":"使用svn客户端功能1.从本地导入代码到服务器(第一次初始化导入) 1$ svn import /Users/apple/Documents/eclipse_workspace/weibo svn://localhost/mycode/weibo --username=mj --password=123 -m &quot;初始化导入&quot; 我解释下指令的意思：将/Users/apple/Documents/eclipse_workspace/weibo中的所有内容，上传到服务器mycode仓库的weibo目录下，后面双引号中的”初始化导入”是注释 2.从服务器端下载代码到客户端本地 1svn checkout svn://localhost/mycode --username=mj --password=123 /Users/apple/Documents/code 我解释下指令的意思：将服务器中mycode仓库的内容下载到/Users/apple/Documents/code目录中 3.提交更改过的代码到服务器 在步骤2中已经将服务器端的代码都下载到/Users/apple/Documents/code目录中，现在修改下里面的一些代码，然后提交这些修改到服务器 12345//&lt;1&gt; 打开终端，先定位到/Users/apple/Documents/code目录$ cd/Users/apple/Documents/code//&lt;2&gt; 输入提交指令：$ svn commit -m &quot;修改了main.m文件&quot; 这个指令会将/Users/apple/Documents/code下的所有修改都同步到服务器端，假如这次我只修改了main.m文件 4.更新服务器端的代码到客户端 这个应该是最简单的指令了，在终端中定位到客户端代码目录后，比如上面的/Users/apple/Documents/code目录 1$ svn update 5.至于svn的其他用法 1$ svn help img 这里列出一大堆svn指令，后面括号中的内容的一般代表着指令的简称，比如我们可以用svn ci代替svn commit，用svn co代替svn checkout。","categories":[],"tags":[]},{"title":"SSH key (win)","slug":"sshkey","date":"2017-05-05T06:21:40.000Z","updated":"2017-05-05T07:17:47.079Z","comments":true,"path":"2017/05/05/sshkey/","link":"","permalink":"http://yoursite.com/2017/05/05/sshkey/","excerpt":"","text":"window系统1234567891011121314//运行git Bash客户端$ cd ~/.ssh//查看目录文件$ ls//创建一个SSH key$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot;//拷贝 id_rsa.pub 文件的内容，你可以用编辑器打开文件复制，也可以用git命令复制该文件的内容$ clip &lt; ~/.ssh/id_rsa.pub//测试一下该SSH key$ ssh -T git@github.com","categories":[],"tags":[]},{"title":"Visual Studio Code 常用快捷键(WIN)","slug":"vscode-keymap","date":"2017-05-05T01:59:54.000Z","updated":"2017-05-23T09:41:13.217Z","comments":true,"path":"2017/05/05/vscode-keymap/","link":"","permalink":"http://yoursite.com/2017/05/05/vscode-keymap/","excerpt":"","text":"主命令框F1或 Ctrl+Shift+P: 打开命令面板。在打开的输入框内，可以输入任何命令，例如： 按一下 Backspace会进入到Ctrl+P 模式 在Ctrl+P下输入 &gt;可以进入Ctrl+Shift+P模式 在 Ctrl+P 窗口下还可以: 直接输入文件名，跳转到文件 ?列出当前可执行的动作 ! 显示 Errors或 Warnings，也可以 Ctrl+Shift+M :跳转到行数，也可以 Ctrl+G直接进入 @跳转到 symbol（搜索变量或者函数），也可以 Ctrl+Shift+O直接进入 @根据分类跳转 symbol，查找属性或函数，也可以 Ctrl+Shift+O 后输入:进入 #根据名字查找 symbol，也可以 Ctrl+T 快捷键Basic Editing Key Command Command id Ctrl+X Cut line (empty selection) 剪切 Ctrl+C Copy line (empty selection) 复制 Ctrl+Shift+K Delete Line 删除当前行 Ctrl+Enter Insert Line Below 向下插入空行 Ctrl+Shift+Enter Insert Line Above 向上插入空行 Alt+Down Move Line Down 向下移动当前行 Alt+Up Move Line Up 向上移动当前行 Shift+Alt+Down Copy Line Down 向下插入当前行内容 Shift+Alt+Up Copy Line Up 向上插入当前行内容 Ctrl+D Add Selection To Next Find Match editor.action.addSelectionToNextFindMatch Ctrl+K Ctrl+D Move Last Selection To Next Find Match editor.action.moveSelectionToNextFindMatch Ctrl+U Undo last cursor operation 回退光标操作位置 Shift+Alt+I Insert cursor at end of each line selected editor.action.insertCursorAtEndOfEachLineSelected Ctrl+Shift+L Select all occurrences of current selection editor.action.selectHighlights Ctrl+F2 Select all occurrences of current word editor.action.changeAll Ctrl+I Select current line 选中当前行内容 Ctrl+Alt+Down Insert Cursor Below editor.action.insertCursorBelow Ctrl+Alt+Up Insert Cursor Above editor.action.insertCursorAbove Ctrl+Shift+\\ Jump to matching bracket editor.action.jumpToBracket Ctrl+] Indent Line 增加当前行缩进 Ctrl+[ Outdent Line 减少当前行缩进 Home Go to Beginning of Line 光标定位到行首 End Go to End of Line 光标定位到行尾 Ctrl+End Go to End of File 光标定位到文件的尾部 Ctrl+Home Go to Beginning of File 光标定位到文件的开头 Ctrl+Down Scroll Line Down 滚动条向下移动 Ctrl+Up Scroll Line Up 滚动条向上移动 Alt+PageDown Scroll Page Down 滚动条向下移动一屏 Alt+PageUp Scroll Page Up 滚动条向上移动一屏 Ctrl+Shift+[ Fold (collapse) region 折叠代码 Ctrl+Shift+] Unfold (uncollapse) region 展开代码 Ctrl+K Ctrl+[ Fold (collapse) all subregions editor.foldRecursively Ctrl+K Ctrl+] Unfold (uncollapse) all subregions editor.unfoldRecursively Ctrl+K Ctrl+0 Fold (collapse) all regions editor.foldAll Ctrl+K Ctrl+J Unfold (uncollapse) all regions editor.unfoldAll Ctrl+K Ctrl+C Add Line Comment editor.action.addCommentLine Ctrl+K Ctrl+U Remove Line Comment editor.action.removeCommentLine Ctrl+/ Toggle Line Comment 注释(或取消注释)当前行代码,//注释内容 Shift+Alt+A Toggle Block Comment 注释(或取消注释)选择代码,/*注释内容*/ Ctrl+F Find 查找 Ctrl+H Replace 替换 F3 Command Command id Shift+F3 Cut line (empty selection) 剪切 Ctrl+C Copy line (empty selection) 复制 Ctrl+Shift+K Delete Line 删除当前行 Ctrl+Enter Insert Line Below 向下插入空行 Ctrl+Shift+Enter Insert Line Above 向上插入空行 Alt+Down Move Line Down 向下移动当前行 Alt+Up Move Line Up 向上移动当前行 Shift+Alt+Down Copy Line Down 向下插入当前行内容 Rich Languages Editing Key Command Command id Ctrl+Space Trigger Suggest editor.action.triggerSuggest Ctrl+Shift+Space Trigger Parameter Hints editor.action.triggerParameterHints Shift+Alt+F Format Document editor.action.formatDocument Ctrl+K Ctrl+F Format Selection editor.action.formatSelection F12 Go to Definition editor.action.goToDeclaration Ctrl+K Ctrl+I Show Hover editor.action.showHover Alt+F12 Peek Definition editor.action.previewDeclaration Ctrl+K F12 Open Definition to the Side editor.action.openDeclarationToTheSide Ctrl+. Quick Fix editor.action.quickFix Shift+F12 Show References editor.action.referenceSearch.trigger F2 Rename Symbol editor.action.rename Ctrl+Shift+. Replace with Next Value editor.action.inPlaceReplace.down Ctrl+Shift+, Replace with Previous Value editor.action.inPlaceReplace.up Shift+Alt+Right Expand AST Select editor.action.smartSelect.grow Shift+Alt+Left Shrink AST Select editor.action.smartSelect.shrink Ctrl+K Ctrl+X Trim Trailing Whitespace editor.action.trimTrailingWhitespace Ctrl+K M Change Language Mode workbench.action.editor.changeLanguageMode Navigation Key Command Command id Ctrl+T Show All Symbols workbench.action.showAllSymbols Ctrl+G Go to Line… workbench.action.gotoLine Ctrl+P Go to File…, Quick Open workbench.action.quickOpen Ctrl+Shift+O Go to Symbol… workbench.action.gotoSymbol Ctrl+Shift+M Show Problems workbench.actions.view.problems F8 Go to Next Error or Warning editor.action.marker.next Shift+F8 Go to Previous Error or Warning editor.action.marker.prev Ctrl+Shift+P Show All Commands workbench.action.showCommands Ctrl+Shift+Tab Navigate Editor Group History workbench.action.openPreviousRecentlyUsedEditorInGroup Alt+Left Go Back workbench.action.navigateBack Alt+Right Go Forward workbench.action.navigateForward Editor/Window Management Key Command Command id Ctrl+Shift+N New Window workbench.action.newWindow Ctrl+W Close Window workbench.action.closeWindow Ctrl+F4 Close Editor workbench.action.closeActiveEditor Ctrl+K F Close Folder workbench.action.closeFolder unassigned Cycle Between Editor Groups workbench.action.navigateEditorGroups Ctrl+\\ Split Editor workbench.action.splitEditor Ctrl+1 Focus into First Editor Group workbench.action.focusFirstEditorGroup Ctrl+2 Focus into Second Editor Group workbench.action.focusSecondEditorGroup Ctrl+3 Focus into Third Editor Group workbench.action.focusThirdEditorGroup Ctrl+K Ctrl+Left Focus into Editor Group on the Left workbench.action.focusPreviousGroup Ctrl+K Ctrl+Right Focus into Editor Group on the Right workbench.action.focusNextGroup Ctrl+Shift+PageUp Move Editor Left workbench.action.moveEditorLeftInGroup Ctrl+Shift+PageDown Move Editor Right workbench.action.moveEditorRightInGroup Ctrl+K Left Move Active Editor Group Left workbench.action.moveActiveEditorGroupLeft Ctrl+K Right Move Active Editor Group Right workbench.action.moveActiveEditorGroupRight File Management Key Command Command id Ctrl+N New File workbench.action.files.newUntitledFile Ctrl+O Open File… workbench.action.files.openFile Ctrl+S Save workbench.action.files.save Ctrl+K S Save All workbench.action.files.saveAll Ctrl+Shift+S Save As… workbench.action.files.saveAs Ctrl+F4 Close workbench.action.closeActiveEditor unassigned Close Others workbench.action.closeOtherEditors Ctrl+K W Close Group workbench.action.closeEditorsInGroup unassigned Close Other Groups workbench.action.closeEditorsInOtherGroups unassigned Close Group to Left workbench.action.closeEditorsToTheLeft unassigned Close Group to Right workbench.action.closeEditorsToTheRight Ctrl+K Ctrl+W Close All workbench.action.closeAllEditors Ctrl+Shift+T Reopen Closed Editor workbench.action.reopenClosedEditor Ctrl+K Enter Keep Open workbench.action.keepEditor Ctrl+Tab Open Next workbench.action.openNextRecentlyUsedEditorInGroup Ctrl+Shift+Tab Open Previous workbench.action.openPreviousRecentlyUsedEditorInGroup Ctrl+K P Copy Path of Active File workbench.action.files.copyPathOfActiveFile Ctrl+K R Reveal Active File in Windows workbench.action.files.revealActiveFileInWindows Ctrl+K O Show Opened File in New Window workbench.action.files.showOpenedFileInNewWindow unassigned Compare Opened File With workbench.files.action.compareFileWith Display Key Command Command id F11 Toggle Full Screen workbench.action.toggleFullScreen Ctrl+K Z Toggle Zen Mode workbench.action.toggleZenMode Escape Escape Leave Zen Mode workbench.action.exitZenMode Ctrl+= Zoom in workbench.action.zoomIn Ctrl+- Zoom out workbench.action.zoomOut Ctrl+Numpad0 Reset Zoom workbench.action.zoomReset Ctrl+B Toggle Sidebar Visibility workbench.action.toggleSidebarVisibility Ctrl+Shift+E Show Explorer / Toggle Focus workbench.view.explorer Ctrl+Shift+D Show Debug workbench.view.debug Ctrl+Shift+G Show Source Control workbench.view.scm Ctrl+Shift+X Show Extensions workbench.view.extensions Ctrl+Shift+U Show Output workbench.action.output.toggleOutput Ctrl+Q Quick Open View workbench.action.quickOpenView Ctrl+Shift+F Show Search workbench.view.search Ctrl+Shift+H Replace in Files workbench.action.replaceInFiles Ctrl+Shift+J Toggle Search Details workbench.action.search.toggleQueryDetails Ctrl+Shift+C Open New Command Prompt workbench.action.terminal.openNativeConsole Ctrl+Shift+V Toggle Markdown Preview markdown.showPreview Ctrl+K V Open Preview to the Side markdown.showPreviewToSide Ctrl+` Toggle Integrated Terminal workbench.action.terminal.toggleTerminal Preferences Key Command Command id Ctrl+, Open User Settings workbench.action.openGlobalSettings unassigned Open Workspace Settings workbench.action.openWorkspaceSettings Ctrl+K Ctrl+S Open Keyboard Shortcuts workbench.action.openGlobalKeybindings unassigned Open User Snippets workbench.action.openSnippets Ctrl+K Ctrl+T Select Color Theme workbench.action.selectTheme unassigned Configure Display Language workbench.action.configureLocale Debug Key Command Command id F9 Toggle Breakpoint editor.debug.action.toggleBreakpoint F5 Start workbench.action.debug.start F5 Continue workbench.action.debug.continue Ctrl+F5 Start (without debugging) workbench.action.debug.run F6 Pause workbench.action.debug.pause F11 Step Into workbench.action.debug.stepInto Shift+F11 Step Out workbench.action.debug.stepOut F10 Step Over workbench.action.debug.stepOver Shift+F5 Stop workbench.action.debug.stop Ctrl+K Ctrl+I Show Hover editor.debug.action.showDebugHover Tasks Key Command Command id Ctrl+Shift+B Run Build Task workbench.action.tasks.build unassigned Run Test Task workbench.action.tasks.test Extensions Key Command Command id unassigned Install Extension workbench.extensions.action.installExtension unassigned Show Installed Extensions workbench.extensions.action.showInstalledExtensions unassigned Show Outdated Extensions workbench.extensions.action.listOutdatedExtensions unassigned Show Recommended Extensions workbench.extensions.action.showRecommendedExtensions unassigned Show Popular Extensions workbench.extensions.action.showPopularExtensions unassigned Update All Extensions workbench.extensions.action.updateAllExtensions 修改默认快捷键打开默认键盘快捷方式设置：File -&gt; Preferences -&gt; Keyboard Shortcuts 修改keybindings.json： 12345678910111213141516171819202122232425262728293031323334353637[ // ctrl+space 被切换输入法快捷键占用 &#123; \"key\": \"ctrl+alt+space\", \"command\": \"editor.action.triggerSuggest\", \"when\": \"editorTextFocus\" &#125;, // ctrl+d 删除一行 &#123; \"key\": \"ctrl+d\", \"command\": \"editor.action.deleteLines\", \"when\": \"editorTextFocus\" &#125;, // 与删除一行的快捷键互换 &#123; \"key\": \"ctrl+shift+k\", \"command\": \"editor.action.addSelectionToNextFindMatch\", \"when\": \"editorFocus\" &#125;, // ctrl+shift+/多行注释 &#123; \"key\":\"ctrl+shift+/\", \"command\": \"editor.action.blockComment\", \"when\": \"editorTextFocus\" &#125;, // 定制与 sublime 相同的大小写转换快捷键，需安装 TextTransform 插件 &#123; \"key\": \"ctrl+k ctrl+u\", \"command\": \"uppercase\", \"when\": \"editorTextFocus\" &#125;, &#123; \"key\": \"ctrl+k ctrl+l\", \"command\": \"lowercase\", \"when\": \"editorTextFocus\" &#125;] 前端开发必备插件 PostCSS Sorting stylelint stylefmt ESLint javascript standard format beautify Babel ES6/ES7 Debugger for Chrome Add jsdoc comments javascript(ES6) code snippets vue weex Reactjs code snippets React Native Tools Npm Intellisense Instant Markdown Markdown Shortcuts TextTransform 相关参考官方快捷键","categories":[],"tags":[{"name":"keymap","slug":"keymap","permalink":"http://yoursite.com/tags/keymap/"}]}]}