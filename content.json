{"meta":{"title":"Peony7的博客乐园","subtitle":null,"description":null,"author":"Peony7","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2017-05-04T09:05:26.000Z","updated":"2017-05-04T10:44:29.999Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-05-04T09:05:08.000Z","updated":"2017-05-04T10:44:08.950Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SASS快速入门","slug":"sass-quick-start","date":"2017-09-11T16:00:00.000Z","updated":"2017-09-12T06:17:23.489Z","comments":true,"path":"2017/09/12/sass-quick-start/","link":"","permalink":"http://yoursite.com/2017/09/12/sass-quick-start/","excerpt":"","text":"1. 使用变量;sass让人们受益的一个重要特性就是它为css引入了变量。你可以把反复使用的css属性值 定义成变量，然后通过变量名来引用它们，而无需重复书写这一属性值。或者，对于仅使用过一 次的属性值，你可以赋予其一个易懂的变量名，让人一眼就知道这个属性值的用途。 sass使用$符号来标识变量(老版本的sass使用!来标识变量。改成$是多半因为!highlight-color看起来太丑了。)，比如$highlight-color和$sidebar-width。为什么选择$ 符号呢？因为它好认、更具美感，且在CSS中并无他用，不会导致与现存或未来的css语法冲突。 1-1. 变量声明;sass变量的声明和css属性的声明很像： 1$highlight-color: #F90; 这意味着变量$highlight-color现在的值是#F90。任何可以用作css属性值的赋值都 可以用作sass的变量值，甚至是以空格分割的多个属性值，如$basic-border: 1px solid black;，或以逗号分割的多个属性值，如$plain-font: &quot;Myriad Pro&quot;、Myriad、&quot;Helvetica Neue&quot;、Helvetica、&quot;Liberation Sans&quot;、Arial和sans-serif; sans-serif;。这时变 量还没有生效，除非你引用这个变量——我们很快就会了解如何引用。 与CSS属性不同，变量可以在css规则块定义之外存在。当变量定义在css规则块内，那么该变量只能在此规则块内使用。如果它们出现在任何形式的{...}块中（如@media或者@font-face块），情况也是如此： 12345678910111213$nav-color: #F90;nav &#123; $width: 100px; width: $width; color: $nav-color;&#125;//编译后nav &#123; width: 100px; color: #F90;&#125; 在这段代码中，$nav-color这个变量定义在了规则块外边，所以在这个样式表中都可以像 nav规则块那样引用它。$width这个变量定义在了nav的{ }规则块内，所以它只能在nav规则块 内使用。这意味着是你可以在样式表的其他地方定义和使用$width变量，不会对这里造成影响。 只声明变量其实没啥用处，我们最终的目的还是使用它们。上例已介绍了如何使用 $nav-color和$width这两个变量，接下来我们将进一步探讨变量的使用方法。 1-2. 变量引用;凡是css属性的标准值（比如说1px或者bold）可存在的地方，变量就可以使用。css生成时，变量会被它们的值所替代。之后，如果你需要一个不同的值，只需要改变这个变量的值，则所有引用此变量的地方生成的值都会随之改变。 12345678910$highlight-color: #F90;.selected &#123; border: 1px solid $highlight-color;&#125;//编译后.selected &#123; border: 1px solid #F90;&#125; 看上边示例中的$highlight-color变量，它被直接赋值给border属性，当这段代码被编译输出css时，$highlight-color会被#F90这一颜色值所替代。产生的效果就是给selected这个类一条1像素宽、实心且颜色值为#F90的边框。 在声明变量时，变量值也可以引用其他变量。当你通过粒度区分，为不同的值取不同名字时，这相当有用。下例在独立的颜色值粒度上定义了一个变量，且在另一个更复杂的边框值粒度上也定义了一个变量： 1234567891011$highlight-color: #F90;$highlight-border: 1px solid $highlight-color;.selected &#123; border: $highlight-border;&#125;//编译后.selected &#123; border: 1px solid #F90;&#125; 这里，$highlight-border变量的声明中使用了$highlight-color这个变量。产生的效 果就跟你直接为border属性设置了一个1px $highlight-color solid的值是一样的。 最后，我们来了解一下变量命名的实用技巧，以结束关于变量的介绍。 1-3. 变量名用中划线还是下划线分隔;sass的变量名可以与css中的属性名和选择器名称相同，包括中划线和下划线。这完全取决于个人的喜好，有些人喜欢使用中划线来分隔变量中的多个词（如$highlight-color），而有些人喜欢使用下划线（如$highlight_color）。使用中划线的方式更为普遍，这也是compass和本文都用的方式。 不过，sass并不想强迫任何人一定使用中划线或下划线，所以这两种用法相互兼容。用中划线声明的变量可以使用下划线的方式引用，反之亦然。这意味着即使compass选择用中划线的命名方式，这并不影响你在使用compass的样式中用下划线的命名方式进行引用： 12345678910$link-color: blue;a &#123; color: $link_color;&#125;//编译后a &#123; color: blue;&#125; 在上例中，$link-color和$link_color其实指向的是同一个变量。实际上，在sass的大 多数地方，中划线命名的内容和下划线命名的内容是互通的，除了变量，也包括对混合器和Sass函数的命名。但是在sass中纯css部分不互通，比如类名、ID或属性名。 尽管变量自身提供了很多有用的地方，但是sass基于变量提供的更为强大的工具才是我们关注的焦点。只有当变量与sass的其他特性一起使用时，才能发挥其全部的潜能。接下来，我们将探讨其中一个非常重要的特性，即规则嵌套。 2. 嵌套CSS 规则;css中重复写选择器是非常恼人的。如果要写一大串指向页面中同一块的样式时，往往需要 一遍又一遍地写同一个ID： 123#content article h1 &#123; color: #333 &#125;#content article p &#123; margin-bottom: 1.4em &#125;#content aside &#123; background-color: #EEE &#125; 像这种情况，sass可以让你只写一遍，且使样式可读性更高。在Sass中，你可以像俄罗斯套娃那样在规则块中嵌套规则块。sass在输出css时会帮你把这些嵌套规则处理好，避免你的重复书写。 1234567#content &#123; article &#123; h1 &#123; color: #333 &#125; p &#123; margin-bottom: 1.4em &#125; &#125; aside &#123; background-color: #EEE &#125;&#125; 1234 /* 编译后 */#content article h1 &#123; color: #333 &#125;#content article p &#123; margin-bottom: 1.4em &#125;#content aside &#123; background-color: #EEE &#125; 上边的例子，会在输出css时把它转换成跟你之前看到的一样的效果。这个过程中，sass用了两步，每一步都是像打开俄罗斯套娃那样把里边的嵌套规则块一个个打开。首先，把#content（父级）这个id放到article选择器（子级）和aside选择器（子级）的前边： 1234567#content &#123; article &#123; h1 &#123; color: #333 &#125; p &#123; margin-bottom: 1.4em &#125; &#125; #content aside &#123; background-color: #EEE &#125;&#125; 1234 /* 编译后 */#content article h1 &#123; color: #333 &#125;#content article p &#123; margin-bottom: 1.4em &#125;#content aside &#123; background-color: #EEE &#125; 然后，#content article里边还有嵌套的规则，sass重复一遍上边的步骤，把新的选择器添加到内嵌的选择器前边。 一个给定的规则块，既可以像普通的CSS那样包含属性，又可以嵌套其他规则块。当你同时要为一个容器元素及其子元素编写特定样式时，这种能力就非常有用了。 1234#content &#123; background-color: #f5f5f5; aside &#123; background-color: #eee &#125;&#125; 容器元素的样式规则会被单独抽离出来，而嵌套元素的样式规则会像容器元素没有包含任何属性时那样被抽离出来。 12#content &#123; background-color: #f5f5f5 &#125;#content aside &#123; background-color: #eee &#125; 大多数情况下这种简单的嵌套都没问题，但是有些场景下不行，比如你想要在嵌套的选择器 里边立刻应用一个类似于：hover的伪类。为了解决这种以及其他情况，sass提供了一个特殊结 构&amp;。 2-1. 父选择器的标识符&amp;;一般情况下，sass在解开一个嵌套规则时就会把父选择器（#content）通过一个空格连接到子选择器的前边（article和aside）形成（#content article和#content aside）。这种在CSS里边被称为后代选择器，因为它选择ID为content的元素内所有命中选择器article和aside的元素。但在有些情况下你却不会希望sass使用这种后代选择器的方式生成这种连接。 最常见的一种情况是当你为链接之类的元素写：hover这种伪类时，你并不希望以后代选择器的方式连接。比如说，下面这种情况sass就无法正常工作： 1234article a &#123; color: blue; :hover &#123; color: red &#125;&#125; 这意味着color: red这条规则将会被应用到选择器article a :hover，article元素内链接的所有子元素在被hover时都会变成红色。这是不正确的！你想把这条规则应用到超链接自身，而后代选择器的方式无法帮你实现。 解决之道为使用一个特殊的sass选择器，即父选择器。在使用嵌套规则时，父选择器能对于嵌套规则如何解开提供更好的控制。它就是一个简单的&amp;符号，且可以放在任何一个选择器可出现的地方，比如h1放在哪，它就可以放在哪。 1234article a &#123; color: blue; &amp;:hover &#123; color: red &#125;&#125; 当包含父选择器标识符的嵌套规则被打开时，它不会像后代选择器那样进行拼接，而是&amp;被父选择器直接替换： 12article a &#123; color: blue &#125;article a:hover &#123; color: red &#125; 在为父级选择器添加：hover等伪类时，这种方式非常有用。同时父选择器标识符还有另外一种用法，你可以在父选择器之前添加选择器。举例来说，当用户在使用IE浏览器时，你会通过JavaScript在&lt;body&gt;标签上添加一个ie的类名，为这种情况编写特殊的样式如下： 1234#content aside &#123; color: red; body.ie &amp; &#123; color: green &#125;&#125; 123/*编译后*/#content aside &#123;color: red&#125;;body.ie #content aside &#123; color: green &#125; sass在选择器嵌套上是非常智能的，即使是带有父选择器的情况。当sass遇到群组选择器（由多个逗号分隔开的选择器形成）也能完美地处理这种嵌套。 2-2. 群组选择器的嵌套;在CSS里边，选择器h1``h2和h3会同时命中h1元素、h2元素和h3元素。与此类似，.button button会命中button元素和类名为.button的元素。这种选择器称为群组选择器。群组选择器 的规则会对命中群组中任何一个选择器的元素生效。 123.button, button &#123; margin: 0;&#125; 当看到上边这段代码时，你可能还没意识到会有重复性的工作。但会很快发现：如果你需要在一个特定的容器元素内对这样一个群组选择器进行修饰，情况就不同了。css的写法会让你在群组选择器中的每一个选择器前都重复一遍容器元素的选择器。 1.container h1, .container h2, .container h3 &#123; margin-bottom: .8em &#125; 非常幸运，sass的嵌套特性在这种场景下也非常有用。当sass解开一个群组选择器规则内嵌的规则时，它会把每一个内嵌选择器的规则都正确地解出来： 123.container &#123; h1, h2, h3 &#123;margin-bottom: .8em&#125;&#125; 首先sass将.container和h1``.container和h2``.container和h3分别组合，然后将三 者重新组合成一个群组选择器，生成你前边看到的普通css样式。对于内嵌在群组选择器内的嵌 套规则，处理方式也一样： 123nav, aside &#123; a &#123;color: blue&#125;&#125; 首先sass将nav和a``aside和a分别组合，然后将二者重新组合成一个群组选择器： 1nav a, aside a &#123;color: blue&#125; 处理这种群组选择器规则嵌套上的强大能力，正是sass在减少重复敲写方面的贡献之一。尤其在当嵌套级别达到两层甚至三层以上时，与普通的css编写方式相比，只写一遍群组选择器大大减少了工作量。 有利必有弊，你需要特别注意群组选择器的规则嵌套生成的css。虽然sass让你的样式表看上去很小，但实际生成的css却可能非常大，这会降低网站的速度。 关于选择器嵌套的最后一个方面，我们看看sass如何处理组合选择器，比如&gt;、+和~的使用。你将看到，这种场景下你甚至无需使用父选择器标识符。 2-3. 子组合选择器和同层组合选择器：&gt;、+和~;上边这三个组合选择器必须和其他选择器配合使用，以指定浏览器仅选择某种特定上下文中的元素。 12article section &#123; margin: 5px &#125;article &gt; section &#123; border: 1px solid #ccc &#125; 你可以用子组合选择器&gt;选择一个元素的直接子元素。上例中，第一个选择器会选择article下的所有命中section选择器的元素。第二个选择器只会选择article下紧跟着的子元素中命中section选择器的元素。 在下例中，你可以用同层相邻组合选择器+选择header元素后紧跟的p元素： 1header + p &#123; font-size: 1.1em &#125; 你也可以用同层全体组合选择器~，选择所有跟在article后的同层article元素，不管它们之间隔了多少其他元素： 1article ~ article &#123; border-top: 1px dashed #ccc &#125; 这些组合选择器可以毫不费力地应用到sass的规则嵌套中。可以把它们放在外层选择器后边，或里层选择器前边： 123456789article &#123; ~ article &#123; border-top: 1px dashed #ccc &#125; &gt; section &#123; background: #eee &#125; dl &gt; &#123; dt &#123; color: #333 &#125; dd &#123; color: #555 &#125; &#125; nav + &amp; &#123; margin-top: 0 &#125;&#125; sass会如你所愿地将这些嵌套规则一一解开组合在一起： 12345article ~ article &#123; border-top: 1px dashed #ccc &#125;article &gt; footer &#123; background: #eee &#125;article dl &gt; dt &#123; color: #333 &#125;article dl &gt; dd &#123; color: #555 &#125;nav + article &#123; margin-top: 0 &#125; 在sass中，不仅仅css规则可以嵌套，对属性进行嵌套也可以减少很多重复性的工作。 2-4. 嵌套属性;在sass中，除了CSS选择器，属性也可以进行嵌套。尽管编写属性涉及的重复不像编写选择器那么糟糕，但是要反复写border-style``border-width``border-color以及border-*等也是非常烦人的。在sass中，你只需敲写一遍border： 1234567nav &#123; border: &#123; style: solid; width: 1px; color: #ccc; &#125;&#125; 嵌套属性的规则是这样的：把属性名从中划线-的地方断开，在根属性后边添加一个冒号:，紧跟一个{ }块，把子属性部分写在这个{ }块中。就像css选择器嵌套一样，sass会把你的子属性一一解开，把根属性和子属性部分通过中划线-连接起来，最后生成的效果与你手动一遍遍写的css样式一样： 12345nav &#123; border-style: solid; border-width: 1px; border-color: #ccc;&#125; 对于属性的缩写形式，你甚至可以像下边这样来嵌套，指明例外规则： 123456nav &#123; border: 1px solid #ccc &#123; left: 0px; right: 0px; &#125;&#125; 这比下边这种同等样式的写法要好： 12345nav &#123; border: 1px solid #ccc; border-left: 0px; border-right: 0px;&#125; 属性和选择器嵌套是非常伟大的特性，因为它们不仅大大减少了你的编写量，而且通过视觉上的缩进使你编写的样式结构更加清晰，更易于阅读和开发。 即便如此，随着你的样式表变得越来越大，这种写法也很难保持结构清晰。有时，处理这种大量样式的唯一方法就是把它们分拆到多个文件中。sass通过对css原有@import规则的改进直接支持了这一特性。 3. 导入SASS文件;css有一个特别不常用的特性，即@import规则，它允许在一个css文件中导入其他css文件。然而，后果是只有执行到@import时，浏览器才会去下载其他css文件，这导致页面加载起来特别慢。 sass也有一个@import规则，但不同的是，sass的@import规则在生成css文件时就把相关文件导入进来。这意味着所有相关的样式被归纳到了同一个css文件中，而无需发起额外的下载请求。另外，所有在被导入文件中定义的变量和混合器（参见2.5节）均可在导入文件中使用。 使用sass的@import规则并不需要指明被导入文件的全名。你可以省略.sass或.scss文件后缀（见下图）。这样，在不修改样式表的前提下，你完全可以随意修改你或别人写的被导入的sass样式文件语法，在sass和scss语法之间随意切换。举例来说，@import“sidebar”;这条命令将把sidebar.scss文件中所有样式添加到当前样式表中。 {% image https://www.sass.hk/images/p1.png 'img' '' %} 本节将介绍如何使用sass的@import来处理多个sass文件。首先，我们将学习编写那些被导入的sass文件，因为在一个大型sass项目中，这样的文件是你最常编写的那一类。接着，了解集中导入sass文件的方法，使你的样式可重用性更高，包括声明可自定义的变量值，以及在某一个选择器范围内导入sass文件。最后，介绍如何在sass中使用css原生的@import命令。 通常，有些sass文件用于导入，你并不希望为每个这样的文件单独地生成一个css文件。对此，sass用一个特殊的约定来解决。 3-1. 使用SASS部分文件;当通过@import把sass样式分散到多个文件时，你通常只想生成少数几个css文件。那些专门为@import命令而编写的sass文件，并不需要生成对应的独立css文件，这样的sass文件称为局部文件。对此，sass有一个特殊的约定来命名这些文件。 此约定即，sass局部文件的文件名以下划线开头。这样，sass就不会在编译时单独编译这个文件输出css，而只把这个文件用作导入。当你@import一个局部文件时，还可以不写文件的全名，即省略文件名开头的下划线。举例来说，你想导入themes/_night-sky.scss这个局部文件里的变量，你只需在样式表中写@import &quot;themes/night-sky&quot;;。 局部文件可以被多个不同的文件引用。当一些样式需要在多个页面甚至多个项目中使用时，这非常有用。在这种情况下，有时需要在你的样式表中对导入的样式稍作修改，sass有一个功能刚好可以解决这个问题，即默认变量值。 3-2. 默认变量值;一般情况下，你反复声明一个变量，只有最后一处声明有效且它会覆盖前边的值。举例说明： 12345$link-color: blue;$link-color: red;a &#123;color: $link-color;&#125; 在上边的例子中，超链接的color会被设置为red。这可能并不是你想要的结果，假如你写了一个可被他人通过@import导入的sass库文件，你可能希望导入者可以定制修改sass库文件中的某些值。使用sass的!default标签可以实现这个目的。它很像css属性中!important标签的对立面，不同的是!default用于变量，含义是：如果这个变量被声明赋值了，那就用它声明的值，否则就用这个默认值。 1234$fancybox-width: 400px !default;.fancybox &#123;width: $fancybox-width;&#125; 在上例中，如果用户在导入你的sass局部文件之前声明了一个$fancybox-width变量，那么你的局部文件中对$fancybox-width赋值400px的操作就无效。如果用户没有做这样的声明，则$fancybox-width将默认为400px。 接下来我们将学习嵌套导入，它允许只在某一个选择器的范围内导入sass局部文件。 3-3. 嵌套导入;跟原生的css不同，sass允许@import命令写在css规则内。这种导入方式下，生成对应的css文件时，局部文件会被直接插入到css规则内导入它的地方。举例说明，有一个名为_blue-theme.scss的局部文件，内容如下： 1234aside &#123; background: blue; color: white;&#125; 然后把它导入到一个CSS规则内，如下所示： 12345678910.blue-theme &#123;@import \"blue-theme\"&#125;//生成的结果跟你直接在.blue-theme选择器内写_blue-theme.scss文件的内容完全一样。.blue-theme &#123; aside &#123; background: blue; color: #fff; &#125;&#125; 被导入的局部文件中定义的所有变量和混合器，也会在这个规则范围内生效。这些变量和混合器不会全局有效，这样我们就可以通过嵌套导入只对站点中某一特定区域运用某种颜色主题或其他通过变量配置的样式。 有时，可用css原生的@import机制，在浏览器中下载必需的css文件。sass也提供了几种方法来达成这种需求。 3-4. 原生的CSS导入;由于sass兼容原生的css，所以它也支持原生的CSS@import。尽管通常在sass中使用@import时，sass会尝试找到对应的sass文件并导入进来，但在下列三种情况下会生成原生的CSS@import，尽管这会造成浏览器解析css时的额外下载： 被导入文件的名字以.css结尾； 被导入文件的名字是一个URL地址（比如http://www.sass.hk/css/css.css），由此可用谷歌字体API提供的相应服务； 被导入文件的名字是CSS的url()值。 这就是说，你不能用sass的@import直接导入一个原始的css文件，因为sass会认为你想用css原生的@import。但是，因为sass的语法完全兼容css，所以你可以把原始的css文件改名为.scss后缀，即可直接导入了。 文件导入是保证sass的代码可维护性和可读性的重要一环。次之但亦非常重要的就是注释了。注释可以帮助样式作者记录写sass的过程中的想法。在原生的css中，注释对于其他人是直接可见的，但sass提供了一种方式可在生成的css文件中按需抹掉相应的注释。 4. 静默注释;css中注释的作用包括帮助你组织样式、以后你看自己的代码时明白为什么这样写，以及简单的样式说明。但是，你并不希望每个浏览网站源码的人都能看到所有注释。 sass另外提供了一种不同于css标准注释格式/* ... */的注释语法，即静默注释，其内容不会出现在生成的css文件中。静默注释的语法跟JavaScript``Java等类C的语言中单行注释的语法相同，它们以//开头，注释内容直到行末。 1234body &#123; color: #333; // 这种注释内容不会出现在生成的css文件中 padding: 0; /* 这种注释内容会出现在生成的css文件中 */&#125; 实际上，css的标准注释格式/* ... */内的注释内容亦可在生成的css文件中抹去。当注释出现在原生css不允许的地方，如在css属性或选择器中，sass将不知如何将其生成到对应css文件中的相应位置，于是这些注释被抹掉。 1234body &#123; color /* 这块注释内容不会出现在生成的css中 */: #333; padding: 1; /* 这块注释内容也不会出现在生成的css中 */ 0;&#125; 你已经掌握了sass的静默注释，了解了保持sass条理性和可读性的最基本的三个方法：嵌套、导入和注释。现在，我们要进一步学习新特性，这样我们不但能保持条理性还能写出更好的样式。首先要介绍的内容是：使用混合器抽象你的相关样式。 5. 混合器;如果你的整个网站中有几处小小的样式类似（例如一致的颜色和字体），那么使用变量来统一处理这种情况是非常不错的选择。但是当你的样式变得越来越复杂，你需要大段大段的重用样式的代码，独立的变量就没办法应付这种情况了。你可以通过sass的混合器实现大段样式的重用。 混合器使用@mixin标识符定义。看上去很像其他的CSS @标识符，比如说@media或者@font-face。这个标识符给一大段样式赋予一个名字，这样你就可以轻易地通过引用这个名字重用这段样式。下边的这段sass代码，定义了一个非常简单的混合器，目的是添加跨浏览器的圆角边框。 12345@mixin rounded-corners &#123; -moz-border-radius: 5px; -webkit-border-radius: 5px; border-radius: 5px;&#125; 然后就可以在你的样式表中通过@include来使用这个混合器，放在你希望的任何地方。@include调用会把混合器中的所有样式提取出来放在@include被调用的地方。如果像下边这样写： 1234567notice &#123; background-color: green; border: 2px solid #00aa00; @include rounded-corners;&#125;//sass最终生成： 1234567.notice &#123; background-color: green; border: 2px solid #00aa00; -moz-border-radius: 5px; -webkit-border-radius: 5px; border-radius: 5px;&#125; 在.notice中的属性border-radius``-moz-border-radius和-webkit-border-radius全部来自rounded-corners这个混合器。这一节将介绍使用混合器来避免重复。通过使用参数，你可以使用混合器把你样式中的通用样式抽离出来，然后轻松地在其他地方重用。实际上，混合器太好用了，一不小心你可能会过度使用。大量的重用可能会导致生成的样式表过大，导致加载缓慢。所以，首先我们将讨论混合器的使用场景，避免滥用。 5-1. 何时使用混合器;利用混合器，可以很容易地在样式表的不同地方共享样式。如果你发现自己在不停地重复一段样式，那就应该把这段样式构造成优良的混合器，尤其是这段样式本身就是一个逻辑单元，比如说是一组放在一起有意义的属性。 判断一组属性是否应该组合成一个混合器，一条经验法则就是你能否为这个混合器想出一个好的名字。如果你能找到一个很好的短名字来描述这些属性修饰的样式，比如rounded-corners``fancy-font或者no-bullets，那么往往能够构造一个合适的混合器。如果你找不到，这时候构造一个混合器可能并不合适。 混合器在某些方面跟css类很像。都是让你给一大段样式命名，所以在选择使用哪个的时候可能会产生疑惑。最重要的区别就是类名是在html文件中应用的，而混合器是在样式表中应用的。这就意味着类名具有语义化含义，而不仅仅是一种展示性的描述：用来描述html元素的含义而不是html元素的外观。而另一方面，混合器是展示性的描述，用来描述一条css规则应用之后会产生怎样的效果。 在之前的例子中，.notice是一个有语义的类名。如果一个html元素有一个notice的类名，就表明了这个html元素的用途：向用户展示提醒信息。rounded-corners混合器是展示性的，它描述了包含它的css规则最终的视觉样式，尤其是边框角的视觉样式。混合器和类配合使用写出整洁的html和css，因为使用语义化的类名亦可以帮你避免重复使用混合器。为了保持你的html和css的易读性和可维护性，在写样式的过程中一定要铭记二者的区别。 有时候仅仅把属性放在混合器中还远远不够，可喜的是，sass同样允许你把css规则放在混合器中。 5-2. 混合器中的CSS规则;混合器中不仅可以包含属性，也可以包含css规则，包含选择器和选择器中的属性，如下代码: 12345678@mixin no-bullets &#123; list-style: none; li &#123; list-style-image: none; list-style-type: none; margin-left: 0px; &#125;&#125; 当一个包含css规则的混合器通过@include包含在一个父规则中时，在混合器中的规则最终会生成父规则中的嵌套规则。举个例子，看看下边的sass代码，这个例子中使用了no-bullets这个混合器： 1234ul.plain &#123; color: #444; @include no-bullets;&#125; sass的@include指令会将引入混合器的那行代码替换成混合器里边的内容。最终，上边的例子如下代码: 123456789ul.plain &#123; color: #444; list-style: none;&#125;ul.plain li &#123; list-style-image: none; list-style-type: none; margin-left: 0px;&#125; 混合器中的规则甚至可以使用sass的父选择器标识符&amp;。使用起来跟不用混合器时一样，sass解开嵌套规则时，用父规则中的选择器替代&amp;。 如果一个混合器只包含css规则，不包含属性，那么这个混合器就可以在文档的顶部调用，写在所有的css规则之外。如果你只是为自己写一些混合器，这并没有什么大的用途，但是当你使用一个类似于Compass的库时，你会发现，这是提供样式的好方法，原因在于你可以选择是否使用这些样式。 接下来你将学习如何通过给混合器传参数来让混合器变得更加灵活和可重用。 5-3. 给混合器传参;混合器并不一定总得生成相同的样式。可以通过在@include混合器时给混合器传参，来定制混合器生成的精确样式。当@include混合器时，参数其实就是可以赋值给css属性值的变量。如果你写过JavaScript，这种方式跟JavaScript的function很像： 12345@mixin link-colors($normal, $hover, $visited) &#123; color: $normal; &amp;:hover &#123; color: $hover; &#125; &amp;:visited &#123; color: $visited; &#125;&#125; 当混合器被@include时，你可以把它当作一个css函数来传参。如果你像下边这样写： 123456789a &#123; @include link-colors(blue, red, green);&#125;//Sass最终生成的是：a &#123; color: blue; &#125;a:hover &#123; color: red; &#125;a:visited &#123; color: green; &#125; 当你@include混合器时，有时候可能会很难区分每个参数是什么意思，参数之间是一个什么样的顺序。为了解决这个问题，sass允许通过语法$name: value的形式指定每个参数的值。这种形式的传参，参数顺序就不必再在乎了，只需要保证没有漏掉参数即可： 1234567a &#123; @include link-colors( $normal: blue, $visited: green, $hover: red );&#125; 尽管给混合器加参数来实现定制很好，但是有时有些参数我们没有定制的需要，这时候也需要赋值一个变量就变成很痛苦的事情了。所以sass允许混合器声明时给参数赋默认值。 5-4. 默认参数值;为了在@include混合器时不必传入所有的参数，我们可以给参数指定一个默认值。参数默认值使用$name: default-value的声明形式，默认值可以是任何有效的css属性值，甚至是其他参数的引用，如下代码： 12345678910@mixin link-colors( $normal, $hover: $normal, $visited: $normal )&#123; color: $normal; &amp;:hover &#123; color: $hover; &#125; &amp;:visited &#123; color: $visited; &#125;&#125; 如果像下边这样调用：@include link-colors(red) $hover和$visited也会被自动赋值为red。 混合器只是sass样式重用特性中的一个。我们已经了解到混合器主要用于样式展示层的重用，如果你想重用语义化的类呢？这就涉及sass的另一个重要的重用特性：选择器继承。 6. 使用选择器继承来精简CSS;使用sass的时候，最后一个减少重复的主要特性就是选择器继承。基于Nicole Sullivan面向对象的css的理念，选择器继承是说一个选择器可以继承为另一个选择器定义的所有样式。这个通过@extend语法实现，如下代码: 123456789//通过选择器继承继承样式.error &#123; border: 1px solid red; background-color: #fdd;&#125;.seriousError &#123; @extend .error; border-width: 3px;&#125; 在上边的代码中，.seriousError将会继承样式表中任何位置处为.error定义的所有样式。以class=&quot;seriousError&quot; 修饰的html元素最终的展示效果就好像是class=&quot;seriousError error&quot;。相关元素不仅会拥有一个3px宽的边框，而且这个边框将变成红色的，这个元素同时还会有一个浅红色的背景，因为这些都是在.error里边定义的样式。 .seriousError不仅会继承.error自身的所有样式，任何跟.error有关的组合选择器样式也会被.seriousError以组合选择器的形式继承，如下代码: 12345678//.seriousError从.error继承样式.error a&#123; //应用到.seriousError a color: red; font-weight: 100;&#125;h1.error &#123; //应用到hl.seriousError font-size: 1.2rem;&#125; 如上所示，在class=&quot;seriousError&quot;的html元素内的超链接也会变成红色和粗体。 本节将介绍与混合器相比，哪种情况下更适合用继承。接下来在探索继承的工作细节之前，我们先了解一下继承的高级用法。最后，我们将看看使用继承可能会有哪些坑，学习如何避免这些坑。 6-1. 何时使用继承;5-1节介绍了混合器主要用于展示性样式的重用，而类名用于语义化样式的重用。因为继承是基于类的（有时是基于其他类型的选择器），所以继承应该是建立在语义化的关系上。当一个元素拥有的类（比如说.seriousError）表明它属于另一个类（比如说.error），这时使用继承再合适不过了。 这有点抽象，所以我们从几个方面来阐释一下。想象一下你正在编写一个页面，给html元素添加类名，你发现你的某个类（比如说.seriousError）另一个类（比如说.error）的细化。你会怎么做？ 你可以为这两个类分别写相同的样式，但是如果有大量的重复怎么办？使用sass时，我们提倡的就是不要做重复的工作。 你可以使用一个选择器组（比如说.error``.seriousError）给这两个选择器写相同的样式。如果.error的所有样式都在同一个地方，这种做法很好，但是如果是分散在样式表的不同地方呢？再这样做就困难多了。 你可以使用一个混合器为这两个类提供相同的样式，但当.error的样式修饰遍布样式表中各处时，这种做法面临着跟使用选择器组一样的问题。这两个类也不是恰好有相同的 样式。你应该更清晰地表达这种关系。 综上所述你应该使用@extend。让.seriousError从.error继承样式，使两者之间的关系非常清晰。更重要的是无论你在样式表的哪里使用.error``.seriousError都会继承其中的样式。 现在你已经更好地掌握了何时使用继承，以及继承有哪些突出的优点，接下来我们看看一些高级用法。 6-2. 继承的高级用法;任何css规则都可以继承其他规则，几乎任何css规则也都可以被继承。大多数情况你可能只想对类使用继承，但是有些场合你可能想做得更多。最常用的一种高级用法是继承一个html元素的样式。尽管默认的浏览器样式不会被继承，因为它们不属于样式表中的样式，但是你对html元素添加的所有样式都会被继承。 接下来的这段代码定义了一个名为disabled的类，样式修饰使它看上去像一个灰掉的超链接。通过继承a这一超链接元素来实现： 1234.disabled &#123; color: gray; @extend a;&#125; 假如一条样式规则继承了一个复杂的选择器，那么它只会继承这个复杂选择器命中的元素所应用的样式。举例来说， 如果.seriousError``@extend``.important.error ， 那么.important.error 和h1.important.error 的样式都会被.seriousError继承， 但是.important或者.error下的样式则不会被继承。这种情况下你很可能希望.seriousError能够分别继承.important或者.error下的样式。 如果一个选择器序列（#main .seriousError）@extend另一个选择器（.error），那么只有完全匹配#main .seriousError这个选择器的元素才会继承.error的样式，就像单个类 名继承那样。拥有class=&quot;seriousError&quot;的#main元素之外的元素不会受到影响。 像#main .error这种选择器序列是不能被继承的。这是因为从#main .error中继承的样式一般情况下会跟直接从.error中继承的样式基本一致，细微的区别往往使人迷惑。 现在你已经了解了通过继承能够做些什么事情，接下来我们将学习继承的工作细节，在生成对应css的时候，sass具体干了些什么事情。 6-3. 继承的工作细节;跟变量和混合器不同，继承不是仅仅用css样式替换@extend处的代码那么简单。为了不让你对生成的css感觉奇怪，对这背后的工作原理有一定了解是非常重要的。 @extend背后最基本的想法是，如果.seriousError @extend .error， 那么样式表中的任何一处.error都用.error``.seriousError这一选择器组进行替换。这就意味着相关样式会如预期那样应用到.error和.seriousError。当.error出现在复杂的选择器中，比如说h1.error``.error a或者#main .sidebar input.error[type=&quot;text&quot;]，那情况就变得复杂多了，但是不用担心，sass已经为你考虑到了这些。 关于@extend有两个要点你应该知道。 跟混合器相比，继承生成的css代码相对更少。因为继承仅仅是重复选择器，而不会重复属性，所以使用继承往往比混合器生成的css体积更小。如果你非常关心你站点的速度，请牢记这一点。 继承遵从css层叠的规则。当两个不同的css规则应用到同一个html元素上时，并且这两个不同的css规则对同一属性的修饰存在不同的值，css层叠规则会决定应用哪个样式。相当直观：通常权重更高的选择器胜出，如果权重相同，定义在后边的规则胜出。 混合器本身不会引起css层叠的问题，因为混合器把样式直接放到了css规则中，而继承存在样式层叠的问题。被继承的样式会保持原有定义位置和选择器权重不变。通常来说这并不会引起什么问题，但是知道这点总没有坏处。 6-4. 使用继承的最佳实践;通常使用继承会让你的css美观、整洁。因为继承只会在生成css时复制选择器，而不会复制大段的css属性。但是如果你不小心，可能会让生成的css中包含大量的选择器复制。 避免这种情况出现的最好方法就是不要在css规则中使用后代选择器（比如.foo .bar）去继承css规则。如果你这么做，同时被继承的css规则有通过后代选择器修饰的样式，生成css中的选择器的数量很快就会失控： 12.foo .bar &#123; @extend .baz; &#125;.bip .baz &#123; a: b; &#125; 在上边的例子中，sass必须保证应用到.baz的样式同时也要应用到.foo .bar（位于class=”foo”的元素内的class=”bar”的元素）。例子中有一条应用到.bip .baz（位于class=”bip”的元素内的class=”baz”的元素）的css规则。当这条规则应用到.foo .bar时，可能存在三种情况，如下代码: 1234567891011121314151617&lt;!-- 继承可能迅速变复杂 --&gt;&lt;!-- Case 1 --&gt;&lt;div class=\"foo\"&gt; &lt;div class=\"bip\"&gt; &lt;div class=\"bar\"&gt;...&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- Case 2 --&gt;&lt;div class=\"bip\"&gt; &lt;div class=\"foo\"&gt; &lt;div class=\"bar\"&gt;...&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- Case 3 --&gt;&lt;div class=\"foo bip\"&gt; &lt;div class=\"bar\"&gt;...&lt;/div&gt;&lt;/div&gt; 为了应付这些情况，sass必须生成三种选择器组合（仅仅是.bip .foo .bar不能覆盖所有情况）。如果任何一条规则里边的后代选择器再长一点，sass需要考虑的情况就会更多。实际上sass并不总是会生成所有可能的选择器组合，即使是这样，选择器的个数依然可能会变得相当大，所以如果允许，尽可能避免这种用法。 值得一提的是，只要你想，你完全可以放心地继承有后代选择器修饰规则的选择器，不管后代选择器多长，但有一个前提就是，不要用后代选择器去继承。 7. 小结;本文介绍了sass最基本部分,你可以轻松地使用sass编写清晰、无冗余、语义化的css。对于sass提供的工具你已经有了一个比较深入的了解，同时也掌握了何时使用这些工具的指导原则。 变量是sass提供的最基本的工具。通过变量可以让独立的css值变得可重用，无论是在一条单独的规则范围内还是在整个样式表中。变量、混合器的命名甚至sass的文件名，可以互换通用_和-。同样基础的是sass的嵌套机制。嵌套允许css规则内嵌套css规则，减少重复编写常用的选择器，同时让样式表的结构一眼望去更加清晰。sass同时提供了特殊的父选择器标识符&amp;，通过它可以构造出更高效的嵌套。 你也已经学到了sass的另一个重要特性，样式导入。通过样式导入可以把分散在多个sass文件中的内容合并生成到一个css文件，避免了项目中有大量的css文件通过原生的css @import带来的性能问题。通过嵌套导入和默认变量值，导入可以构建更强有力的、可定制的样式。混合器允许用户编写语义化样式的同时避免视觉层面上样式的重复。你不仅学到了如何使用混合器减少重复，同时学习到了如何使用混合器让你的css变得更加可维护和语义化。最后，我们学习了与混合器相辅相成的选择器继承。继承允许你声明类之间语义化的关系，通过这些关系可以保持你的css的整洁和可维护性。 https://www.sass.hk/guide/ 官网网址","categories":[{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"SASS中文文档","slug":"sass-document","date":"2017-09-11T16:00:00.000Z","updated":"2017-09-12T06:21:56.288Z","comments":true,"path":"2017/09/12/sass-document/","link":"","permalink":"http://yoursite.com/2017/09/12/sass-document/","excerpt":"","text":"Sass (Syntactically Awesome StyleSheets)Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。使用 Sass 以及 Sass 的样式库（如 Compass）有助于更好地组织管理样式文件，以及更高效地开发项目。 1. 特色功能 (Features) 完全兼容 CSS3 在 CSS 基础上增加变量、嵌套 (nesting)、混合 (mixins) 等功能 通过函数进行颜色值与属性值的运算 提供控制指令 (control directives)等高级功能 自定义输出格式 2. 语法格式 (Syntax)Sass 有两种语法格式。首先是 SCSS (Sassy CSS) —— 也是本文示例所使用的格式 —— 这种格式仅在 CSS3 语法的基础上进行拓展，所有 CSS3 语法在 SCSS 中都是通用的，同时加入 Sass 的特色功能。此外，SCSS 也支持大多数 CSS hacks 写法以及浏览器前缀写法 (vendor-specific syntax)，以及早期的 IE 滤镜写法。这种格式以.scss 作为拓展名。 另一种也是最早的 Sass 语法格式，被称为缩进格式 (Indented Sass) 通常简称 “Sass”，是一种简化格式。它使用 “缩进” 代替 “花括号” 表示属性属于某个选择器，用 “换行” 代替 “分号” 分隔属性，很多人认为这样做比 SCSS 更容易阅读，书写也更快速。缩进格式也可以使用 Sass 的全部功能，只是与 SCSS 相比个别地方采取了不同的表达方式，具体请查看 the indented syntax reference。这种格式以 .sass 作为拓展名。 任何一种格式可以直接 导入 (@import) 到另一种格式中使用，或者通过 sass-convert 命令行工具转换成另一种格式： 12345# Convert Sass to SCSS$ sass-convert style.sass style.scss# Convert SCSS to Sass$ sass-convert style.scss style.sass 3. 使用 Sass (Using Sass)Sass 可以通过以下三种方式使用：作为命令行工具；作为独立的 Ruby 模块 (Ruby module)；或者作为 Rack-enabled 框架的插件（例如 Ruby on Rails 与 Merb）。无论哪种方式都需要先安装 Sass gem （Windows 系统需要先安装 Ruby）： 1gem install sass 在命令行中运行 Sass： 1sass input.scss output.css 监视单个 Sass 文件，每次修改并保存时自动编译： 1sass --watch input.scss:output.css 监视整个文件夹： 1sass --watch app/sass:public/stylesheets 更多命令的用法请通过 sass --help 获取帮助。 在 Ruby 中使用 Sass 也非常容易，Sass gem 安装完毕后运行 require &quot;sass&quot; 然后按照下面的方法使用 Sass::Engine： 12engine = Sass::Engine.new(&quot;#main &#123;background-color: #0000ff&#125;&quot;, :syntax =&gt; :scss)engine.render #=&gt; &quot;#main &#123; background-color: #0000ff; &#125;\\n&quot; 3.1. Rack/Rails/Merb Plugin在 Rails 3 之前的版本中使用 Sass，需要在 environment.rb 文件中添加： 1config.gem &quot;sass&quot; Rails 3 则需要在 Gemfile 中添加： 1gem &quot;sass&quot; 在 Merb 中使用 Sass，需要在 config/dependencies.rb 中添加： 1dependency &quot;merb-haml&quot; 在 Rack 中使用 Sass，需要在 config.ru 中添加： 12require &apos;sass/plugin/rack&apos;use Sass::Plugin::Rack 样式文件与 views 不同，不包含任何动态内容，因此 CSS 只需要在 Sass 文件被修改后再编译生成。默认情况下 .sass 与 .scss 文件放置在 public/stylesheets/sass中（可通过 :template_location 修改路径），编译生成的 CSS 文件放置在 public/stylesheets 中。例如 public/stylesheets/sass/main.scss 编译生成public/stylesheets/main.css。 3.2. 缓存 (Caching)Sass 自动缓存编译后的模板与 partials，这样做能够显著提升重新编译的速度，尤其在处理由 @import 导入多个子文件的大型项目时。 单独使用 Sass，缓存内容保存在 .sass-cache 文件夹中。在 Rails 和 Merb 项目中缓存文件保存在 tmp/sass-cache 文件夹中（可通过 :cache_location 修改路径）。禁用缓存可将 :cache 设为 false。 3.3. 配置选项 (Options)暂未翻译 3.4. 判断语法格式 (Syntax Selection)Sass 命令行工具根据文件的拓展名判断所使用的语法格式，没有文件名时 sass 命令默认编译 .sass 文件，添加 --scss 选项或者使用 scss 命令编译 SCSS 文件。 3.5. 编码格式 (Encodings)在 Ruby 1.9 及以上环境中运行 Sass 时，Sass 对文件的编码格式比较敏感，首先会根据 CSS spec 判断样式文件的编码格式，如果失败则检测 Ruby string encoding。也就是说，Sass 首先检查 Unicode byte order mark，然后是 @charset 声明，最后是 Ruby string encoding，假如都没有检测到，默认使用 UTF-8 编码。 与 CSS 相同，使用 @charset 可以声明特定的编码格式。在样式文件的起始位置（前面没有任何空白与注释）插入 @charset &quot;encoding-name&quot;， Sass 将会按照给出的编码格式编译文件。注意所使用的编码格式必须可转换为 Unicode 字符集。 Sass 以 UTF-8 编码输出 CSS 文件，当且仅当编译后的文件中包含非 ASCII 字符时，才会在输出文件中添加 @charset 声明，而在压缩模式下 (compressed mode) 使用 UTF-8 byte order mark 代替 @charset 声明语句。 4. CSS 功能拓展 (CSS Extensions)4.1. 嵌套规则 (Nested Rules)Sass 允许将一套 CSS 样式嵌套进另一套样式中，内层的样式将它外层的选择器作为父选择器，例如： 123456789#main p &#123; color: #00ff00; width: 97%; .redbox &#123; background-color: #ff0000; color: #000000; &#125;&#125; 编译为 123456#main p &#123; color: #00ff00; width: 97%; &#125; #main p .redbox &#123; background-color: #ff0000; color: #000000; &#125; 嵌套功能避免了重复输入父选择器，而且令复杂的 CSS 结构更易于管理： 12345678910#main &#123; width: 97%; p, div &#123; font-size: 2em; a &#123; font-weight: bold; &#125; &#125; pre &#123; font-size: 3em; &#125;&#125; 编译为 12345678#main &#123; width: 97%; &#125; #main p, #main div &#123; font-size: 2em; &#125; #main p a, #main div a &#123; font-weight: bold; &#125; #main pre &#123; font-size: 3em; &#125; 4.2. 父选择器 &amp; (Referencing Parent Selectors: &amp;)在嵌套 CSS 规则时，有时也需要直接使用嵌套外层的父选择器，例如，当给某个元素设定 hover 样式时，或者当 body 元素有某个 classname 时，可以用 &amp; 代表嵌套规则外层的父选择器。 123456a &#123; font-weight: bold; text-decoration: none; &amp;:hover &#123; text-decoration: underline; &#125; body.firefox &amp; &#123; font-weight: normal; &#125;&#125; 编译为 1234567a &#123; font-weight: bold; text-decoration: none; &#125; a:hover &#123; text-decoration: underline; &#125; body.firefox a &#123; font-weight: normal; &#125; 编译后的 CSS 文件中 &amp; 将被替换成嵌套外层的父选择器，如果含有多层嵌套，最外层的父选择器会一层一层向下传递： 1234567#main &#123; color: black; a &#123; font-weight: bold; &amp;:hover &#123; color: red; &#125; &#125;&#125; 编译为 123456#main &#123; color: black; &#125; #main a &#123; font-weight: bold; &#125; #main a:hover &#123; color: red; &#125; &amp; 必须作为选择器的第一个字符，其后可以跟随后缀生成复合的选择器，例如 1234#main &#123; color: black; &amp;-sidebar &#123; border: 1px solid; &#125;&#125; 编译为 1234#main &#123; color: black; &#125; #main-sidebar &#123; border: 1px solid; &#125; 当父选择器含有不合适的后缀时，Sass 将会报错。 4.3. 属性嵌套 (Nested Properties)有些 CSS 属性遵循相同的命名空间 (namespace)，比如 font-family, font-size, font-weight 都以 font 作为属性的命名空间。为了便于管理这样的属性，同时也为了避免了重复输入，Sass 允许将属性嵌套在命名空间中，例如： 1234567.funky &#123; font: &#123; family: fantasy; size: 30em; weight: bold; &#125;&#125; 编译为 1234.funky &#123; font-family: fantasy; font-size: 30em; font-weight: bold; &#125; 命名空间也可以包含自己的属性值，例如： 123456.funky &#123; font: 20px/24px &#123; family: fantasy; weight: bold; &#125;&#125; 编译为 1234.funky &#123; font: 20px/24px; font-family: fantasy; font-weight: bold; &#125; 4.4. 占位符选择器 %foo (Placeholder Selectors: %foo)Sass 额外提供了一种特殊类型的选择器：占位符选择器 (placeholder selector)。与常用的 id 与 class 选择器写法相似，只是 # 或 . 替换成了 %。必须通过 @extend 指令调用，更多介绍请查阅 @extend-Only Selectors。 当占位符选择器单独使用时（未通过 @extend 调用），不会编译到 CSS 文件中。 5. 注释 /* */ 与 // (Comments: /* */ and //)Sass 支持标准的 CSS 多行注释 /* */，以及单行注释 //，前者会 被完整输出到编译后的 CSS 文件中，而后者则不会，例如： 12345678910/* This comment is * several lines long. * since it uses the CSS comment syntax, * it will appear in the CSS output. */body &#123; color: black; &#125;// These comments are only one line long each.// They won&apos;t appear in the CSS output,// since they use the single-line comment syntax.a &#123; color: green; &#125; 编译为 123456789/* This comment is * several lines long. * since it uses the CSS comment syntax, * it will appear in the CSS output. */body &#123; color: black; &#125;a &#123; color: green; &#125; 将 ! 作为多行注释的第一个字符表示在压缩输出模式下保留这条注释并输出到 CSS 文件中，通常用于添加版权信息。 插值语句 (interpolation) 也可写进多行注释中输出变量值： 12$version: &quot;1.2.3&quot;;/* This CSS is generated by My Snazzy Framework version #&#123;$version&#125;. */ 编译为 1/* This CSS is generated by My Snazzy Framework version 1.2.3. */ 6. SassScript在 CSS 属性的基础上 Sass 提供了一些名为 SassScript 的新功能。 SassScript 可作用于任何属性，允许属性使用变量、算数运算等额外功能。 通过 interpolation，SassScript 甚至可以生成选择器或属性名，这一点对编写 mixin 有很大帮助。 6.1. Interactive ShellInteractive Shell 可以在命令行中测试 SassScript 的功能。在命令行中输入 sass -i，然后输入想要测试的 SassScript 查看输出结果： 123456789$ sass -i&gt;&gt; &quot;Hello, Sassy World!&quot;&quot;Hello, Sassy World!&quot;&gt;&gt; 1px + 1px + 1px3px&gt;&gt; #777 + #777#eeeeee&gt;&gt; #777 + #888white 6.2. 变量 $ (Variables: $)SassScript 最普遍的用法就是变量，变量以美元符号开头，赋值方法与 CSS 属性的写法一样： 1$width: 5em; 直接使用即调用变量： 123#main &#123; width: $width;&#125; 变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。将局部变量转换为全局变量可以添加 !global 声明： 12345678#main &#123; $width: 5em !global; width: $width;&#125;#sidebar &#123; width: $width;&#125; 编译为 1234567#main &#123; width: 5em;&#125;#sidebar &#123; width: 5em;&#125; 6.3. 数据类型 (Data Types)SassScript 支持 6 种主要的数据类型： 数字，1, 2, 13, 10px 字符串，有引号字符串与无引号字符串，&quot;foo&quot;, &#39;bar&#39;, baz 颜色，blue, #04a3f9, rgba(255,0,0,0.5) 布尔型，true, false 空值，null 数组 (list)，用空格或逗号作分隔符，1.5em 1em 0 2em, Helvetica, Arial, sans-serif maps, 相当于 JavaScript 的 object，(key1: value1, key2: value2) SassScript 也支持其他 CSS 属性值，比如 Unicode 字符集，或 !important 声明。然而Sass 不会特殊对待这些属性值，一律视为无引号字符串。 6.3.1. 字符串 (Strings)SassScript 支持 CSS 的两种字符串类型：有引号字符串 (quoted strings)，如 &quot;Lucida Grande&quot; &#39;http://sass-lang.com&#39;；与无引号字符串 (unquoted strings)，如sans-serif bold，在编译 CSS 文件时不会改变其类型。只有一种情况例外，使用 #{} (interpolation) 时，有引号字符串将被编译为无引号字符串，这样便于在 mixin 中引用选择器名： 123456@mixin firefox-message($selector) &#123; body.firefox #&#123;$selector&#125;:before &#123; content: &quot;Hi, Firefox users!&quot;; &#125;&#125;@include firefox-message(&quot;.header&quot;); 编译为 12body.firefox .header:before &#123; content: &quot;Hi, Firefox users!&quot;; &#125; 6.3.2. 数组 (Lists)数组 (lists) 指 Sass 如何处理 CSS 中 margin: 10px 15px 0 0 或者 font-face: Helvetica, Arial, sans-serif 这样通过空格或者逗号分隔的一系列的值。事实上，独立的值也被视为数组 —— 只包含一个值的数组。 数组本身没有太多功能，但 Sass list functions 赋予了数组更多新功能：nth 函数可以直接访问数组中的某一项；join 函数可以将多个数组连接在一起；append 函数可以在数组中添加新值；而 @each 指令能够遍历数组中的每一项。 数组中可以包含子数组，比如 1px 2px, 5px 6px 是包含 1px 2px 与 5px 6px 两个数组的数组。如果内外两层数组使用相同的分隔方式，需要用圆括号包裹内层，所以也可以写成 (1px 2px) (5px 6px)。变化是，之前的 1px 2px, 5px 6px 使用逗号分割了两个子数组 (comma-separated)，而 (1px 2px) (5px 6px) 则使用空格分割(space-separated)。 当数组被编译为 CSS 时，Sass 不会添加任何圆括号（CSS 中没有这种写法），所以 (1px 2px) (5px 6px) 与 1px 2px, 5px 6px 在编译后的 CSS 文件中是完全一样的，但是它们在 Sass 文件中却有不同的意义，前者是包含两个数组的数组，而后者是包含四个值的数组。 用 () 表示不包含任何值的空数组（在 Sass 3.3 版之后也视为空的 map）。空数组不可以直接编译成 CSS，比如编译 font-family: () Sass 将会报错。如果数组中包含空数组或空值，编译时将被清除，比如 1px 2px () 3px 或 1px 2px null 3px。 基于逗号分隔的数组允许保留结尾的逗号，这样做的意义是强调数组的结构关系，尤其是需要声明只包含单个值的数组时。例如 (1,) 表示只包含 1 的数组，而 (1 2 3,) 表示包含 1 2 3 这个以空格分隔的数组的数组。 6.3.3. MapsMaps represent an association between keys and values, where keys are used to look up values. They make it easy to collect values into named groups and access those groups dynamically. They have no direct parallel in CSS, although they’re syntactically similar to media query expressions: 1scss $map: (key1: value1, key2: value2, key3: value3); Unlike lists, maps must always be surrounded by parentheses and must always be comma-separated. Both the keys and values in maps can be any SassScript object. A map may only have one value associated with a given key (although that value may be a list). A given value may be associated with many keys, though. Like lists, maps are mostly manipulated using SassScript functions. The map-get function looks up values in a map and the map-merge function adds values to a map. The @each directive can be used to add styles for each key/value pair in a map. The order of pairs in a map is always the same as when the map was created. Maps can also be used anywhere lists can. When used by a list function, a map is treated as a list of pairs. For example, (key1: value1, key2: value2) would be treated as the nested list key1 value1, key2 value2 by list functions. Lists cannot be treated as maps, though, with the exception of the empty list. () represents both a map with no key/value pairs and a list with no elements. Note that map keys can be any Sass data type (even another map) and the syntax for declaring a map allows arbitrary SassScript expressions that will be evaluated to determine the key. Maps cannot be converted to plain CSS. Using one as the value of a variable or an argument to a CSS function will cause an error. Use the inspect($value) function to produce an output string useful for debugging maps. 6.3.4. 颜色 (Colors)Any CSS color expression returns a SassScript Color value. This includes a large number of named colors which are indistinguishable from unquoted strings. In compressed output mode, Sass will output the smallest CSS representation of a color. For example, #FF0000 will output as red in compressed mode, but blanchedalmond will output as #FFEBCD. A common issue users encounter with named colors is that since Sass prefers the same output format as was typed in other output modes, a color interpolated into a selector becomes invalid syntax when compressed. To avoid this, always quote named colors if they are meant to be used in the construction of a selector. 6.4. 运算 (Operations)所有数据类型均支持相等运算 1== 或 1!= ，此外，每种数据类型也有其各自支持的运算方式。 6.4.1. 数字运算 (Number Operations)SassScript 支持数字的加减乘除、取整等运算 (+, -, *, /, %)，如果必要会在不同单位间转换值。 123p &#123; width: 1in + 8pt;&#125; 编译为 12p &#123; width: 1.111in; &#125; 关系运算 &lt;, &gt;, &lt;=, &gt;= 也可用于数字运算，相等运算 ==, != 可用于所有数据类型。 6.4.1.1. 除法运算 / (Division and /)/ 在 CSS 中通常起到分隔数字的用途，SassScript 作为 CSS 语言的拓展当然也支持这个功能，同时也赋予了 / 除法运算的功能。也就是说，如果 / 在 SassScript 中把两个数字分隔，编译后的 CSS 文件中也是同样的作用。 以下三种情况 / 将被视为除法运算符号： 如果值，或值的一部分，是变量或者函数的返回值 如果值被圆括号包裹 如果值是算数表达式的一部分 12345678p &#123; font: 10px/8px; // Plain CSS, no division $width: 1000px; width: $width/2; // Uses a variable, does division width: round(1.5)/2; // Uses a function, does division height: (500px/2); // Uses parentheses, does division margin-left: 5px + 8px/2px; // Uses +, does division&#125; 编译为 12345p &#123; font: 10px/8px; width: 500px; height: 250px; margin-left: 9px; &#125; 如果需要使用变量，同时又要确保 / 不做除法运算而是完整地编译到 CSS 文件中，只需要用 #{} 插值语句将变量包裹。 12345p &#123; $font-size: 12px; $line-height: 30px; font: #&#123;$font-size&#125;/#&#123;$line-height&#125;;&#125; 编译为 12p &#123; font: 12px/30px; &#125; 6.4.2. 颜色值运算 (Color Operations)颜色值的运算是分段计算进行的，也就是分别计算红色，绿色，以及蓝色的值： 123p &#123; color: #010203 + #040506;&#125; 计算 01 + 04 = 05 02 + 05 = 07 03 + 06 = 09，然后编译为 12p &#123; color: #050709; &#125; 使用 color functions 比计算颜色值更方便一些。 数字与颜色值之间也可以进行算数运算，同样也是分段计算的，比如 123p &#123; color: #010203 * 2;&#125; 计算 01 * 2 = 02 02 * 2 = 04 03 * 2 = 06，然后编译为 12p &#123; color: #020406; &#125; 需要注意的是，如果颜色值包含 alpha channel（rgba 或 hsla 两种颜色值），必须拥有相等的 alpha 值才能进行运算，因为算术运算不会作用于 alpha 值。 123p &#123; color: rgba(255, 0, 0, 0.75) + rgba(0, 255, 0, 0.75);&#125; 编译为 12p &#123; color: rgba(255, 255, 0, 0.75); &#125; 颜色值的 alpha channel 可以通过 opacify 或 transparentize 两个函数进行调整。 12345$translucent-red: rgba(255, 0, 0, 0.5);p &#123; color: opacify($translucent-red, 0.3); background-color: transparentize($translucent-red, 0.25);&#125; 编译为 123p &#123; color: rgba(255, 0, 0, 0.8); background-color: rgba(255, 0, 0, 0.25); &#125; IE 滤镜要求所有的颜色值包含 alpha 层，而且格式必须固定 #AABBCCDD，使用 ie_hex_str 函数可以很容易地将颜色转化为 IE 滤镜要求的格式。 12345$translucent-red: rgba(255, 0, 0, 0.5);$green: #00ff00;div &#123; filter: progid:DXImageTransform.Microsoft.gradient(enabled=&apos;false&apos;, startColorstr=&apos;#&#123;ie-hex-str($green)&#125;&apos;, endColorstr=&apos;#&#123;ie-hex-str($translucent-red)&#125;&apos;);&#125; 编译为 123div &#123; filter: progid:DXImageTransform.Microsoft.gradient(enabled=&apos;false&apos;, startColorstr=#FF00FF00, endColorstr=#80FF0000);&#125; 6.4.3. 字符串运算 (String Operations)+ 可用于连接字符串 123p &#123; cursor: e + -resize;&#125; 编译为 12p &#123; cursor: e-resize; &#125; 注意，如果有引号字符串（位于 + 左侧）连接无引号字符串，运算结果是有引号的，相反，无引号字符串（位于 + 左侧）连接有引号字符串，运算结果则没有引号。 1234p:before &#123; content: &quot;Foo &quot; + Bar; font-family: sans- + &quot;serif&quot;;&#125; 编译为 123p:before &#123; content: &quot;Foo Bar&quot;; font-family: sans-serif; &#125; 运算表达式与其他值连用时，用空格做连接符： 123p &#123; margin: 3px + 4px auto;&#125; 编译为 12p &#123; margin: 7px auto; &#125; 在有引号的文本字符串中使用 #{} 插值语句可以添加动态的值： 123p:before &#123; content: &quot;I ate #&#123;5 + 10&#125; pies!&quot;;&#125; 编译为 12p:before &#123; content: &quot;I ate 15 pies!&quot;; &#125; 空的值被视作插入了空字符串： 1234$value: null;p:before &#123; content: &quot;I ate #&#123;$value&#125; pies!&quot;;&#125; 编译为 12p:before &#123; content: &quot;I ate pies!&quot;; &#125; 6.4.4. 布尔运算 (Boolean Operations)SassScript 支持布尔型的 and or 以及 not 运算。 6.4.5. 数组运算 (List Operations)数组不支持任何运算方式，只能使用 list functions 控制。 6.5. 圆括号 (Parentheses)圆括号可以用来影响运算的顺序： 123p &#123; width: 1em + (2em * 3);&#125; 编译为 12p &#123; width: 7em; &#125; 6.6. 函数 (Functions)SassScript 定义了多种函数，有些甚至可以通过普通的 CSS 语句调用： 123p &#123; color: hsl(0, 100%, 50%);&#125; 编译为 12p &#123; color: #ff0000; &#125; 6.6.1. 关键词参数 (Keyword Arguments)Sass 函数允许使用关键词参数 (keyword arguments)，上面的例子也可以写成： 123p &#123; color: hsl($hue: 0, $saturation: 100%, $lightness: 50%);&#125; 虽然不够简明，但是阅读起来会更方便。关键词参数给函数提供了更灵活的接口，以及容易调用的参数。关键词参数可以打乱顺序使用，如果使用默认值也可以省缺，另外，参数名被视为变量名，下划线、短横线可以互换使用。 通过 Sass::Script::Functions 查看完整的 Sass 函数列表，参数名，以及如何自定义函数。 6.7. 插值语句 #{} (Interpolation: #{})通过 #{} 插值语句可以在选择器或属性名中使用变量： 12345$name: foo;$attr: border;p.#&#123;$name&#125; &#123; #&#123;$attr&#125;-color: blue;&#125; 编译为 12p.foo &#123; border-color: blue; &#125; #{} 插值语句也可以在属性值中插入 SassScript，大多数情况下，这样可能还不如使用变量方便，但是使用 #{} 可以避免 Sass 运行运算表达式，直接编译 CSS。 12345p &#123; $font-size: 12px; $line-height: 30px; font: #&#123;$font-size&#125;/#&#123;$line-height&#125;;&#125; 编译为 12p &#123; font: 12px/30px; &#125; 6.8. &amp; in SassScriptJust like when it’s used in selectors, &amp; in SassScript refers to the current parent selector. It’s a comma-separated list of space-separated lists. For example: 123.foo.bar .baz.bang, .bip.qux &#123; $selector: &amp;;&#125; The value of $selector is now ((“.foo.bar” “.baz.bang”), “.bip.qux”). The compound selectors are quoted here to indicate that they’re strings, but in reality they would be unquoted. Even if the parent selector doesn’t contain a comma or a space, &amp; will always have two levels of nesting, so it can be accessed consistently. If there is no parent selector, the value of &amp; will be null. This means you can use it in a mixin to detect whether a parent selector exists: 1234567891011@mixin does-parent-exist &#123; @if &amp; &#123; &amp;:hover &#123; color: red; &#125; &#125; @else &#123; a &#123; color: red; &#125; &#125;&#125; 6.9. 变量定义 !default (Variable Defaults: !default)可以在变量的结尾添加 !default 给一个未通过 !default 声明赋值的变量赋值，此时，如果变量已经被赋值，不会再被重新赋值，但是如果变量还没有被赋值，则会被赋予新的值。 12345678$content: &quot;First content&quot;;$content: &quot;Second content?&quot; !default;$new_content: &quot;First time reference&quot; !default;#main &#123; content: $content; new-content: $new_content;&#125; 编译为 123#main &#123; content: &quot;First content&quot;; new-content: &quot;First time reference&quot;; &#125; 变量是 null 空值时将视为未被 !default 赋值。 123456$content: null;$content: &quot;Non-null content&quot; !default;#main &#123; content: $content;&#125; 编译为 12#main &#123; content: &quot;Non-null content&quot;; &#125; 7. @-Rules 与指令 (@-Rules and Directives)Sass 支持所有的 CSS3 @-Rules，以及 Sass 特有的 “指令”（directives）。这一节会详细解释，更多资料请查看 控制指令 (control directives) 与 混合指令 (mixin directives) 两个部分。 7.1. @importSass 拓展了 @import 的功能，允许其导入 SCSS 或 Sass 文件。被导入的文件将合并编译到同一个 CSS 文件中，另外，被导入的文件中所包含的变量或者混合指令 (mixin) 都可以在导入的文件中使用。 Sass 在当前地址，或 Rack, Rails, Merb 的 Sass 文件地址寻找 Sass 文件，如果需要设定其他地址，可以用 :load_paths 选项，或者在命令行中输入 --load-path 命令。 通常，@import 寻找 Sass 文件并将其导入，但在以下情况下，@import 仅作为普通的 CSS 语句，不会导入任何 Sass 文件。 文件拓展名是 .css； 文件名以 http:// 开头； 文件名是 url()； @import 包含 media queries。 如果不在上述情况内，文件的拓展名是 .scss 或 .sass，则导入成功。没有指定拓展名，Sass 将会试着寻找文件名相同，拓展名为 .scss 或 .sass 的文件并将其导入。 1@import &quot;foo.scss&quot;; 或 1@import &quot;foo&quot;; 都会导入文件 foo.scss，但是 1234@import &quot;foo.css&quot;;@import &quot;foo&quot; screen;@import &quot;http://foo.com/bar&quot;;@import url(foo); 编译为 1234@import &quot;foo.css&quot;;@import &quot;foo&quot; screen;@import &quot;http://foo.com/bar&quot;;@import url(foo); Sass 允许同时导入多个文件，例如同时导入 rounded-corners 与 text-shadow 两个文件： 1@import &quot;rounded-corners&quot;, &quot;text-shadow&quot;; 导入文件也可以使用 #{ } 插值语句，但不是通过变量动态导入 Sass 文件，只能作用于 CSS 的 url() 导入方式： 12$family: unquote(&quot;Droid+Sans&quot;);@import url(&quot;http://fonts.googleapis.com/css?family=\\#&#123;$family&#125;&quot;); 编译为 1@import url(&quot;http://fonts.googleapis.com/css?family=Droid+Sans&quot;); 7.1.1. 分音 (Partials)如果需要导入 SCSS 或者 Sass 文件，但又不希望将其编译为 CSS，只需要在文件名前添加下划线，这样会告诉 Sass 不要编译这些文件，但导入语句中却不需要添加下划线。 例如，将文件命名为 _colors.scss，便不会编译 _colours.css 文件。 1@import &quot;colors&quot;; 上面的例子，导入的其实是 _colors.scss 文件 注意，不可以同时存在添加下划线与未添加下划线的同名文件，添加下划线的文件将会被忽略。 7.1.2. 嵌套 @import大多数情况下，一般在文件的最外层（不在嵌套规则内）使用 @import，其实，也可以将 @import 嵌套进 CSS 样式或者 @media 中，与平时的用法效果相同，只是这样导入的样式只能出现在嵌套的层中。 假设 example.scss 文件包含以下样式： 123.example &#123; color: red;&#125; 然后导入到 #main 样式内 123#main &#123; @import &quot;example&quot;;&#125; 将会被编译为 123#main .example &#123; color: red;&#125; Directives that are only allowed at the base level of a document, like @mixin or @charset, are not allowed in files that are @imported in a nested context. 这一句不理解 不可以在混合指令 (mixin) 或控制指令 (control directives) 中嵌套 @import。 7.2. @mediaSass 中 @media 指令与 CSS 中用法一样，只是增加了一点额外的功能：允许其在 CSS 规则中嵌套。如果 @media 嵌套在 CSS 规则内，编译时，@media 将被编译到文件的最外层，包含嵌套的父选择器。这个功能让 @media 用起来更方便，不需要重复使用选择器，也不会打乱 CSS 的书写流程。 123456.sidebar &#123; width: 300px; @media screen and (orientation: landscape) &#123; width: 500px; &#125;&#125; 编译为 12345.sidebar &#123; width: 300px; &#125; @media screen and (orientation: landscape) &#123; .sidebar &#123; width: 500px; &#125; &#125; @media 的 queries 允许互相嵌套使用，编译时，Sass 自动添加 and 1234567@media screen &#123; .sidebar &#123; @media (orientation: landscape) &#123; width: 500px; &#125; &#125;&#125; 编译为 123@media screen and (orientation: landscape) &#123; .sidebar &#123; width: 500px; &#125; &#125; @media 甚至可以使用 SassScript（比如变量，函数，以及运算符）代替条件的名称或者值： 123456789$media: screen;$feature: -webkit-min-device-pixel-ratio;$value: 1.5;@media #&#123;$media&#125; and ($feature: $value) &#123; .sidebar &#123; width: 500px; &#125;&#125; 编译为 123@media screen and (-webkit-min-device-pixel-ratio: 1.5) &#123; .sidebar &#123; width: 500px; &#125; &#125; 7.3. @extend在设计网页的时候常常遇到这种情况：一个元素使用的样式与另一个元素完全相同，但又添加了额外的样式。通常会在 HTML 中给元素定义两个 class，一个通用样式，一个特殊样式。假设现在要设计一个普通错误样式与一个严重错误样式，一般会这样写： 123&lt;div class=&quot;error seriousError&quot;&gt; Oh no! You&apos;ve been hacked!&lt;/div&gt; 样式如下 1234567.error &#123; border: 1px #f00; background-color: #fdd;&#125;.seriousError &#123; border-width: 3px;&#125; 麻烦的是，这样做必须时刻记住使用 .seriousError 时需要参考 .error 的样式，带来了很多不变：智能比如加重维护负担，导致 bug，或者给 HTML 添加无语意的样式。使用 @extend 可以避免上述情况，告诉 Sass 将一个选择器下的所有样式继承给另一个选择器。 12345678.error &#123; border: 1px #f00; background-color: #fdd;&#125;.seriousError &#123; @extend .error; border-width: 3px;&#125; 上面代码的意思是将 .error 下的所有样式继承给 .seriousError，border-width: 3px; 是单独给 .seriousError 设定特殊样式，这样，使用 .seriousError 的地方可以不再使用 .error。 其他使用到 .error 的样式也会同样继承给 .seriousError，例如，另一个样式 .error.intrusion 使用了 hacked.png 做背景，&lt;div class=&quot;seriousError intrusion&quot;&gt; 也同样会使用 hacked.png 背景。 123.error.intrusion &#123; background-image: url(&quot;/image/hacked.png&quot;);&#125; 7.3.1. How it Works@extend 的作用是将重复使用的样式 (.error) 延伸 (extend) 给需要包含这个样式的特殊样式（.seriousError），刚刚的例子： 1234567891011.error &#123; border: 1px #f00; background-color: #fdd;&#125;.error.intrusion &#123; background-image: url(&quot;/image/hacked.png&quot;);&#125;.seriousError &#123; @extend .error; border-width: 3px;&#125; 编译为 123456789.error, .seriousError &#123; border: 1px #f00; background-color: #fdd; &#125;.error.intrusion, .seriousError.intrusion &#123; background-image: url(&quot;/image/hacked.png&quot;); &#125;.seriousError &#123; border-width: 3px; &#125; 当合并选择器时，@extend 会很聪明地避免无谓的重复，.seriousError.seriousError 将编译为 .seriousError，不能匹配任何元素的选择器（比如 #main#footer ）也会删除。 7.3.2. 延伸复杂的选择器 (Extending Complex Selectors)Class 选择器并不是唯一可以被延伸 (extend) 的，Sass 允许延伸任何定义给单个元素的选择器，比如 .special.cool，a:hover 或者 a.user[href^=&quot;http://&quot;] 等，例如： 123.hoverlink &#123; @extend a:hover;&#125; 同 class 元素一样，a:hover 的样式将继承给 .hoverlink。 123456.hoverlink &#123; @extend a:hover;&#125;a:hover &#123; text-decoration: underline;&#125; 编译为 12a:hover, .hoverlink &#123; text-decoration: underline; &#125; 与上面 .error.intrusion 的例子一样，所有 a:hover 的样式将继承给 .hoverlink，包括其他使用到 a:hover 的样式，例如： 123456.hoverlink &#123; @extend a:hover;&#125;.comment a.user:hover &#123; font-weight: bold;&#125; 编译为 12.comment a.user:hover, .comment .user.hoverlink &#123; font-weight: bold; &#125; 7.3.3. 多重延伸 (Multiple Extends)同一个选择器可以延伸给多个选择器，它所包含的属性将继承给所有被延伸的选择器： 12345678910111213.error &#123; border: 1px #f00; background-color: #fdd;&#125;.attention &#123; font-size: 3em; background-color: #ff0;&#125;.seriousError &#123; @extend .error; @extend .attention; border-width: 3px;&#125; 编译为 12345678910.error, .seriousError &#123; border: 1px #f00; background-color: #fdd; &#125;.attention, .seriousError &#123; font-size: 3em; background-color: #ff0; &#125;.seriousError &#123; border-width: 3px; &#125; 每个 .seriousError 将包含 .error 与 .attention 下的所有样式，这时，后定义的样式享有优先权：.seriousError 的背景颜色是 #ff0 而不是 #fdd，因为.attention 在 .error 之后定义。 多重延伸可以使用逗号分隔选择器名，比如 @extend .error, .attention; 与 @extend .error; @extend.attention 有相同的效果。 7.3.4. 继续延伸 (Chaining Extends)当一个选择器延伸给第二个后，可以继续将第二个选择器延伸给第三个，例如： 12345678910111213141516.error &#123; border: 1px #f00; background-color: #fdd;&#125;.seriousError &#123; @extend .error; border-width: 3px;&#125;.criticalError &#123; @extend .seriousError; position: fixed; top: 10%; bottom: 10%; left: 10%; right: 10%;&#125; 现在，每个 .seriousError 选择器将包含 .error 的样式，而 .criticalError 不仅包含 .seriousError 的样式也会同时包含 .error 的所有样式，上面的代码编译为： 12345678910111213.error, .seriousError, .criticalError &#123; border: 1px #f00; background-color: #fdd; &#125;.seriousError, .criticalError &#123; border-width: 3px; &#125;.criticalError &#123; position: fixed; top: 10%; bottom: 10%; left: 10%; right: 10%; &#125; 7.3.5. 选择器列 (Selector Sequences)暂时不可以将选择器列 (Selector Sequences)，比如 .foo .bar 或 .foo + .bar，延伸给其他元素，但是，却可以将其他元素延伸给选择器列： 12345678910#fake-links .link &#123; @extend a;&#125;a &#123; color: blue; &amp;:hover &#123; text-decoration: underline; &#125;&#125; 编译为 1234a, #fake-links .link &#123; color: blue; &#125; a:hover, #fake-links .link:hover &#123; text-decoration: underline; &#125; 7.3.5.1. 合并选择器列 (Merging Selector Sequences)有时会遇到复杂的情况，比如选择器列中的某个元素需要延伸给另一个选择器列，这种情况下，两个选择器列需要合并，比如： 123456#admin .tabbar a &#123; font-weight: bold;&#125;#demo .overview .fakelink &#123; @extend a;&#125; 技术上讲能够生成所有匹配条件的结果，但是这样生成的样式表太复杂了，上面这个简单的例子就可能有 10 种结果。所以，Sass 只会编译输出有用的选择器。 当两个列 (sequence) 合并时，如果没有包含相同的选择器，将生成两个新选择器：第一列出现在第二列之前，或者第二列出现在第一列之前： 123456#admin .tabbar a &#123; font-weight: bold;&#125;#demo .overview .fakelink &#123; @extend a;&#125; 编译为 1234#admin .tabbar a,#admin .tabbar #demo .overview .fakelink,#demo .overview #admin .tabbar .fakelink &#123; font-weight: bold; &#125; 如果两个列 (sequence) 包含了相同的选择器，相同部分将会合并在一起，其他部分交替输出。在下面的例子里，两个列都包含 #admin，输出结果中它们合并在了一起： 123456#admin .tabbar a &#123; font-weight: bold;&#125;#admin .overview .fakelink &#123; @extend a;&#125; 编译为 1234#admin .tabbar a,#admin .tabbar .overview .fakelink,#admin .overview .tabbar .fakelink &#123; font-weight: bold; &#125; 7.3.6. @extend-Only 选择器 (@extend-Only Selectors)有时，需要定义一套样式并不是给某个元素用，而是只通过 @extend 指令使用，尤其是在制作 Sass 样式库的时候，希望 Sass 能够忽略用不到的样式。 如果使用普通的 CSS 规则，最后会编译出很多用不到的样式，也容易与其他样式名冲突，所以，Sass 引入了“占位符选择器” (placeholder selectors)，看起来很像普通的id 或 class 选择器，只是 # 或 . 被替换成了 %。可以像 class 或者 id 选择器那样使用，当它们单独使用时，不会被编译到 CSS 文件中。 123456// This ruleset won&apos;t be rendered on its own.#context a%extreme &#123; color: blue; font-weight: bold; font-size: 2em;&#125; 占位符选择器需要通过延伸指令使用，用法与 class 或者 id 选择器一样，被延伸后，占位符选择器本身不会被编译。 123.notice &#123; @extend %extreme;&#125; 编译为 1234#context a.notice &#123; color: blue; font-weight: bold; font-size: 2em; &#125; 7.3.7. !optional 声明 (The !optional Flag)如果 @extend 失败会收到错误提示，比如，这样写 a.important {@extend .notice}，当没有 .notice 选择器时，将会报错，只有 h1.notice 包含 .notice 时也会报错，因为 h1 与 a 冲突，会生成新的选择器。 如果要求 @extend 不生成新选择器，可以通过 !optional 声明达到这个目的，例如： 123a.important &#123; @extend .notice !optional;&#125; 7.3.8. 在指令中延伸 (@extend in Directives)在指令中使用 @extend 时（比如在 @media 中）有一些限制：Sass 不可以将 @media 层外的 CSS 规则延伸给指令层内的 CSS，这样会生成大量的无用代码。也就是说，如果在 @media （或者其他 CSS 指令）中使用 @extend，必须延伸给相同指令层中的选择器。 下面的例子是可行的： 12345678910@media print &#123; .error &#123; border: 1px #f00; background-color: #fdd; &#125; .seriousError &#123; @extend .error; border-width: 3px; &#125;&#125; 但不可以这样： 123456789101112.error &#123; border: 1px #f00; background-color: #fdd;&#125;@media print &#123; .seriousError &#123; // INVALID EXTEND: .error is used outside of the &quot;@media print&quot; directive @extend .error; border-width: 3px; &#125;&#125; 希望有一天，浏览器可以原生支持 @extend 指令，这样就可以在任何指令中使用延伸功能，不再受限制了。 7.4. @at-rootThe @at-root directive causes one or more rules to be emitted at the root of the document, rather than being nested beneath their parent selectors. It can either be used with a single inline selector: 1234.parent &#123; ... @at-root .child &#123; ... &#125;&#125; Which would produce: 12.parent &#123; ... &#125;.child &#123; ... &#125; Or it can be used with a block containing multiple selectors: 12345678.parent &#123; ... @at-root &#123; .child1 &#123; ... &#125; .child2 &#123; ... &#125; &#125; .step-child &#123; ... &#125;&#125; Which would output the following: 1234.parent &#123; ... &#125;.child1 &#123; ... &#125;.child2 &#123; ... &#125;.parent .step-child &#123; ... &#125; 7.4.1. @at-root (without: …) and @at-root (with: …)By default, @at-root just excludes selectors. However, it’s also possible to use @at-root to move outside of nested directives such as @media as well. For example: 12345678@media print &#123; .page &#123; width: 8in; @at-root (without: media) &#123; color: red; &#125; &#125;&#125; produces: 12345678@media print &#123; .page &#123; width: 8in; &#125;&#125;.page &#123; color: red;&#125; You can use @at-root (without: …) to move outside of any directive. You can also do it with multiple directives separated by a space: @at-root (without: media supports) moves outside of both @media and @supports queries. There are two special values you can pass to @at-root. “rule” refers to normal CSS rules; @at-root (without: rule) is the same as @at-root with no query. @at-root (without: all) means that the styles should be moved outside of all directives and CSS rules. If you want to specify which directives or rules to include, rather than listing which ones should be excluded, you can use with instead of without. For example, @at-root (with: rule) will move outside of all directives, but will preserve any CSS rules. 7.5. @debugThe @debug directive prints the value of a SassScript expression to the standard error output stream. It’s useful for debugging Sass files that have complicated SassScript going on. For example: 1@debug 10em + 12em; 编译为 1Line 1 DEBUG: 22em 7.6. @warnThe @warn directive prints the value of a SassScript expression to the standard error output stream. It’s useful for libraries that need to warn users of deprecations or recovering from minor mixin usage mistakes. There are two major distinctions between @warn and @debug: You can turn warnings off with the –quiet command-line option or the :quiet Sass option. A stylesheet trace will be printed out along with the message so that the user being warned can see where their styles caused the warning. Usage Example: 1234567891011@mixin adjust-location($x, $y) &#123; @if unitless($x) &#123; @warn &quot;Assuming #&#123;$x&#125; to be in pixels&quot;; $x: 1px * $x; &#125; @if unitless($y) &#123; @warn &quot;Assuming #&#123;$y&#125; to be in pixels&quot;; $y: 1px * $y; &#125; position: relative; left: $x; top: $y;&#125; 7.7. @warnThe @error directive throws the value of a SassScript expression as a fatal error, including a nice stack trace. It’s useful for validating arguments to mixins and functions. For example: 123456789@mixin adjust-location($x, $y) &#123; @if unitless($x) &#123; @error &quot;$x may not be unitless, was #&#123;$x&#125;.&quot;; &#125; @if unitless($y) &#123; @error &quot;$y may not be unitless, was #&#123;$y&#125;.&quot;; &#125; position: relative; left: $x; top: $y;&#125; There is currently no way to catch errors. 8. 控制指令 (Control Directives)SassScript 提供了一些基础的控制指令，比如在满足一定条件时引用样式，或者设定范围重复输出格式。控制指令是一种高级功能，日常编写过程中并不常用到，主要与混合指令 (mixin) 配合使用，尤其是用在 Compass 等样式库中。 8.1. if()The built-in if() function allows you to branch on a condition and returns only one of two possible outcomes. It can be used in any script context. The if function only evaluates the argument corresponding to the one that it will return – this allows you to refer to variables that may not be defined or to have calculations that would otherwise cause an error (E.g. divide by zero). 8.2. @if当 @if 的表达式返回值不是 false 或者 null 时，条件成立，输出 {} 内的代码： 12345p &#123; @if 1 + 1 == 2 &#123; border: 1px solid; &#125; @if 5 &lt; 3 &#123; border: 2px dotted; &#125; @if null &#123; border: 3px double; &#125;&#125; 编译为 12p &#123; border: 1px solid; &#125; @if 声明后面可以跟多个 @else if 声明，或者一个 @else 声明。如果 @if 声明失败，Sass 将逐条执行 @else if 声明，如果全部失败，最后执行 @else 声明，例如： 123456789101112$type: monster;p &#123; @if $type == ocean &#123; color: blue; &#125; @else if $type == matador &#123; color: red; &#125; @else if $type == monster &#123; color: green; &#125; @else &#123; color: black; &#125;&#125; 编译为 12p &#123; color: green; &#125; 8.3. @for@for 指令可以在限制的范围内重复输出格式，每次按要求（变量的值）对输出结果做出变动。这个指令包含两种格式：@for $var from &lt;start&gt; through &lt;end&gt;，或者@for $var from &lt;start&gt; to &lt;end&gt;，区别在于 through 与 to 的含义：当使用 through 时，条件范围包含 与 的值，而使用 to 时条件范围只包含 的值不包含 的值。另外，$var 可以是任何变量，比如 $i；&lt;start&gt; 和 &lt;end&gt; 必须是整数值。 123@for $i from 1 through 3 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;&#125; 编译为 123456.item-1 &#123; width: 2em; &#125;.item-2 &#123; width: 4em; &#125;.item-3 &#123; width: 6em; &#125; 8.4. @each@each 指令的格式是 $var in &lt;list&gt;, $var 可以是任何变量名，比如 $length 或者 $name，而 &lt;list&gt; 是一连串的值，也就是值列表。 @each 将变量 $var 作用于值列表中的每一个项目，然后输出结果，例如： 12345@each $animal in puma, sea-slug, egret, salamander &#123; .#&#123;$animal&#125;-icon &#123; background-image: url(&apos;/images/#&#123;$animal&#125;.png&apos;); &#125;&#125; 编译为 12345678.puma-icon &#123; background-image: url(&apos;/images/puma.png&apos;); &#125;.sea-slug-icon &#123; background-image: url(&apos;/images/sea-slug.png&apos;); &#125;.egret-icon &#123; background-image: url(&apos;/images/egret.png&apos;); &#125;.salamander-icon &#123; background-image: url(&apos;/images/salamander.png&apos;); &#125; 8.4.1 Multiple AssignmentThe @each directive can also use multiple variables, as in @each $var1, $var2, … in . If is a list of lists, each element of the sub-lists is assigned to the respective variable. For example: 123456789@each $animal, $color, $cursor in (puma, black, default), (sea-slug, blue, pointer), (egret, white, move) &#123; .#&#123;$animal&#125;-icon &#123; background-image: url(&apos;/images/#&#123;$animal&#125;.png&apos;); border: 2px solid $color; cursor: $cursor; &#125;&#125; is compiled to: 123456789101112.puma-icon &#123; background-image: url(&apos;/images/puma.png&apos;); border: 2px solid black; cursor: default; &#125;.sea-slug-icon &#123; background-image: url(&apos;/images/sea-slug.png&apos;); border: 2px solid blue; cursor: pointer; &#125;.egret-icon &#123; background-image: url(&apos;/images/egret.png&apos;); border: 2px solid white; cursor: move; &#125; Since maps are treated as lists of pairs, multiple assignment works with them as well. For example: 12345@each $header, $size in (h1: 2em, h2: 1.5em, h3: 1.2em) &#123; #&#123;$header&#125; &#123; font-size: $size; &#125;&#125; is compiled to: 123456h1 &#123; font-size: 2em; &#125;h2 &#123; font-size: 1.5em; &#125;h3 &#123; font-size: 1.2em; &#125; 8.5. @while@while 指令重复输出格式直到表达式返回结果为 false。这样可以实现比 @for 更复杂的循环，只是很少会用到。例如： 12345$i: 6;@while $i &gt; 0 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125; $i: $i - 2;&#125; 12345678.item-6 &#123; width: 12em; &#125;.item-4 &#123; width: 8em; &#125;.item-2 &#123; width: 4em; &#125; 9. 混合指令 (Mixin Directives)混合指令（Mixin）用于定义可重复使用的样式，避免了使用无语意的 class，比如 .float-left。混合指令可以包含所有的 CSS 规则，绝大部分 Sass 规则，甚至通过参数功能引入变量，输出多样化的样式。 9.1. 定义混合指令 @mixin (Defining a Mixin: @mixin)混合指令的用法是在 @mixin 后添加名称与样式，比如名为 large-text 的混合通过下面的代码定义： 12345678@mixin large-text &#123; font: &#123; family: Arial; size: 20px; weight: bold; &#125; color: #ff0000;&#125; 混合也需要包含选择器和属性，甚至可以用 &amp; 引用父选择器： 1234567891011@mixin clearfix &#123; display: inline-block; &amp;:after &#123; content: &quot;.&quot;; display: block; height: 0; clear: both; visibility: hidden; &#125; * html &amp; &#123; height: 1px &#125;&#125; 9.2. 引用混合样式 @include (Including a Mixin: @include)使用 @include 指令引用混合样式，格式是在其后添加混合名称，以及需要的参数（可选）： 12345.page-title &#123; @include large-text; padding: 4px; margin-top: 10px;&#125; 编译为 1234567.page-title &#123; font-family: Arial; font-size: 20px; font-weight: bold; color: #ff0000; padding: 4px; margin-top: 10px; &#125; 也可以在最外层引用混合样式，不会直接定义属性，也不可以使用父选择器。 1234567@mixin silly-links &#123; a &#123; color: blue; background-color: red; &#125;&#125;@include silly-links; 编译为 123a &#123; color: blue; background-color: red; &#125; 混合样式中也可以包含其他混合样式，比如 123456@mixin compound &#123; @include highlighted-background; @include header-text;&#125;@mixin highlighted-background &#123; background-color: #fc0; &#125;@mixin header-text &#123; font-size: 20px; &#125; 混合样式中应该只定义后代选择器，这样可以安全的导入到文件的任何位置。 9.3. 参数 (Arguments)参数用于给混合指令中的样式设定变量，并且赋值使用。在定义混合指令的时候，按照变量的格式，通过逗号分隔，将参数写进圆括号里。引用指令时，按照参数的顺序，再将所赋的值对应写进括号： 12345678@mixin sexy-border($color, $width) &#123; border: &#123; color: $color; width: $width; style: dashed; &#125;&#125;p &#123; @include sexy-border(blue, 1in); &#125; 编译为 1234p &#123; border-color: blue; border-width: 1in; border-style: dashed; &#125; 混合指令也可以使用给变量赋值的方法给参数设定默认值，然后，当这个指令被引用的时候，如果没有给参数赋值，则自动使用默认值： 123456789@mixin sexy-border($color, $width: 1in) &#123; border: &#123; color: $color; width: $width; style: dashed; &#125;&#125;p &#123; @include sexy-border(blue); &#125;h1 &#123; @include sexy-border(blue, 2in); &#125; 编译为 123456789p &#123; border-color: blue; border-width: 1in; border-style: dashed; &#125;h1 &#123; border-color: blue; border-width: 2in; border-style: dashed; &#125; 9.3.1. 关键词参数 (Keyword Arguments)混合指令也可以使用关键词参数，上面的例子也可以写成： 12p &#123; @include sexy-border($color: blue); &#125;h1 &#123; @include sexy-border($color: blue, $width: 2in); &#125; 虽然不够简明，但是阅读起来会更方便。关键词参数给函数提供了更灵活的接口，以及容易调用的参数。关键词参数可以打乱顺序使用，如果使用默认值也可以省缺，另外，参数名被视为变量名，下划线、短横线可以互换使用。 9.3.2. 参数变量 (Variable Arguments)有时，不能确定混合指令需要使用多少个参数，比如一个关于 box-shadow 的混合指令不能确定有多少个 ‘shadow’ 会被用到。这时，可以使用参数变量 … 声明（写在参数的最后方）告诉 Sass 将这些参数视为值列表处理： 12345678@mixin box-shadow($shadows...) &#123; -moz-box-shadow: $shadows; -webkit-box-shadow: $shadows; box-shadow: $shadows;&#125;.shadows &#123; @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999);&#125; 编译为 12345.shadowed &#123; -moz-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; -webkit-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;&#125; 参数变量也可以用在引用混合指令的时候 (@include)，与平时用法一样，将一串值列表中的值逐条作为参数引用： 123456789@mixin colors($text, $background, $border) &#123; color: $text; background-color: $background; border-color: $border;&#125;$values: #ff0000, #00ff00, #0000ff;.primary &#123; @include colors($values...);&#125; 编译为 12345.primary &#123; color: #ff0000; background-color: #00ff00; border-color: #0000ff;&#125; You can use variable arguments to wrap a mixin and add additional styles without changing the argument signature of the mixin. If you do so, even keyword arguments will get passed through to the wrapped mixin. For example: 12345678@mixin wrapped-stylish-mixin($args...) &#123; font-weight: bold; @include stylish-mixin($args...);&#125;.stylish &#123; // The $width argument will get passed on to &quot;stylish-mixin&quot; as a keyword @include wrapped-stylish-mixin(#00ff00, $width: 100px);&#125; 上面注释内的意思是：$width 参数将会传递给 stylish-mixin 作为关键词。 9.4. 向混合样式中导入内容 (Passing Content Blocks to a Mixin)在引用混合样式的时候，可以先将一段代码导入到混合指令中，然后再输出混合样式，额外导入的部分将出现在 @content 标志的地方： 12345678910@mixin apply-to-ie6-only &#123; * html &#123; @content; &#125;&#125;@include apply-to-ie6-only &#123; #logo &#123; background-image: url(/logo.gif); &#125;&#125; 编译为 123* html #logo &#123; background-image: url(/logo.gif);&#125; 为便于书写，@mixin 可以用 = 表示，而 @include 可以用 + 表示，所以上面的例子可以写成： 1234567=apply-to-ie6-only * html @content+apply-to-ie6-only #logo background-image: url(/logo.gif) 注意： 当 @content 在指令中出现过多次或者出现在循环中时，额外的代码将被导入到每一个地方。 9.4.1. Variable Scope and Content Blocks The block of content passed to a mixin are evaluated in the scope where the block is defined, not in the scope of the mixin. This means that variables local to the mixin cannot be used within the passed style block and variables will resolve to the global value: 123456789$color: white;@mixin colors($color: blue) &#123; background-color: $color; @content; border-color: $color;&#125;.colors &#123; @include colors &#123; color: $color; &#125;&#125; 编译为 12345.colors &#123; background-color: blue; color: white; border-color: blue;&#125; Additionally, this makes it clear that the variables and mixins that are used within the passed block are related to the other styles around where the block is defined. For example: 1234567#sidebar &#123; $sidebar-width: 300px; width: $sidebar-width; @include smartphone &#123; width: $sidebar-width / 3; &#125;&#125; 10. 函数指令 (Function Directives)Sass 支持自定义函数，并能在任何属性值或 Sass script 中使用： 12345678$grid-width: 40px;$gutter-width: 10px;@function grid-width($n) &#123; @return $n * $grid-width + ($n - 1) * $gutter-width;&#125;#sidebar &#123; width: grid-width(5); &#125; 编译为 12#sidebar &#123; width: 240px; &#125; 与 mixin 相同，也可以传递若干个全局变量给函数作为参数。一个函数可以含有多条语句，需要调用 @return 输出结果。 自定义的函数也可以使用关键词参数，上面的例子还可以这样写： 1#sidebar &#123; width: grid-width($n: 5); &#125; 建议在自定义函数前添加前缀避免命名冲突，其他人阅读代码时也会知道这不是 Sass 或者 CSS 的自带功能。 自定义函数与 mixin 相同，都支持 variable arguments 11. 输出格式 (Output Style)Sass 默认的 CSS 输出格式很美观也能清晰反映文档结构，为满足其他需求 Sass 也提供了多种输出格式。 Sass 提供了四种输出格式，可以通过 :style option 选项设定，或者在命令行中使用 --style 选项。 11.1. :nestedNested （嵌套）样式是 Sass 默认的输出格式，能够清晰反映 CSS 与 HTML 的结构关系。选择器与属性等单独占用一行，缩进量与 Sass 文件中一致，每行的缩进量反映了其在嵌套规则内的层数。当阅读大型 CSS 文件时，这种样式可以很容易地分析文件的主要结构。 12345678910#main &#123; color: #fff; background-color: #000; &#125; #main p &#123; width: 10em; &#125;.huge &#123; font-size: 10em; font-weight: bold; text-decoration: underline; &#125; 11.2. :expandedExpanded 输出更像是手写的样式，选择器、属性等各占用一行，属性根据选择器缩进，而选择器不做任何缩进。 12345678910111213#main &#123; color: #fff; background-color: #000;&#125;#main p &#123; width: 10em;&#125;.huge &#123; font-size: 10em; font-weight: bold; text-decoration: underline;&#125; 11.3. :compactCompact 输出方式比起上面两种占用的空间更少，每条 CSS 规则只占一行，包含其下的所有属性。嵌套过的选择器在输出时没有空行，不嵌套的选择器会输出空白行作为分隔符。 1234#main &#123; color: #fff; background-color: #000; &#125;#main p &#123; width: 10em; &#125;.huge &#123; font-size: 10em; font-weight: bold; text-decoration: underline; &#125; 11.4. :compressedCompressed 输出方式删除所有无意义的空格、空白行、以及注释，力求将文件体积压缩到最小，同时也会做出其他调整，比如会自动替换占用空间最小的颜色表达方式。 1#main&#123;color:#fff;background-color:#000&#125;#main p&#123;width:10em&#125;.huge&#123;font-size:10em;font-weight:bold;text-decoration:underline&#125; 12. 拓展 Sass (Extending Sass)Sass 提供了很多高级自定义功能，使用这些功能需要有良好的 Ruby 基础。 12.1. 自定义 Sass 函数 (Defining Custom Sass Functions)通过 Ruby API 可以自定义 Sass 函数，具体请查看 source documentation。 12.2. 存储缓存 (Cache Stores)Sass caches parsed documents so that they can be reused without parsing them again unless they have changed. By default, Sass will write these cache files to a location on the filesystem indicated by :cache_location. If you cannot write to the filesystem or need to share cache across ruby processes or machines, then you can define your own cache store and set the:cache_store option. For details on creating your own cache store, please see the source documentation. 12.3. 自定义导入 (Custom Importers)Sass importers are in charge of taking paths passed to @import and finding the appropriate Sass code for those paths. By default, this code is loaded from the filesystem, but importers could be added to load from a database, over HTTP, or use a different file naming scheme than what Sass expects. Each importer is in charge of a single load path (or whatever the corresponding notion is for the backend). Importers can be placed in the :load_paths array alongside normal filesystem paths. When resolving an @import, Sass will go through the load paths looking for an importer that successfully imports the path. Once one is found, the imported file is used. User-created importers must inherit from Sass::Importers::Base. https://www.sass.hk/docs/ 官方网址","categories":[{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"form表单回车提交问题","slug":"html-form-submit","date":"2017-09-10T16:00:00.000Z","updated":"2017-09-11T09:57:39.024Z","comments":true,"path":"2017/09/11/html-form-submit/","link":"","permalink":"http://yoursite.com/2017/09/11/html-form-submit/","excerpt":"","text":"form表单回车提交问题,JS监听回车事件我们有时候希望回车键敲在文本框（input element）里来提交表单（form），但有时候又不希望如此。比如搜索行为，希望输入完关键词之后直接按回车键立即提交表单，而有些复杂表单，可能要避免回车键误操作在未完成表单填写的时候就触发了表单提交。要控制这些行为，不需要借助JS，浏览器已经帮我们做了这些处理，这里总结几条规则： 如果表单里有一个type=”submit”的按钮，回车键生效。 如果表单里只有一个type=”text”的input，不管按钮是什么type，回车键生效。 如果按钮不是用input，而是用button，并且没有加type，IE下默认为type=button，FX默认为type=submit。 其他表单元素如textarea、select不影响，radio checkbox不影响触发规则，但本身在FX下会响应回车键，在IE下不响应。 type=”image”的input，效果等同于type=”submit”，不知道为什么会设计这样一种type，不推荐使用，应该用CSS添加背景图合适些。 我们在处理表单的页面可以检验他是否点击了按钮来控制下面的程序。if($_POST[‘submit’]){ 如果点击了按钮 程序继续}实际应用的时候，要让表单响应回车键很容易，保证表单里有个type=”submit”的按钮就行。而当只有一个文本框又不希望响应回车键怎么办 呢？我的方法有点别扭，就是再写一个无意义的文本框，隐藏起来。根据第3条规则，我们在用button的时候，尽量显式声明type以使浏览器表现一致。 通过以上可知只要把type=”submit”改成type=”button”然后js提交， 在不要有一个type=”text”的input就行了。就不会发生回车跳转。 但实验发现，ie和火狐不一样，火狐的submit按钮有掩藏的（display：block）和显现的都不行，必须全改，但ie只要显现的没有submit就行了。 12345678910111213&lt;script type=\"text/javascript\"&gt; document.onkeydown=keyDownSearch; function keyDownSearch(e) &#123; // 兼容FF和IE和Opera var theEvent = e || window.event; var code = theEvent.keyCode || theEvent.which || theEvent.charCode; if (code == 13) &#123; DoSomeThing();//具体处理函数 return false; &#125; return true; &#125; &lt;/script&gt; 如果只是针对某个DIV层应用回车查询的话，可以将：document.onkeydown=keyDownSearch;改成：document.getElementById(&#39;层ID&#39;).onkeydown=keyDownSearch; http://www.cnblogs.com/suizhikuo/p/4925086.html","categories":[{"name":"html","slug":"html","permalink":"http://yoursite.com/categories/html/"}],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"CSS 实现隐藏滚动条同时又可以滚动","slug":"css-scrollbar","date":"2017-08-24T16:00:00.000Z","updated":"2017-08-25T03:16:01.986Z","comments":true,"path":"2017/08/25/css-scrollbar/","link":"","permalink":"http://yoursite.com/2017/08/25/css-scrollbar/","excerpt":"","text":"CSS 实现隐藏滚动条同时又可以滚动移动端页面为了更接近原生的体验，是否可以隐藏滚动条，同时又保证页面可以滚动？ 使用 overflow:hidden 隐藏滚动条，但存在的问题是：页面或元素失去了滚动的特性。由于只需要兼容移动浏览器（Chrome 和 Safari），于是想到了自定义滚动条的伪对象选择器::-webkit-scrollbar。 关于这个选择器的介绍可以参考：Styling ScrollbarsCustom Scrollbars in WebKit 应用如下 CSS 可以隐藏滚动条： 1.element::-webkit-scrollbar &#123;display:none&#125; 如果要兼容 PC 其他浏览器（IE、Firefox 等），国外一位才人 John Kurlak 也研究出了一种办法。在容器外面再嵌套一层 overflow:hidden 内部内容再限制尺寸和外部嵌套层一样，就变相隐藏了。 123456789101112131415161718192021222324 &lt;div class=&quot;outer-container&quot;&gt; &lt;div class=&quot;inner-container&quot;&gt; &lt;div class=&quot;content&quot;&gt; ...... &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;.outer-container,.content &#123; width: 200px; height: 200px;&#125;.outer-container &#123; position: relative; overflow: hidden;&#125;.inner-container &#123; position: absolute; left: 0; overflow-x: hidden; overflow-y: scroll;&#125; /* for Chrome */.inner-container::-webkit-scrollbar &#123; display: none;&#125; 参考Hiding Vertical Scrollbars with Pure CSS in Chrome, IE (6+), Firefox, Opera, and Safari https://blog.niceue.com/front-end-development/hide-scrollbar-but-still-scrollable-using-css.html","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"scrollbar","slug":"scrollbar","permalink":"http://yoursite.com/tags/scrollbar/"}]},{"title":"viewports","slug":"viewports","date":"2017-08-10T16:00:00.000Z","updated":"2017-08-11T06:39:16.699Z","comments":true,"path":"2017/08/11/viewports/","link":"","permalink":"http://yoursite.com/2017/08/11/viewports/","excerpt":"","text":"原文: http://www.w3cplus.com/css/viewports.html 桌面浏览器的特性screen.width/height(屏幕尺寸) 含义：用户的屏幕的完整大小。 度量：设备的pixels。 兼容性问题：IE8里，不管使用IE7模式还是IE8模式，都以CSS的pixels来度量 window.innerWidth/Height(浏览器尺寸) 含义：包含滚动条尺寸的浏览器完整尺寸 度量：CSS的pixels 兼容性问题：IE不支持，Opera用设备pixels来度量 window.pageX/YOffset(滚动位移) 含义：页面的移位 度量：CSS的pixels 兼容性问题：pageXOffset 和 pageYOffset 在 IE 8 及之前版本的IE不支持, 使用”document.body.scrollLeft” and “document.body.scrollTop” 来取代 document. documentElement. clientWidth/Height(viewport的尺寸) 含义：viewport的尺寸 度量：CSS的pixels 兼容性问题：无 为&lt;html&gt;元素赋值25%。但document. documentElement. clientWidth/Height的值不变。它虽然貌似从&lt;html&gt;元素取值，但实际描述的确是viewport的尺寸。 document. documentElement. offsetWidth/Height(&lt;html&gt;的尺寸) 含义：&lt;html&gt;的尺寸 度量：CSS的pixels 兼容性问题：IE用这个值标示viewport的尺寸而非&lt;html&gt; 如果你为&lt;html&gt;元素赋值了宽度，offsetWidth会真实的反应出来。 pageX/Y, clientX/Y, screenX/Y(事件坐标) 含义：见下文 度量：见下文 兼容性问题：IE不支持pageX/Y,IE使用CSSpixels来度量screanX/Y 详细描述: pageX/Y：从&lt;html&gt;原点到事件触发点的CSS的 pixels clientX/Y：从viewport原点（浏览器窗口）到事件触发点的CSS的 pixels screenX/Y：从用户显示器窗口原点到事件触发点的设备 的 pixels。 mediaqueries(Media查询) 含义：见下文 度量：见下文 兼容性问题：IE不支持. 详情描述: device-width/height使用screen.width/height来做为的判定值。该值以设备的pixels来度量 width/height使用documentElement.clientWidth/Height即viewport的值。该值以CSS的pixels来度量 在桌面浏览器中使用width而忘记device-width 移动设备浏览器的问题两种viewport因此viewport太窄，不能很好为你的基本CSS布局服务了。最显然的解决方式是让viewport更宽。因此这个需求分为了2个方面：虚拟的visualviewport和布局的layoutviewport。 document. documentElement. clientWidth/Height(度量layout viewviewport)的尺寸 含义：layoutviewport尺寸 度量：CSS的pixels 完整支持：Opera, iPhone, Android, Symbian, Bolt, MicroB, Skyfire, Obigo 问题：在Iris上它标示visualvieport 三星的Webkit核心浏览器，仅当在页面上写入&lt;meta viewport&gt;标签，才正确表示。否则就代表着 FireFox以设备的pixels来度量 IE返回1024 x 768 px，而准确的尺寸保存在document.body.clientWidth/Height NetFront仅当100%缩放时候才正确 塞班的Webkit1(在S60v3设备)不支持这些属性 不支持：黑莓 很幸运浏览器由于浏览器大战而遗留给我们2个特性对来度量这两种viewport。 旋转只关系到高度，而不是宽度。 window.innerWidth/Height(度量visual viewport) 含义：visualviewport尺寸 度量：CSS的pixels 完整支持：iPhone, Symbian, BlackBerry 问题： FireFox和Opera以设备的pixels返回该数值 Android, Bolt, MicroB, 和 NetFront 以CSS的pixels返回该数值，且为layoutviewport的值 不支持： IE，它使用document. documentElement. offsetWidh/Height来表示 三星的Webkit核心浏览器，仅当在页面上写入&lt;meta viewport&gt;标签，才正确表示。否则就代表着&lt;html&gt;的尺寸 混乱：Iris, Skyfire, Obigo返回的值不知所云 我们使用window.innerWidth/Height来度量visualviewport。显然，随着用户缩放浏览器，这值会改变，更多、更少的CSS pixels放进了屏幕。很不幸这是一个待完善的部分，许多浏览器依然没有支持对visualviewport的度量。到现在为止，没有浏览器将该度量存储在其他地方，我猜测window.innerWidth/Height会成为标准，albeit是最强力的支持者。 screen.width and screen.height(屏幕尺寸) 含义：屏幕尺寸 度量：设备的pixels 完整支持：Opera Mini, Android, Symbian, Iris, Firefox, MicroB, IE, BlackBerry 问题： Opera在Windows Mobile下只给出横向尺寸(landscape size)。在S60上工作正确。 三星的Webkit核心浏览器，仅当在页面上写入&lt;meta viewport&gt;标签，才正确表示。否则就代表着&lt;html&gt;的尺寸 iPhone和Obigo仅给出竖直尺寸(portrait sizes) Android, Bolt, MicroB, 和 NetFront 以CSS的pixels返回该数值，且为layoutviewport的值 不支持： IE，它使用document. documentElement. offsetWidh/Height来表示 - 三星的Webkit核心浏览器，仅当在页面上写入&lt;meta viewport&gt;标签，才正确表示。否则就代表着&lt;html&gt;的尺寸 混乱：Iris, Skyfire, Obigo返回的值不知所云 和pc浏览器一样，screen.width/height标示了设备屏幕的尺寸，以设备的pixels度量。和pc浏览器一样，作为web开发人员你永远不需要这些信息。你不关心屏幕的物理宽度，而关心当前有多少CSS的pixels能供你使用。 window.pageX/YOffset(滚动位移) 含义：见描述 度量：CSS的pixels 完整支持：iPhone, Android, Symbian, Iris, MicroB, Skyfire, Obigo 问题： Opera, Bolt, Firefox, and NetFront 总是返回 0. 三星的Webkit核心浏览器，仅当在页面上写入标签，才正确表示。 不支持： IE，它使用document. scrollLeft/Top来表示 你同意需要知道当前visualviewport相对于layoutviewport的距离。这就是滚动位移，如同在桌面浏览器一样，使用window.pageX/YOffset存储。 document. documentElement. offsetWidth / Height 含义：html元素的整体尺寸 度量：CSS的pixels 完整支持：Opera, iPhone, Android, Symbian, Samsung, Iris, Bolt, Firefox, MicroB, Skyfire, BlackBerry, Obigo 问题： NetFront只在100%缩放时返回正确的值. IE，使用这个特性对来表示visualviewport的尺寸。它使用document. body. clientWidth/Height来表示 和在桌面系统一样,document.documentElement.offsetWidth/Height给出了 元素以CSS的pixels度量的尺寸。 Mediaqueries(Media查询) 含义：以CSS的pixels度量&lt;html&gt;元素或以设备 的pixels度量设备 完整支持：Opera, iPhone, Android, Symbian, Samsung, Iris, Bolt, Firefox, MicroB. 不支持：Skyfire, IE, BlackBerry, NetFront, Obigo 备注： 我只测试了浏览器是否从正确的特性对里提取这些值。而特性对里的值是否正确并不在这里进行详细测试。 media查询如同桌面系统一样。width/height使用以CSS的pixels度量的layoutviewport，device-width/height使用以设备的pixels度量的设备屏幕（device screen）。 换句话说，width/height 反映document. documentElement. clientWidth/Height的值, device-width/height 反映screen.width/height. (所有浏览器遵循同样原理，即使取值是错误的)。 media查询在标识网站处于桌面浏览器、pad浏览器或手机浏览器方面很重要，而在区别不同pad和手机设备方面并不有用。 Eventcoordinates(事件坐标) 含义：见下文 度量：见下文 完整支持：Symbian, Iris 问题： Opera 只有pageX/Y，但滚动页面过远时这个值会出错。 在iPhone, Firefox, 和 BlackBerry 上clientX/Y 和pageX/Y相等 在 Android 和 MicroB screenX/Y和clientX/Y相等，也就是它们以CSS的pixels度量屏幕尺寸 在FireFox里screenX/Y值不正确 IE, BlackBerry, 和 Obigo 不支持 pageX/Y. NetFront 所以三个值都是screenX/Y. Obigo clientX/Y是screenX/Y. Samsung WebKit 总是返回pageX/Y. 未测试：Opera Mini,Bolt,Skyfire 事件坐标在桌面浏览器上多多少少是支持的。不幸的是，移动设备上在所测试的12个主流浏览器中只有Symbian WebKit 和 Iris完全正确的支持这3个坐标特性。其余浏览器多多少少都存在问题。 pageX/Y,该特性依然是基于页面的CSSpixels度量的值，如图在桌面浏览器一样，它是三个特性里面最有用的。 clientX/Y是基于visualviewport的，以CSSpixels度量的值. 这样做比较靠谱，虽然我不是很确信这样计算的好处。 screenX/Y基于设备屏幕以设备的pixels度量的值。显然，它使用和clientX/Y同样的参考，而设备的pixels没什么用。所以我们不需要在意screenX/Y,同在桌面浏览器一样，每个bit都是没用的。 Metaviewport(meta viewport) 含义：设置layoutviewport的宽度 度量：CSS的pixels 完整支持：Opera Mobile, iPhone, Android, Iris, IE, BlackBerry, Obigo 不支持：Opera Mini, Symbian, Bolt, Firefox, MicroB, NetFront 问题： Skyfire 不能处理我的测试页面。 在三星的wibkit浏览器下，出现会改变一些特性对的值。 Opera Mobile, iPhone, Samsung, and BlackBerry 不允许用户在设置viewport后再进行缩小操作（do not allow the user to zoom out.）","categories":[],"tags":[{"name":"viewports","slug":"viewports","permalink":"http://yoursite.com/tags/viewports/"}]},{"title":"Linux入门教程","slug":"linux-base","date":"2017-07-04T16:00:00.000Z","updated":"2017-07-12T03:38:01.149Z","comments":true,"path":"2017/07/05/linux-base/","link":"","permalink":"http://yoursite.com/2017/07/05/linux-base/","excerpt":"","text":"Linux是一个多用户多任务操作系统，不但被很多开发者用作个人操作系统，还大量运行在Web服务器上。该教程将带你快速了解Linux系统，包括基本概念、Linux命令、Shell脚本、常用工具等。该教程可以让你快速入门快速上手，能很快让你看到学习的效果；如果你希望深入研究Linux，成为大师，请阅读《鸟哥的Lunix私房菜》。阅读该教程之前，最好对操作系统有所了解，请查看计算机操作系统教程自行学习。学习过程中，会涉及到Linux命令和Shell脚本，如果不希望在本地搭建学习环境，那么可以在线免费体验：compileonline.comLinux有大量的命令，教程中没有一一详解，如果遇到困难，可以随时查看在线手册：http://man.linuxde.net/注意：Linux 是一个类似 Unix 的操作系统，Unix 是闭源收费的，Linux 是开源免费的，Unix 要早于 Linux，所以 Linux 的开发者也模仿了 Unix（但并没有包括Unix源码），使得Linux在外观和操作上与 Unix 非常相似。 Linux简介**Linux简介**严格的来讲，Linux 不算是一个操作系统，只是一个 Linux 系统中的内核，即计算机软件与硬件通讯之间的平台；Linux的全称是GNU/Linux，这才算是一个真正意义上的Linux系统。GNU是Richard Stallman组织的一个项目，世界各地的程序员可以变形GNU程序，同时遵循GPL协议，允许任何人任意改动。但是，修改后的程序必须遵循GPL协议。Linux 是一个多用户多任务的操作系统，也是一款自由软件，完全兼容POSIX标准，拥有良好的用户界面，支持多种处理器架构，移植方便。为程序分配系统资源，处理计算机内部细节的软件叫做操作系统或者内核。如果你希望详细了解操作系统的概念，请查看操作系统教程。用户通过Shell与Linux内核交互。Shell是一个命令行解释工具（是一个软件），它将用户输入的命令转换为内核能够理解的语言（命令）。Linux下，很多工作都是通过命令完成的，学好Linux，首先要掌握常用命令。 Linux版本**内核版本指的是在 Linus 领导下的开发小组开发出的系统内核的版本号。Linux 的每个内核版本使用形式为 x.y.zz-www 的一组数字来表示。其中： · x.y：为linux的主版本号。通常y若为奇数，表示此版本为测试版，系统会有较多bug，主要用途是提供给用户测试。· zz：为次版本号。· www：代表发行号（注意，它与发行版本号无关）。当内核功能有一个飞跃时，主版本号升级，如 Kernel2.2、2.4、2.6等。如果内核增加了少量补丁时，常常会升级次版本号，如Kernel2.6.15、2.6.20等。 一些组织或厂家将 Linux 内核与GNU软件（系统软件和工具）整合起来，并提供一些安装界面和系统设定与管理工具，这样就构成了一个发型套件，例如Ubuntu、Red Hat、Centos、Fedora、SUSE、Debian、FreeBSD等。相对于内核版本，发行套件的版本号随着发布者的不同而不同，与系统内核的版本号是相对独立的。因此把Red Hat等直接说成是Linux是不确切的，它们是Linux的发行版本，更确切地说，应该叫做“以linux为核心的操作系统软件包”。 Linux体系结构**下面是Linux体系结构的示意图： img 在所有Linux版本中，都会涉及到以下几个重要概念： · 内核：内核是操作系统的核心。内核直接与硬件交互，并处理大部分较低层的任务，如内存管理、进程调度、文件管理等。 · Shell：Shell是一个处理用户请求的工具，它负责解释用户输入的命令，调用用户希望使用的程序。 · 命令和工具：日常工作中，你会用到很多系统命令和工具，如cp、mv、cat和grep等。在Linux系统中，有250多个命令，每个命令都有多个选项；第三方工具也有很多，他们也扮演着重要角色。 · 文件和目录：Linux系统中所有的数据都被存储到文件中，这些文件被分配到各个目录，构成文件系统。Linux的目录与Windows的文件夹是类似的概念。 系统启动（开机）**如果你有一台装有Linux的电脑，通电后系统会自动启动，然后提示你登录系统，只有登录后才能进行其他操作。 登录Linux**第一次使用Linux，会看到登录的提示，如下所示： 1login: 登录步骤：**· 登录Linux必须有用户名（用户ID）和密码，如果没有，可以向管理员所要。· 在登录提示处输入用户名并回车；用户名是区分大小写的，输入时要注意。· 然后会提示你输入密码，密码也是区分大小写的。· 如果用户名和密码正确，那么会成功登录，并看到上次登录信息。1234login : amroodamrood&apos;s password:Last login: Sun Jun 14 09:32:32 2009 from 62.61.164.73$ 登录后会出现命令提示符($)，你可以输入任何命令。下面通过 cal 命令来查看日历：123456789$ cal​ June 2009Su Mo Tu We Th Fr Sa​ 1 2 3 4 5 67 8 9 10 11 12 1314 15 16 17 18 19 2021 22 23 24 25 26 2728 29 30$ 修改密码**Linux系统通过密码来保证数据和文件的安全，防止黑客破解和攻击。你可以通过以下方法来修改密码：· 输入 password 命令。· 输入你现在使用的密码。· 输入新密码。注意密码不要过于简单，简单的密码往往会为入侵者大开便利之门。· 确认密码，再输入一遍刚才的密码。1234567$ passwdChanging password for amrood(current) Linux password:******New Linux password:*******Retype new Linux password:*******passwd: all authentication tokens updated successfully$ 注意：输入的密码是看不到的，只会看到一个占位符(*)。 查看目录和文件**在Linux中，所有的数据都被保存在文件中，所有的文件又被分配到不同的目录；目录是一种类似树的结构，称为文件系统。你可以使用 ls 命令来查看当前目录下的文件和目录。下面的例子，使用了 ls 命令的 -l 选项：12345678910111213$ ls -ltotal 19621drwxrwxr-x 2 amrood amrood 4096 Dec 25 09:59 uml-rw-rw-r-- 1 amrood amrood 5341 Dec 25 08:38 uml.jpgdrwxr-xr-x 2 amrood amrood 4096 Feb 15 2006 univdrwxr-xr-x 2 root root 4096 Dec 9 2007 urlspedia-rw-r--r-- 1 root root 276480 Dec 9 2007 urlspedia.tardrwxr-xr-x 8 root root 4096 Nov 25 2007 usr-rwxr-xr-x 1 root root 3192 Nov 25 2007 webthumb.php-rw-rw-r-- 1 amrood amrood 20480 Nov 25 2007 webthumb.tar-rw-rw-r-- 1 amrood amrood 5654 Aug 9 2007 yourfile.mid-rw-rw-r-- 1 amrood amrood 166255 Aug 9 2007 yourfile.swf$ 注意：以d* 开头的为目录，如 uml、univ、urlspedia等；其他的都是文件。 查看当前用户信息**登录系统后，如果你希望知道自己的用户名（用户ID），可以使用 whoami 命令：123$ whoamiamrood$ 如果你希望了解更多关于当前用户的信息，可以使用 who am i 命令，读者可以自己尝试一下。 查看当前在线用户**如果你希望知道当前在线的用户（同时登录到系统的用户），可以使用 users、who 和 w 命令：1234567$ usersamrood bablu qadir$ whoamrood ttyp0 Oct 8 14:10 (limbo)bablu ttyp2 Oct 4 09:08 (calliope)qadir ttyp4 Oct 8 12:09 (dent)$ w 命令可以看到在线用户的更多信息，读者可以自己尝试。 退出登录**完成工作后，你需要退出系统，防止他人使用你的账户。使用 logout 命令即可退出登录，系统会清理有关信息并断开连接。 关闭系统（关机）**关系Linux系统可以使用下列命令：| 命令** | 说明** || ———- | —————————- || halt | 直接关闭系统 || init 0 | 使用预先定义的脚本关闭系统，关闭前可以清理和更新有关信息 || init 6 | 重新启动系统 || poweroff | 通过断电来关闭系统 || reboot | 重新启动系统 || shutdown | 安全关闭系统 |注意：一般情况下只有超级用户和root用户（Linux系统中的最高特权用户）才有关闭系统的权限，但是给普通用户赋予相应权限也可以关闭系统。 Linux文件管理**Linux中的所有数据都被保存在文件中，所有的文件被分配到不同的目录。目录是一种类似于树的结构，称为文件系统。当你使用Linux时，大部分时间都会和文件打交道，通过本节可以了解基本的文件操作，如创建文件、删除文件、复制文件、重命名文件以及为文件创建链接等。在Linux中，有三种基本的文件类型： 1) 普通文件**普通文件是以字节为单位的数据流，包括文本文件、源码文件、可执行文件等。文本和二进制对Linux来说并无区别，对普通文件的解释由处理该文件的应用程序进行。 2) 目录**目录可以包含普通文件和特殊文件，目录相当于Windows和Mac OS中的文件夹。 3) 设备文件**有些教程中称特殊文件，是一个含义。Linux 与外部设备（例如光驱，打印机，终端，modern等）是通过一种被称为设备文件的文件来进行通信。Linux 输入输出到外部设备的方式和输入输出到一个文件的方式是相同的。Linux 和一个外部设备通讯之前，这个设备必须首先要有一个设备文件存在。例如，每一个终端都有自己的设备文件来供 Linux 写数据（出现在终端屏幕上）和读取数据（用户通过键盘输入）。设备文件和普通文件不一样，设备文件中并不包含任何数据。 设备文件有两种类型：字符设备文件和块设备文件。· 字符设备文件以字母&quot;c&quot;开头。字符设备文件向设备传送数据时，一次传送一个字符。典型的通过字符传送数据的设备有终端、打印机、绘图仪、modern等。字符设备文件有时也被称为”raw”设备文件。· 块设备文件以字母&quot;b&quot;开头。块设备文件向设备传送数据时，先从内存中的buffer中读或写数据，而不是直接传送数据到物理磁盘。磁盘和CD-ROMS既可以使用字符设备文件也可以使用块设备文件。 查看文件**查看当前目录下的文件和目录可以使用 ls 命令，例如：12345$lsbin hosts lib res.03ch07 hw1 pub test_resultsch07.bak hw2 res.01 usersdocs hw3 res.02 work 通过 ls 命令的 -l 选项，你可以获取更多文件信息，例如：123456789101112131415$ls -ltotal 1962188drwxrwxr-x 2 amrood amrood 4096 Dec 25 09:59 uml-rw-rw-r-- 1 amrood amrood 5341 Dec 25 08:38 uml.jpgdrwxr-xr-x 2 amrood amrood 4096 Feb 15 2006 univdrwxr-xr-x 2 root root 4096 Dec 9 2007 urlspedia-rw-r--r-- 1 root root 276480 Dec 9 2007 urlspedia.tardrwxr-xr-x 8 root root 4096 Nov 25 2007 usrdrwxr-xr-x 2 200 300 4096 Nov 25 2007 webthumb-1.01-rwxr-xr-x 1 root root 3192 Nov 25 2007 webthumb.php-rw-rw-r-- 1 amrood amrood 20480 Nov 25 2007 webthumb.tar-rw-rw-r-- 1 amrood amrood 5654 Aug 9 2007 yourfile.mid-rw-rw-r-- 1 amrood amrood 166255 Aug 9 2007 yourfile.swfdrwxr-xr-x 11 amrood amrood 4096 May 29 2007 zlib-1.2.3$ 每一列的含义如下：· 第一列：文件类型。· 第二列：表示文件个数。如果是文件，那么就是1；如果是目录，那么就是该目录中文件的数目。· 第三列：文件的所有者，即文件的创建者。· 第四列：文件所有者所在的用户组。在Linux中，每个用户都隶属于一个用户组。· 第五列：文件大小（以字节计）。· 第六列：文件被创建或上次被修改的时间。· 第七列：文件名或目录名。注意：每一个目录都有一个指向它本身的子目录. 和指向它上级目录的子目录..，所以对于一个空目录，第二列应该为 2。 通过 ls -l 列出的文件，每一行都是以 a、d、- 或 l 开头，这些字符表示文件类型：| 前缀** | 描述** || ———- | —————————————- || - | 普通文件。如文本文件、二进制可执行文件、源代码等。 || b | 块设备文件。硬盘可以使用块设备文件。 || c | 字符设备文件。硬盘也可以使用字符设备文件。 || d | 目录文件。目录可以包含文件和其他目录。 || l | 符号链接（软链接）。可以链接任何普通文件，类似于 Windows 中的快捷方式。 || p | 具名管道。管道是进程间的一种通信机制。 || s | 用于进程间通信的套接字。 |提示：通俗的讲软连接就是windows的快捷方式，原来文件删了，快捷方式虽然在但是不起作用了。 元字符**元字符是具有特殊含义的字符。* 和 ? 都是元字符：· * 可以匹配 0 个或多个任意字符；· ? 匹配一个字符。例如:1$ls ch*.doc 可以显示所有以 ch 开头，以.doc 结尾的文件：123ch01-1.doc ch010.doc ch02.doc ch03-2.docch04-1.doc ch040.doc ch05.doc ch06-2.docch01-2.doc ch02-1.doc c 这里，* 匹配任意一个字符。如果你希望显示所有以 .doc 结尾的文件，可以使用1$ls *.doc。 隐藏文件**隐藏文件的第一个字符为英文句号或点号(.)，Linux程序（包括Shell）通常使用隐藏文件来保存配置信息。下面是一些常见的隐藏文件：.profile：Bourne shell (sh) 初始化脚本.kshrc：Korn shell (ksh) 初始化脚本.cshrc：C shell (csh) 初始化脚本.rhosts：Remote shell (rsh) 配置文件 查看隐藏文件需要使用 ls 命令的 -a 选项：1234567$ ls -a. .profile docs lib test_results.. .rhosts hosts pub users.emacs bin hw1 res.01 work.exrc ch07 hw2 res.02.kshrc ch07.bak hw3 res.03$ 一个点号(.)表示当前目录，两个点号(..)表示上级目录注意：输入密码时，星号(*)作为占位符，代表你输入的字符个数。 创建文件**在Linux中，可以使用 vi 编辑器创建一个文本文件，例如：1$ vi filename 上面的命令会创建文件 filename 并打开，按下 i 键即可进入编辑模式，你可以向文件中写入内容。例如：12This is Linux file....I created it for the first time.....I&apos;m going to save this content in this file. 完成编辑后，可以按 esc 键退出编辑模式，也可以按组合键 Shift + ZZ 完全退出文件。这样，就完成了文件的创建。12$ vi filename$ 编辑文件**vi 编辑器可以用来编辑文件。由于篇幅限制，这里仅作简单介绍，将在后面章节进行详细讲解。如下可以打开一个名为 filename 的文件：1$ vi filename 当文件被打开后，可以按 i 键进入编辑模式，按照自己的方式编辑文件。如果想移动光标，必须先按 esc 键退出编辑模式，然后使用下面的按键在文件内移动光标：· l 键向右移动· h 键向左移动· k 键向上移动· j 键向下移动 使用上面的按键，可以将光标快速定位到你想编辑的地方。定位好光标后，按 i 键再次进入编辑模式。编辑完成后按 esc 键退出编辑模式或者按组合键Shift+ZZ 退出当前文件。 查看文件内容**可以使用 cat 命令来查看文件内容，下面是一个简单的例子：1234$ cat filenameThis is Linux file....I created it for the first time.....I&apos;m going to save this content in this file.$ 可以通过 cat 命令的 -b 选项来显示行号，例如：1234$ cat -b filename1 This is Linux file....I created it for the first time.....2 I&apos;m going to save this content in this file.$ 统计单词数目**可以使用 wc 命令来统计当前文件的行数、单词数和字符数，下面是一个简单的例子：123$ wc filename2 19 103 filename$ 每一列的含义如下：· 第一列：文件的总行数· 第二列：单词数目· 第三列：文件的字节数，即文件的大小· 第四列：文件名 也可以一次查看多个文件的内容，例如：1$ wc filename1 filename2 filename3 复制文件**可以使用 cp 命令来复制文件。cp 命令的基本语法如下：1$ cp source_file destination_file 下面的例子将会复制 filename 文件：12$ cp filename copyfile$ 现在在当前目录中会多出一个和 filename 一模一样的 copyfile 文件。 重命名文件**重命名文件可以使用 mv 命令，语法为：1$ mv old_file new_file 下面的例子将会把 filename 文件重命名为 newfile：12$ mv filename newfile$ 现在在当前目录下，只有一个 newfile 文件。mv 命令其实是一个移动文件的命令，不但可以更改文件的路径，也可以更改文件名。 删除文件**rm命令可以删除文件，语法为：1$ rm filename 注意：删除文件是一种危险的行为，因为文件内可能包含有用信息，建议结合 -i 选项来使用 rm 命令。下面的例子会彻底删除一个文件：12$ rm filename$ 你也可以一次删除多个文件：12$ rm filename1 filename2 filename3$ 标准的Linux流**一般情况下，每个Linux程序运行时都会创建三个文件流（三个文件）：· 标准输入流(stdin)：stdin的文件描述符为0，Linux程序默认从stdin读取数据。· 标准输出流(stdout)：stdout 的文件描述符为1，Linux程序默认向stdout输出数据。· 标准错误流(stderr)：stderr的文件描述符为2，Linux程序会向stderr流中写入错误信息。 Linux目录**目录也是一个文件，它的唯一功能是用来保存文件及其相关信息。所有的文件，包括普通文件、设备文件和目录文件，都会被保存到目录中。 主目录**登录后，你所在的位置就是你的主目录（或登录目录），接下来你主要是在这个目录下进行操作，如创建文件、删除文件等。使用下面的命令可以随时进入主目录：12$cd ~$ 这里~ 就表示主目录。如果你希望进入其他用户的主目录，可以使用下面的命令：12$cd ~username$ 返回进入当前目录前所在的目录可以使用下面的命令：12$cd -$ 绝对路径和相对路径**Linux 的目录有清晰的层次结构，/ 代表根目录，所有的目录都位于/下面；文件在层次结构中的位置可以用路径来表示。如果一个路径以/ 开头，就称为绝对路径；它表示当前文件与根目录的关系。举例如下：123/etc/passwd/users/sjones/chem/notes/dev/rdsk/Os3 不以 / 开头的路径称为相对路径，它表示文件与当前目录的关系。例如：12chem/notespersonal/res 获取当前所在的目录可以使用 pwd 命令：123$pwd/user0/home/amrood$ 查看目录中的文件可以使用 ls 命令：1$ls dirname 下面的例子将遍历 /usr/local 目录下的文件：1234$ls /usr/localX11 bin gimp jikes sbinace doc include lib shareatalk etc info man ami 创建目录**可以使用 mkdir 命令来创建目录，语法为：1$mkdir dirname dirname 可以为绝对路径，也可以为相对路径。例如12$mkdir mydir$ 会在当前目录下创建 mydir 目录。又如12$mkdir /tmp/test-dir$ 会在/tmp 目录下创建 test-dir 目录。mkdir 成功创建目录后不会输出任何信息。也可以使用 mkdir 命令同时创建多个目录，例如12$mkdir docs pub$ 会在当前目录下创建 docs 和 pub 两个目录。 创建父目录**使用 mkdir 命令创建目录时，如果上级目录不存在，就会报错。下面的例子中，mkdir 会输出错误信息：1234$mkdir /tmp/amrood/testmkdir: Failed to make directory &quot;/tmp/amrood/test&quot;;No such file or directory$ 为 mkdir 命令增加 -p 选项，可以一级一级创建所需要的目录，即使上级目录不存在也不会报错。例如12$mkdir -p /tmp/amrood/test$ 会创建所有不存在的上级目录。 删除目录**可以使用 rmdir 命令来删除目录，例如：12$rmdir dirname$ 注意：删除目录时请确保目录为空，不会包含其他文件或目录。也可以使用 rmdir 命令同时删除多个目录：12$rmdir dirname1 dirname2 dirname3$ 如果 dirname1、dirname2、dirname3 为空，就会被删除。rmdir 成功删除目录后不会输出任何信息。 改变所在目录**可以使用 cd 命令来改变当前所在目录，进入任何有权限的目录，语法为：1$cd dirname dirname 为路径，可以为相对路径，也可以为绝对路径。例如12$cd /usr/local/bin$ 可以进入/usr/local/bin 目录。可以使用相对路径从这个目录进入 /usr/home/amrood 目录：12$cd ../../home/amrood$ 重命名目录**mv (move) 命令也可以用来重命名目录，语法为：1$mv olddir newdir 下面的例子将会把 mydir 目录重命名为 yourdir 目录：12$mv mydir yourdir$ 点号(.)**一个点号(.)表示当前目录，两个点号(..)表示上级目录（父目录）。ls 命令的 -a 选项可以查看所有文件，包括隐藏文件；-l 选项可以查看文件的所有信息，共有7列。例如：123456$ls -ladrwxrwxr-x 4 teacher class 2048 Jul 16 17.56 .drwxr-xr-x 60 root 1536 Jul 13 14:18 ..---------- 1 teacher class 4210 May 1 08:27 .profile-rwxr-xr-x 1 teacher class 1948 May 12 13:42 memo$ Linux文件权限和访问模式**为了更加安全的存储文件，Linux为不同的文件赋予了不同的权限，每个文件都拥有下面三种权限：· 所有者权限：文件所有者能够进行的操作· 组权限：文件所属用户组能够进行的操作· 外部权限（其他权限）：其他用户可以进行的操作。 查看文件权限** ???使用 ls -l 命令可以查看与文件权限相关的信息：123$ls -l /home/amrood-rwxr-xr-- 1 amrood users 1024 Nov 2 00:10 myfiledrwxr-xr--- 1 amrood users 1024 Nov 2 00:10 mydir 第一列就包含了文件或目录的权限。第一列的字符可以分为三组，每一组有三个，每个字符都代表不同的权限，分别为读取(r)、写入(w)和执行(x)：· 第一组字符(2-4)表示文件所有者的权限，-rwxr-xr– 表示所有者拥有读取(r)、写入(w)和执行(x)的权限。· 第二组字符(5-7)表示文件所属用户组的权限，-rwxr-xr– 表示该组拥有读取(r)和执行(x)的权限，但没有写入权限。· 第三组字符(8-10)表示所有其他用户的权限，rwxr-xr– 表示其他用户只能读取(r)文件。 文件访问模式**文件权限是Linux系统的第一道安全防线，基本的权限有读取(r)、写入(w)和执行(x)：· 读取：用户能够读取文件信息，查看文件内容。· 写入：用户可以编辑文件，可以向文件写入内容，也可以删除文件内容。· 执行：用户可以将文件作为程序来运行。 目录访问模式**目录的访问模式和文件类似，但是稍有不同：· 读取：用户可以查看目录中的文件· 写入：用户可以在当前目录中删除文件或创建文件· 执行：执行权限赋予用户遍历目录的权利，例如执行 cd 和 ls 命令。 改变权限**可以使用 chmod (change mode) 命令来改变文件或目录的访问权限，权限可以使用符号或数字来表示。 使用符号表示权限**对于初学者来说最简单的就是使用符号来改变文件或目录的权限，你可以增加(+)和删除(-)权限，也可以指定特定权限。| 符号** | 说明** || ———- | ———- || + | 为文件或目录增加权限 || - | 删除文件或目录的权限 || = | 设置指定的权限 |下面的例子将会修改 testfile 文件的权限：1234567891011$ls -l testfile-rwxrwxr-- 1 amrood users 1024 Nov 2 00:10 testfile$chmod o+wx testfile$ls -l testfile-rwxrwxrwx 1 amrood users 1024 Nov 2 00:10 testfile$chmod u-x testfile$ls -l testfile-rw-rwxrwx 1 amrood users 1024 Nov 2 00:10 testfile$chmod g=rx testfile$ls -l testfile-rw-r-xrwx 1 amrood users 1024 Nov 2 00:10 testfile 也可以同时使用多个符号：123$chmod o+wx,u-x,g=rx testfile$ls -l testfile-rw-r-xrwx 1 amrood users 1024 Nov 2 00:10 testfile 使用数字表示权限**除了符号，也可以使用八进制数字来指定具体权限，如下表所示：| 数字** | 说明** | 权限** || ———- | ———————————- | ———- || 0 | 没有任何权限 | — || 1 | 执行权限 | –x || 2 | 写入权限 | -w- || 3 | 执行权限和写入权限：1 (执行) + 2 (写入) = 3 | -wx || 4 | 读取权限 | r– || 5 | 读取和执行权限：4 (读取) + 1 (执行) = 5 | r-x || 6 | 读取和写入权限：4 (读取) + 2 (写入) = 6 | rw- || 7 | 所有权限: 4 (读取) + 2 (写入) + 1 (执行) = 7 | rwx |下面的例子，首先使用 ls -1 命令查看 testfile 文件的权限，然后使用 chmod 命令更改权限：1234567891011$ls -l testfile-rwxrwxr-- 1 amrood users 1024 Nov 2 00:10 testfile$ chmod 755 testfile$ls -l testfile-rwxr-xr-x 1 amrood users 1024 Nov 2 00:10 testfile$chmod 743 testfile$ls -l testfile-rwxr---wx 1 amrood users 1024 Nov 2 00:10 testfile$chmod 043 testfile$ls -l testfile----r---wx 1 amrood users 1024 Nov 2 00:10 testfile 更改所有者和用户组**在Linux中，每添加一个新用户，就会为它分配一个用户ID和群组ID，上面提到的文件权限也是基于用户和群组来分配的。有两个命令可以改变文件的所有者或群组：· chown：chown 命令是”change owner”的缩写，用来改变文件的所有者。· chgrp：chgrp 命令是”change group”的缩写，用来改变文件所在的群组。 chown 命令用来更改文件所有者，其语法如下：1$ chown user filelist user 可以是用户名或用户ID，例如12$ chown amrood testfile$ 将 testfile 文件的所有者改为 amrood。注意：超级用户 root 可以不受限制的更改文件的所有者和用户组，但是普通用户只能更改所有者是自己的文件或目录。 chgrp 命令用来改变文件所属群组，其语法为：1$ chgrp group filelist group可以是群组名或群组ID，例如12$ chgrp special testfile$ 将文件 testfile 的群组改为 special。 SUID和SGID位**在Linux中，一些程序需要特殊权限才能完成用户指定的操作。例如，用户的密码保存在/etc/shadow 文件中，出于安全考虑，一般用户没有读取和写入的权限。但是当我们使用passwd 命令来更改密码时，需要对/etc/shadow 文件有写入权限。这就意味着，passwd 程序必须要给我们一些特殊权限，才可以向 /etc/shadow 文件写入内容。Linux 通过给程序设置SUID(Set User ID)和SGID(Set Group ID)位来赋予普通用户特殊权限。当我们运行一个带有SUID位的程序时，就会继承该程序所有者的权限；如果程序不带SUID位，则会根据程序使用者的权限来运行。SGID也是一样。一般情况下程序会根据你的组权限来运行，但是给程序设置SGID后，就会根据程序所在组的组权限运行。如果程序设置了SUID位，就会在表示文件所有者可执行权限的位置上出现’s’字母；同样，如果设置了SGID，就会在表示文件群组可执行权限的位置上出现’s’字母。如下所示：123$ ls -l /usr/bin/passwd-r-sr-xr-x 1 root bin 19031 Feb 7 13:47 /usr/bin/passwd*$ 上面第一列第四个字符不是’x’或’-‘，而是’s’，说明 /usr/bin/passwd 文件设置了SUID位，这时普通用户会以root用户的权限来执行passwd程序。注意：小写字母’s’说明文件所有者有执行权限(x)，大写字母’S’说明程序所有者没有执行权限(x)。如果在表示群组权限的位置上出现SGID位，那么也仅有三类用户可以删除该目录下的文件：目录所有者、文件所有者、超级用户 root。为一个目录设置SUID和SGID位可以使用下面的命令：1234$ chmod ug+s dirname$ ls -ldrwsr-sr-x 2 root root 4096 Jun 19 06:45 dirname$ Linux环境变量**在Linux中，环境变量是一个很重要的概念。环境变量可以由系统、用户、Shell以及其他程序来设定。变量就是一个可以被赋值的字符串，赋值范围包括数字、文本、文件名、设备以及其他类型的数据。下面的例子，我们将为变量 TEST 赋值，然后使用 echo 命令输出：123$TEST=&quot;Linux Programming&quot;$echo $TESTLinux Programming 注意：变量赋值时前面不能加 $ 符号，变量输出时必须要加 $ 前缀。退出 Shell 时，变量将消失。登录系统后，Shell会有一个初始化的过程，用来设置环境变量。这个阶段，Shell会读取 /etc/profile 和 .profile 两个文件，过程如下：· Shell首先检查 /etc/profile 文件是否存在，如果存在，就读取内容，否则就跳过，但是不会报错。· 然后检查你的主目录（登录目录）中是否存在 .profile 文件，如果存在，就读取内容，否则就跳过，也不会报错。读取完上面两个文件，Shell就会出现 $ 命令提示符：$出现这个提示符，就可以输入命令并调用相应的程序了。注意：上面是Bourne Shell的初始化过程，bash 和 ksh 在初始化过程中还会检查其他文件。 .profile文件**/etc/profile文件包含了通用的Shell初始化信息，由Linux管理员维护，一般用户无权修改。但是你可以修改主目录下的 .profile 文件，增加一些“私人定制”初始化信息，包括：· 设置默认终端类型和外观样式；· 设置 Shell 命令查找路径，即PATH变量；· 设置命令提示符。找到主目录下的 .profile 文件，使用 vi 编辑器打开并查看内容。 设置终端类型**一般情况下，我们使用的终端是由 login 或 getty 程序设置的，可能会不符合我们的习惯。对于没有使用过的终端，可能会比较生疏，不习惯命令的输出样式，交互起来略显吃力。所以，一般用户会将终端设置成下面的类型：12$TERM=vt100$ vt100 是 virtual terminate 100 的缩写。虚拟终端是一种假的终端，真正有自己的显示器和键盘的终端，会通过特殊电缆（如串口）连到计算机主机。vt100 是被绝大多数Linux系统所支持的一种虚拟终端规范，常用的还有ansi、xterm等。 设置PATH变量**在命令提示符下输入一个命令时，Shell 会根据 PATH 变量来查找该命令对应的程序，PATH变量指明了这些程序所在的路径。一般情况下PATH变量的设置如下：12$PATH=/bin:/usr/bin$ 多个路径使用冒号(:)分隔。如果用户输入的命令在PATH设置的路径下没有找到，就会报错，例如：123$hellohello: not found$ PS1和PS2变量**PS1变量用来保存命令提示符，可以随意修改，如果你不习惯使用 $ 作为提示符，也可以改成其他字符。PS1变量被修改后，提示符会立即改变。例如，把命令提示符设置成=&gt;：1234$PS1=&apos;=&gt;&apos;=&gt;=&gt;=&gt; 也可以将提示信息设置成当前目录，例如：123=&gt;PS1=&quot;[\\u@\\h \\w]\\$&quot;[root@ip-72-167-112-17 /var/www/tutorialspoint/Linux]$[root@ip-72-167-112-17 /var/www/tutorialspoint/Linux]$ 命令提示信息包含了用户名、主机名和当前目录。下表中的转义字符可以被用作PS1的参数，丰富命令提示符信息。| 转义字符** | 描述** || ———— | ————————– || \\t | 当前时间，格式为 HH:MM:SS || \\d | 当前日期，格式为Weekday Month Date || \\n | 换行 || \\W | 当前所在目录 || \\w | 当前所在目录的完整路径 || \\u | 用户名 || \\h | 主机名（IP地址） || # | 输入的命令的个数，每输入一个新的命令就会加1 || \\$ | 如果是超级用户 root，提示符为#，否则为$。 |你可以在每次登录的时候修改提示符，也可以在 .profile 文件中增加 PS1 变量，这样每次登录时会自动修改提示符。如果用户输入的命令不完整，Shell还会使用第二提示符来等待用户完成命令的输入。默认的第二命令提示符是 &gt;，保存在 PS2 变量，可以随意修改。下面的例子使用默认的第二命令提示符：12345$ echo &quot;this is a&gt; test&quot;this is atest$ 下面的例子通过PS2变量改变提示符：123456$ PS2=&quot;secondary prompt-&gt;&quot;$ echo &quot;this is asecondary prompt-&gt;test&quot;this is atest$ 常用环境变量**下表列出了部分重要的环境变量，这些变量可以通过上面提到的方式修改。| 变量** | 描述** || ———- | —————————————- || DISPLAY | 用来设置将图形显示到何处。 || HOME | 当前用户的主目录。 || IFS | 内部域分隔符。 || LANG | LANG可以让系统支持多语言。例如，将LANG设为pt_BR，则可以支持(巴西)葡萄牙语。 || PATH | 指定Shell命令的路径。 || PWD | 当前所在目录，即 cd 到的目录。 || RANDOM | 生成一个介于 0 和 32767 之间的随机数。 || TERM | 设置终端类型。 || TZ | 时区。可以是AST(大西洋标准时间)或GMT(格林尼治标准时间)等。 || UID | 以数字形式表示的当前用户ID，shell启动时会被初始化。 |下面的例子中使用了部分环境变量：12345678$ echo $HOME/root]$ echo $DISPLAY$ echo $TERMxterm$ echo $PATH/usr/local/bin:/bin:/usr/bin:/home/amrood/bin:/usr/local/bin$ Linux打印文件和发送邮件**通过前面的介绍，相信你对 Linux 的命令和特性有了一个基本的认识，本节将介绍如果打印文件以及发送邮件。 文件打印**如果你希望打印文本文件，最好预先处理一下，包括调整边距、设置行高、设置标题等，这样打印出来的文件更加美观，易于阅读。当然，不处理也可以打印，但是可能会比较丑陋。大部分的Linux自带了 nroff 和 troff 两个强大的文本格式化工具，不过比较老旧，使用的人很少，有兴趣的读者可以可以自行学习，本教程不再进行深入讲解。 pr命令**pr 命令用来将文本文件转换成适合打印的格式，它可以把较大的文件分割成多个页面进行打印，并为每个页面添加标题。pr 命令的语法如下：pr option(s) filename(s)pr 命令仅仅改变文件在屏幕上的显示样式和打印输出样式，并不会更改文件本身。下表是 pr 命令的几个选项：| 选项** | 说明** || ————– | —————————- || -k | 分成几列打印，默认为1。 || -d | 两倍行距（并不是所有版本的 pr 都有效）。 || -h “header” | 设置每个页面的标题。 || -t | 不打印标题和上下边距。 || -l PAGE_LENGTH | 每页显示多少行。默认是每个页面一共66行，文本占56行。 || -o MARGIN | 每行缩进的空格数。 || -w PAGE_WIDTH | 多列输出时，设置页面宽度，默认是72个字符。 |例如，food 文件包含了很多食品的名字，使用 pr 命令分成两列打印，并设置每页的标题为“Restaurants”。首先查看文件内容：$cat foodSweet ToothBangkok WokMandalayAfghani CuisineIsle of JavaBig Apple DeliSushi and SashimiTio Pepe’s Peppers……..$然后使用 pr 命令打印：$pr -2 -h “Restaurants” foodNov 7 9:58 1997 Restaurants Page 1Sweet Tooth Isle of JavaBangkok Wok Big Apple DeliMandalay Sushi and SashimiAfghani Cuisine Tio Pepe’s Peppers……..$ lp和lpr命令**lp 和 lpr 命令将文件传送到打印机进行打印。使用 pr 命令将文件格式化后就可以使用这两个命令来打印。打印机一般由系统管理员来设置，下面的例子使用默认的打印机打印food文件：$lp foodrequest id is laserp-525 (1 file)$命令成功执行会返回一个表示打印任务的ID，通过这个ID可以取消打印或者查看打印状态。如果你希望打印多份文件，可以使用 lp 的 -nNum 选项，或者 lpr 命令的 -Num 选项。Num 是一个数字，可以随意设置。如果系统连接了多台打印机，可以使用 lp 命令的 -dprinter 选项，或者 lpr 命令的 -Pprinter 选项来选择打印机。printer 为打印机名称。 lpstat 和 lpq 命令**lpstat 命令可以查看打印机的缓存队列（有多少个文件等待打印），包括任务ID、所有者、文件大小、请求时间和请求状态。提示：等待打印的文件会被放到打印机的的缓存队列中。例如，使用 lpstat -o 命令查看打印机中所有等待打印的文件，包括你自己的：$lpstat -olaserp-573 john 128865 Nov 7 11:27 on laserplaserp-574 grace 82744 Nov 7 11:28laserp-575 john 23347 Nov 7 11:35$lpstat -o 命令按照打印顺序输出队列中的文件。lpq 命令显示的信息与 lpstat -o 稍有差异：$lpqlaserp is ready and printingRank Owner Job Files Total Sizeactive john 573 report.ps 128865 bytes1st grace 574 ch03.ps ch04.ps 82744 bytes2nd john 575 standard input 23347 bytes$第一行为打印机的状态。如果打印机无法使用或者纸被用完，将会输出其他信息。 cancel 和 lprm 命令**cancel 和 lprm 分别用来终止 lp 和 lpr 的打印请求。使用这两个命令，需要指定ID（由 lp 或 lpq 返回）或打印机名称。例如，通过ID取消打印请求：$cancel laserp-575request “laserp-575” cancelled$如果希望取消正在打印的文件，那么可以不指定ID，仅仅指定打印机名称即可：$cancel laserprequest “laserp-573” cancelled$lprm 命令用来取消当前用户的正在等待打印的文件，使用任务号作为参数可以取消指定文件，使用横线(-)作为参数可以取消所有文件。例如，取消575号打印任务：$lprm 575dfA575diamond dequeuedcfA575diamond dequeued$lprm 会返回被取消的文件名。 发送邮件**可以使用mail命令发送和接收邮件，语法如下：$mail [-s subject] [-c cc-addr] [-b bcc-addr] to-addr每个选项的含义如下：| 选项** | 描述** || ———- | ————————— || -s | 邮件标题。 || -c | 要发送的用户，多个用户以逗号(,)分隔。 || -b | 需要密件发送（密送）的用户，多个用户以逗号(,)分隔。 |例如，向admin@yahoo.com发送邮件：$mail -s “Test Message” admin@yahoo.comHello everyone,this is Linux tutorial and url is http://see.xidian.edu.cn/cpp/linux/.Cc:第一行是输入的命令，-s表示邮件的主题，后面的admin@yahoo.com则是邮件的接收人，输入完这行命令后回车，会进入邮件正文的编写，你可以输入任何文字，比如上面的两行。输入完邮件正文，需要按CTRL+D结束输入，此时会提示你输入Cc地址，即邮件抄送地址，没有直接回车就完成了邮件的发送。也可以通过重定向操作符 &lt; 来发送文件：$mail -s “Report 05/06/07” admin@yahoo.com &lt; demo.txt通过上面的命令，就可以把demol.txt文件的内容作为邮件的内容发送给admin@yahoo.com了。接收邮件不需要任何参数：$mailno email Linux管道和过滤器**有时候，我们可以把两个命令连起来使用，一个命令的输出作为另一个命令的输入，这就叫做管道。为了建立管道，需要在两个命令之间使用竖线(|)连接。管道是Linux进程之间一种重要的通信机制；除了管道，还有共享内存、消息队列、信号、套接字(socket) 等进程通信机制。管道使用竖线(|)将两个命令隔开，竖线左边命令的输出就会作为竖线右边命令的输入。连续使用竖线表示第一个命令的输出会作为第二个命令的输入，第二个命令的输出又会作为第三个命令的输入，依此类推。能够接受数据，过滤（处理或筛选）后再输出的工具，称为过滤器。 grep命令**grep 是一个强大的文本搜索工具，可以使用正则表达式，并返回匹配的行，语法为：$grep pattern file(s)“grep”源于 ed（Linux的一个行文本编辑器）的 g/re/p 命令，g/re/p 是“globally search for a regular expression and print all lines containing it”的缩写，意思是使用正则表达式进行全局检索，并把匹配的行打印出来。正则表达式是一个包含了若干特殊字符的字符串，每个字符都有特殊含义，可以用来匹配文本，更多信息请查看正则表达式教程。grep 可以看做是一个过滤器，如果没有为 grep 指定要检索的文件，那么它会从标准输入设备（一般是键盘）读取；其他过滤器也是如此。grep 命令最简单的使用就是检索包含固定字符的文本。例如，在管道中使用 grep 命令，只允许包含指定字符的行输出到显示器：$ls -l | grep “Aug”-rw-rw-rw- 1 john doc 11008 Aug 6 14:10 ch02-rw-rw-rw- 1 john doc 8515 Aug 6 15:30 ch07-rw-rw-r– 1 john doc 2488 Aug 15 10:51 intro-rw-rw-r– 1 carol doc 1605 Aug 23 07:35 macros$grep 命令有很多选项：| 选项** | 说明** || ———- | —————————————- || -v | 反转查询，输出不匹配的行。例如，grep -v “test” demo.txt 将输出不包含”test”的行。 || -n | 输出匹配的行以及行号。 || -l | 输出匹配的行所在的文件名。 || -c | 输出匹配的总行数。 || -i | 不区分大小写进行匹配。 |下面我们使用正则表达式来匹配这样的行：包含字符“carol”，然后包含任意数目（含零个）的其他字符，最后还要包含“Aug”。使用 -i 选项进行不区分大小写的匹配：$ls -l | grep -i “carol.*aug”-rw-rw-r– 1 carol doc 1605 Aug 23 07:35 macros$ sort命令**sort 命令在 Linux 中非常有用，它将文件中的各行按字母或数进行排序。sort命令既可以从特定的文件，也可以从stdin获取输入。例如，对 foot 文件的各行进行排序：$sort foodAfghani CuisineBangkok WokBig Apple DeliIsle of JavaMandalaySushi and SashimiSweet ToothTio Pepe’s Peppers$通过下面的选项可以控制排序规则：| 选项** | 描述** || ———- | ————————————— || -n | 按照数字大小排序，例如，10会排在2后面；-n 选项会忽略空格或 tab缩进。 || -r | 降序排序。sort 默认是升序排序。 || -f | 不区分大小写。 || +x | 对第x列（从0开始）进行排序。 |下面的例子通过管道将 ls、grep 和 sort 命令连起来使用，过滤包含“Aug”的行，并按照文件大小排序：$ls -l | grep “Aug” | sort +4n-rw-rw-r– 1 carol doc 1605 Aug 23 07:35 macros-rw-rw-r– 1 john doc 2488 Aug 15 10:51 intro-rw-rw-rw- 1 john doc 8515 Aug 6 15:30 ch07-rw-rw-rw- 1 john doc 11008 Aug 6 14:10 ch02$上面的命令，对当前目录中八月份修改的文件按照大小排序；+4n 表示对第5列按照数字大小排序。 pg和more命令**如果文件内容过多，全部显示会很乱，可以使用 pg 和 more 命令分页显示，每次只显示一屏。例如，通过管道，使用more命令显示目录中的文件：$ls -l | grep “Aug” | sort +4n | more-rw-rw-r– 1 carol doc 1605 Aug 23 07:35 macros-rw-rw-r– 1 john doc 2488 Aug 15 10:51 intro-rw-rw-rw- 1 john doc 8515 Aug 6 15:30 ch07-rw-rw-r– 1 john doc 14827 Aug 9 12:40 ch03...-rw-rw-rw- 1 john doc 16867 Aug 6 15:56 ch05–More–(74%)如上，一次只显示一屏文本，显示满后，停下来，并提示已显示全部内容的百分比，按空格键(space)可以查看下一屏，按 b 键可以查看上一屏。 Linux进程管理**当我们运行程序时，Linux会为程序创建一个特殊的环境，该环境包含程序运行需要的所有资源，以保证程序能够独立运行，不受其他程序的干扰。这个特殊的环境就称为进程。每个 Linux 命令都与系统中的程序对应，输入命令，Linux 就会创建一个新的进程。例如使用 ls 命令遍历目录中的文件时，就创建了一个进程。简而言之，进程就是程序的实例。系统通过一个五位数字跟踪程序的运行状态，这个数字称为 pid 或进程ID。每个进程都拥有唯一的 pid。理论上，五位数字是有限的，当数字被用完时，下一个 pid 就会重新开始，所以 pid 最终会重复。但是，两个 pid 一样的进程不能同时存在，因为Linux会使用 pid 来跟踪程序的运行状态。 创建进程**有两种方式来创建进程：前台进程和后台进程。 前台进程**默认情况下，用户创建的进程都是前台进程；前台进程从键盘读取数据，并把处理结果输出到显示器。我们可以看到前台进程的运行过程。例如，使用 ls 命令来遍历当前目录下的文件：$ls ch*.docch01-1.doc ch010.doc ch02.doc ch03-2.docch04-1.doc ch040.doc ch05.doc ch06-2.docch01-2.doc ch02-1.doc这个程序就运行在前台，它会直接把结果输出到显示器。如果 ls 命令需要数据（实际上不需要），那么它会等待用户从键盘输入。当程序运行在前台时，由于命令提示符($)还未出现，用户不能输入其他命令；即使程序需要运行很长时间，也必须等待程序运行结束才能输入其他命令。 后台进程**后台进程与键盘没有必然的关系。当然，后台进程也可能会等待键盘输入。后台进程的优点是不必等待程序运行结束就可以输入其他命令。创建后台进程最简单的方式就是在命令的末尾加 &amp;，例如：$ls ch*.doc &amp;ch01-1.doc ch010.doc ch02.doc ch03-2.docch04-1.doc ch040.doc ch05.doc ch06-2.docch01-2.doc ch02-1.doc如果 ls 命令需要输入（实际上不需要），那么它会暂停，直到用户把它调到前台并从键盘输入数据才会继续运行。 查看正在运行的进程**可以使用 ps 命令查看进程的运行状态，包括后台进程，例如：$psPID TTY TIME CMD18358 ttyp3 00:00:00 sh18361 ttyp3 00:01:31 abiword18789 ttyp3 00:00:00 ps还可以结合 -f 选项查看更多信息，f 是 full 的缩写，例如：$ps -fUID PID PPID C STIME TTY TIME CMDamrood 6738 3662 0 10:23:03 pts/6 0:00 first_oneamrood 6739 3662 0 10:22:54 pts/6 0:00 second_oneamrood 3662 3657 0 08:10:53 pts/6 0:00 -kshamrood 6892 3662 4 10:51:50 pts/6 0:00 ps -f每列的含义如下：| 列** | 描述** || ——— | ———————- || UID | 进程所属用户的ID，即哪个用户创建了该进程。 || PID | 进程ID。 || PPID | 父进程ID，创建该进程的进程称为父进程。 || C | CPU使用率。 || STIME | 进程被创建的时间。 || TTY | 与进程有关的终端类型。 || TIME | 进程所使用的CPU时间。 || CMD | 创建该进程的命令。 |ps 命令还有其他一些选项：| 选项** | 说明** || ———- | —————– || -a | 显示所有用户的所有进程。 || -x | 显示无终端的进程。 || -u | 显示更多信息，类似于 -f 选项。 || -e | 显示所有进程。 | 终止进程**当进程运行在前台时，可以通过 kill 命令或 Ctrl+C 组合键来结束进程。如果进程运行在后台，那么首先要通过 ps 命令来获取进程ID，然后使用 kill 命令“杀死”进程，例如：$ps -fUID PID PPID C STIME TTY TIME CMDamrood 6738 3662 0 10:23:03 pts/6 0:00 first_oneamrood 6739 3662 0 10:22:54 pts/6 0:00 second_oneamrood 3662 3657 0 08:10:53 pts/6 0:00 -kshamrood 6892 3662 4 10:51:50 pts/6 0:00 ps -f$kill 6738Terminated如上所示，kill 命令终结了 first_one 进程。如果进程忽略 kill 命令，那么可以通过 kill -9 来结束：$kill -9 6738Terminated 父进程和子进程**每个 Linux 进程会包含两个进程ID：当前进程ID(pid)和父进程ID(ppid)。可以暂时认为所有的进程都有父进程。由用户运行的大部分命令都将 Shell 作为父进程，使用 ps -f 命令可以查看当前进程ID和父进程ID。 僵尸进程和孤儿进程**正常情况下，子进程被终止时会通过 SIGCHLD 信号通知父进程，父进程可以做一些清理工作或者重新启动一个新的进程。但在某些情况下，父进程会在子进程之前被终止，那么这些子进程就没有了“父亲”，被称为孤儿进程。init 进程会成为所有孤儿进程的父进程。init 的 pid 为1，是Linux系统的第一个进程，也是所有进程的父进程。如果一个进程被终止了，但是使用 ps 命令仍然可以查看该进程，并且状态为 Z，那么这就是一个僵尸进程。僵尸进程虽然被终止了，但是仍然存在于进程列表中。一般僵尸进程很难杀掉，你可以先杀死他们的父进程，让他们变成孤儿进程，init 进程会自动清理僵尸进程。 常驻进程**常驻进程一般是系统级进程，以 root 权限运行在后台，可以处理其他进程的请求。常驻进程没有终端，不能访问 /dev/tty 文件，如果使用 ps -ef 查看该进程，tty 这一列会显示问号(?)。更确切地说，常驻进程通常运行在后台，等待指定事件发生，例如打印进程是一个常驻进程，它会等待用户输入打印相关的命令并进行处理。 top命令**top 命令是一个很有用的工具，它可以动态显示正在运行的进程，还可以按照指定条件对进程进行排序，与Windows的任务管理器类似。top 命令可以显示进程的很多信息，包括物理内存、虚拟内存、CPU使用率、平均负载以及繁忙的进程等。例如：$top这里仅给出一个示意图，读者最好亲自运行一下： img 任务和进程**任务(task)是最抽象的，是一个一般性的术语，指由软件完成的一个活动。一个任务既可以是一个进程，也可以是多个进程。简而言之，它指的是一系列共同达到某一目的的操作。例如，读取数据并将数据放入内存中。这个任务可以由一个进程来实现，也可以由多个进程来实现。 每个任务都有一个数字表示的任务号。进程(process)常常被定义为程序的执行。可以把一个进程看成是一个独立的程序，在内存中有其完备的数据空间和代码空间。一个进程所拥有的数据和变量只属于它自己。jobs 命令可以用来查看系统中正在运行的任务，包括后台运行的任务。该命令可以显示任务号及其对应的进程ID。一个任务可以对应于一个或者多个进程号。jobs 命令的 -l 选项可以查看当前任务包含的进程ID：$jobs -l[1] + 1903 running ls ch*.doc &amp;$其中，第一列表示任务号，第二列表示任务对应的进程ID，第三列表示任务的运行状态，第四列表示启动任务的命令。 前台任务和后台任务的切换**fg 命令可以将后台任务调到前台，语法为：$fg %jobnumberjobnumber 是通过 jobs 命令获取的后台任务的的序号，注意不是pid。如果后台只有一个任务，可以不指定 jobnumber。bg 命令可以将后台暂停的任务，调到前台继续运行，语法为：$bg %jobnumberjobnumber 同样是通过 jobs 命令获取的后台任务的的序号，注意不是pid。如果前台只有一个任务，可以不指定 jobnumber。如果希望将当前任务转移到后台，可以先 Ctrl+z 暂停任务，再使用 bg 命令。任务转移到后台可以空出终端，继续输入其他命令。 Linux网络通信工具**现在是一个互联网的时代，你不可避免的要和其他用户进行远程交流，连接到远程主机。 ping 命令**ping 命令会向网络上的主机发送应答请求，根据响应信息可以判断远程主机是否可用。ping 命令的语法：$ping hostname or ip-address如果网络畅通，很快就可以看到响应信息。例如，检测是否可以连接到谷歌的主机：$ping google.comPING google.com (74.125.67.100) 56(84) bytes of data.64 bytes from 74.125.67.100: icmp_seq=1 ttl=54 time=39.4 ms64 bytes from 74.125.67.100: icmp_seq=2 ttl=54 time=39.9 ms64 bytes from 74.125.67.100: icmp_seq=3 ttl=54 time=39.3 ms64 bytes from 74.125.67.100: icmp_seq=4 ttl=54 time=39.1 ms64 bytes from 74.125.67.100: icmp_seq=5 ttl=54 time=38.8 ms— google.com ping statistics —22 packets transmitted, 22 received, 0% packet loss, time 21017msrtt min/avg/max/mdev = 38.867/39.334/39.900/0.396 ms$如果主机没有响应，可以看到类似下面的信息：$ping giiiiiigle.comping: unknown host giiiiigle.com$ ftp 工具**ftp 是 File Transfer Protocol 的缩写，称为文件传输协议。通过 ftp 工具，能够将文件上传到远程服务器，也可以从远程服务器下载文件。ftp 工具有自己的命令（类似Linux命令），可以：· 连接并登录远程主机；· 查看目录，遍历目录下的文件；· 上传或下载文件，包括文本文件、二进制文件等。ftp 命令的用法如下：$ftp hostname or ip-address接下来会提示你输入用户名和密码，验证成功后会进入主目录，然后就可以使用 ftp 工具的命令进行操作了。| ftp命令** | 说明** || ————– | —————————————- || put filename | 将本地文件上传到远程主机。 || get filename | 将远程文件下载到本地。 || mput file list | 将多个本地文件上传到远程主机。 || mget file list | 将多个远程文件下载到本地。 || prompt off | 关闭提示。默认情况下，使用 mput 或 mget 命令会不断提示你确认文件的上传或下载。 || prompt on | 打开提示。 || dir | 列出远程主机当前目录下的所有文件。 || cd dirname | 改变远程主机目录。 || lcd dirname | 改变本地目录。 || quit | 退出登录。 |注意，所有的上传和下载都是针对本地主机和远程主机的当前目录，如果你希望上传指定目录下的文件，首先要 cd 到该目录，然后才能上传。ftp 工具使用举例：$ftp amrood.comConnected to amrood.com.220 amrood.com FTP server (Ver 4.9 Thu Sep 2 20:35:07 CDT 2009)Name (amrood.com:amrood): amrood331 Password required for amrood.Password:230 User amrood logged in.ftp&gt; dir200 PORT command successful.150 Opening data connection for /bin/ls.total 1464drwxr-sr-x 3 amrood group 1024 Mar 11 20:04 Maildrwxr-sr-x 2 amrood group 1536 Mar 3 18:07 Miscdrwxr-sr-x 5 amrood group 512 Dec 7 10:59 OldStuffdrwxr-sr-x 2 amrood group 1024 Mar 11 15:24 bindrwxr-sr-x 5 amrood group 3072 Mar 13 16:10 mpl-rw-r–r– 1 amrood group 209671 Mar 15 10:57 myfile.outdrwxr-sr-x 3 amrood group 512 Jan 5 13:32 publicdrwxr-sr-x 3 amrood group 512 Feb 10 10:17 pvm3226 Transfer complete.ftp&gt; cd mpl250 CWD command successful.ftp&gt; dir200 PORT command successful.150 Opening data connection for /bin/ls.total 7320-rw-r–r– 1 amrood group 1630 Aug 8 1994 dboard.f-rw-r—– 1 amrood group 4340 Jul 17 1994 vttest.c-rwxr-xr-x 1 amrood group 525574 Feb 15 11:52 wave_shift-rw-r–r– 1 amrood group 1648 Aug 5 1994 wide.list-rwxr-xr-x 1 amrood group 4019 Feb 14 16:26 fix.c226 Transfer complete.ftp&gt; get wave_shift200 PORT command successful.150 Opening data connection for wave_shift (525574 bytes).226 Transfer complete.528454 bytes received in 1.296 seconds (398.1 Kbytes/s)ftp&gt; quit221 Goodbye.$ telnet工具**Telnet 工具可以让我们连接并登录到远程计算机。一旦连接到了远程计算机，就可以在上面进行各种操作了，例如：C:&gt;telnet amrood.comTrying…Connected to amrood.com.Escape character is ‘^]’.login: amroodamrood’s Password: * \\ \\ WELCOME TO AMROOD.COM \\ \\ * Last unsuccessful login: Fri Mar 3 12:01:09 IST 2009Last login: Wed Mar 8 18:33:27 IST 2009 on pts/10 { do your work }$ logoutConnection closed.C:&gt; finger工具**finger 可以让我们查看本地主机或远程主机上的用户信息。有些系统为了安全会禁用 finger 命令。例如，查看本机在线用户：$ fingerLogin Name Tty Idle Login Time Officeamrood pts/0 Jun 25 08:03 (62.61.164.115)查看本机指定用户的信息：$ finger amroodLogin: amrood Name: (null)Directory: /home/amrood Shell: /bin/bashOn since Thu Jun 25 08:03 (MST) on pts/0 from 62.61.164.115No mail.No Plan.查看远程主机上的在线用户：$ finger @avtar.comLogin Name Tty Idle Login Time Officeamrood pts/0 Jun 25 08:03 (62.61.164.115)查看远程主机上某个用户的信息：$ finger amrood@avtar.comLogin: amrood Name: (null)Directory: /home/amrood Shell: /bin/bashOn since Thu Jun 25 08:03 (MST) on pts/0 from 62.61.164.115No mail.No Plan. 10分钟掌握Linux vi编辑器常见命令的使用，最简单的vi编辑器教程**Linux下的文本编辑器有很多种，vi 是最常用的，也是各版本Linux的标配。注意，vi 仅仅是一个文本编辑器，可以给字符着色，可以自动补全，但是不像 Windows 下的 word 有排版功能。vi 是十年磨一剑的产品，虽然命令繁多，并且大多数功能都是依靠键盘输入来完成，但是一旦你熟悉后，会发现 vi 的功能和效率是其他图形界面编辑器无法比拟的。Vim 是 Vi improved 的缩写，是 vi 的改进版。在Linux中，vi 被认为是事实上的标准编辑器，因为：· 所有版本的 Linux 都带有 vi 编辑器；· 占用资源少；· 与 ed、ex 等其他编辑器相比，vi 对用户更加友好。你可以使用 vi 编辑器编辑现有的文件，也可以创建一个新文件，还能以只读模式打开文本文件。 进入 vi 编辑器**可以通过以下方式进入 vi 编辑器：| 命令** | 描述** || ————– | ——————————- || vi filename | 如果filename存在，则打开；否则会创建一个新文件再打开。 || vi -R filename | 以只读模式（只能查看不能编辑）打开现有文件。 || view filename | 以只读模式打开现有文件。 |例如，使用 vi 编辑器创建一个新文件并打开：$vi testfile|~~~~~~~~~~~~“testfile” [New File]竖线(|)代表光标的位置；波浪号(~)代表该行没有任何内容。如果没有 ~，也看不到任何内容，那说明这一行肯定是有空白字符（空格、tab 缩进、换行符等）或不可见字符。 工作模式**进一步了解 vi 之前先来了解一下 vi 的工作模式，vi 有三种工作模式： 1) 普通模式**由Shell进入vi编辑器时，首先进入普通模式。在普通模式下，从键盘输入任何字符都被当作命令来解释。普通模式下没有任何提示符，输入命令后立即执行，不需要回车，而且输入的字符不会在屏幕上显示出来。普通模式下可以执行命令、保存文件、移动光标、粘贴复制等。 2) 编辑模式**编辑模式主要用于文本的编辑。该模式下用户输入的任何字符都被作为文件的内容保存起来，并在屏幕上显示出来。 3) 命令模式**命令模式下，用户可以对文件进行一些高级处理。尽管普通模式下的命令可以完成很多功能，但要执行一些如字符串查找、替换、显示行号等操作还是必须要进入命令模式。注意：有些教程中称有两种工作模式，是把命令模式合并到普通模式。工作模式切换：· 在普通模式下输入 i(插入)、c(修改)、o(另起一行) 命令时进入编辑模式；按 esc 键退回到普通模式。· 在普通模式下输入冒号(:)可以进入命令模式。输入完命令按回车，命令执行完后会自动退回普通模式。提示：如果不确定当前处于哪种模式，按两次 Esc 键将回到普通模式。 退出 vi 编辑器**一般在命令模式下退出 vi 编辑器。| 退出命令** | 说明** || ———— | —————————— || q | 如果文件未被修改，会直接退回到Shell；否则提示保存文件。 || q! | 强行退出，不保存修改内容。 || wq | w 命令保存文件，q 命令退出 vi，合起来就是保存并退出。 || ZZ | 保存并退出，相当于 wq，但是更加方便。 |退出之前，你也可以在 w 命令后面指定一个文件名，将文件另存为新文件，例如：w filename2将当前文件另存为 filename2。注意：vi 编辑文件时，用户的操作都是基于缓冲区中的副本进行的。如果退出时没有保存到磁盘，则缓冲区中的内容就会被丢失。 移动光标**为了不影响文件内容，必须在普通模式（按两次 Esc 键）下移动光标。使用下表中的命令每次可以移动一个字符：| 命令** | 描述** || ———- | ————– || k | 向上移动光标（移动一行） || j | 向下移动光标（移动一行） || h | 向左移动光标（移动一个字符） || l | 向右移动光标（移动一个字符） |两点提醒：· vi 是区分大小写的，输入命令时注意不要锁定大写。· 可以在命令前边添加一个数字作为前缀，例如，2j 将光标向下移动两行。当然，还有很多其他命令来移动光标，不过记住，一定要在普通模式（按两次 Esc 键）下。| 用来移动光标的命令 | || ———- | —————————— || 命令** | 说明** || 0 或 | | 将光标定位在一行的开头。 || $ | 将光标定位在一行的末尾。 || w | 定位到下一个单词。 || b | 定位到上一个单词。 || ( | 定位到一句话的开头，句子是以 ! . ? 三种符号来界定的。 || ) | 定位到一句话的结尾。 || { | 移动到段落开头。&amp;&amp;&amp;&amp;&amp;&amp; || } | 移动到段落结束。&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; || [[ | 回到段落的开头处。&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; || ]] | 向前移到下一个段落的开头处。&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; || n| | 移动到第 n 列（当前行）。 || 1G | 移动到文件第一行。 || G | 移动到文件最后一行。 || nG | 移动到文件第 n 行。 || :n | 移动到文件第 n 行。 || H | 移动到屏幕顶部。 || nH | 移动到距离屏幕顶部第 n 行的位置。 || M | 移动到屏幕中间。 || L | 移动到屏幕底部。 || nL | 移动到距离屏幕底部第 n 行的位置。 || :x | x 是一个数字，表示移动到行号为 x 的行。 | 控制命令**有一些控制命令可以与 Ctrl 键组合使用，如下：| 命令** | 描述** || ———- | ———- || CTRL+d | 向前滚动半屏 || CTRL+f | 向前滚动全屏 || CTRL+u | 向后滚动半屏 || CTRL+b | 向后滚动整屏 || CTRL+e | 向上滚动一行 || CTRL+y | 向下滚动一行 || CTRL+I | 刷新屏幕 | 编辑文件**切换到编辑模式下才能编辑文件。有很多命令可以从普通模式切换到编辑模式，如下所示：| 命令** | 描述** || ———- | ————- || i | 在当前光标位置之前插入文本 || I | 在当前行的开头插入文本 || a | 在当前光标位置之后插入文本 || A | 在当前行的末尾插入文本 || o | 在当前位置下面创建一行 || O | 在当前位置上面创建一行 | 删除字符**下面的命令，可以删除文件中的字符或行：| 命令** | 说明** || ———- | ————— || x | 删除当前光标下的字符 || X | 删除光标前面的字符 || dw | 删除从当前光标到单词结尾的字符 || d^ | 删除从当前光标到行首的字符 || d$ | 删除从当前光标到行尾的字符 || D | 删除从当前光标到行尾的字符 || dd | 删除当前光标所在的行 |可以在命令前面添加一个数字前缀，表示重复操作的次数，例如，2x 表示连续两次删除光标下的字符，2dd 表示连续两次删除光标所在的行。建议各位读者多加练习上面的命令，再进一步深入学习。 修改文本**如果你希望对字符、单词或行进行修改，可以使用下面的命令：| 命令** | 描述** || ———- | ———————- || cc | 删除当前行，并进入编辑模式。 || cw | 删除当前字（单词），并进入编辑模式。 || r | 替换当前光标下的字符。 || R | 从当前光标开始替换字符，按 Esc 键退出。 || s | 用输入的字符替换当前字符，并进入编辑模式。 || S | 用输入的文本替换当前行，并进入编辑模式。 | 粘贴复制**vi 中的复制粘贴命令：| 命令** | 描述** || ———- | ————- || yy | 复制当前行 || nyy | 复制n行 || yw | 复制一个字（单词） || nyw | 复制n行 || p | 将复制的文本粘贴到光标后面 || P | 将复制的文本粘贴到光标前面 | 高级命令**下面的一些命令虽然看起来有些古怪，但是会让你的工作更有效率，如果你是 vi 重度用户，就了解一下吧。| 命令** | 说明** || ———– | ———————————- || J | 将当前行和下一行连接为一行 || &lt;&lt; | 将当前行左移一个单位（一个缩进宽度） || &gt;&gt; | 将当前行右移一个单位（一个缩进宽度） || ~ | 改变当前字符的大小写 || ^G | Ctrl+G组合键可以显示当前文件名和状态 || U | 撤销对当前行所做的修改 || u | 撤销上次操作，再次按 ‘u’ 恢复该次操作 || :f | 以百分号(%)的形式显示当前光标在文件中的位置、文件名和文件的总行数 || :f filename | 将文件重命名为 filename || :w filename | 保存修改到 filename || :e filename | 打开另一个文件名为 filename 的文件 || :cd dirname | 改变当前工作目录到 dirname || :e # | 在两个打开的文件之间进行切换 || :n | 如果用 vi 打开了多个文件，可以使用 :n 切换到下一个文件 || :p | 如果用 vi 打开了多个文件，可以使用 :n 切换到上一个文件 || :N | 如果用 vi 打开了多个文件，可以使用 :n 切换到上一个文件 || :r file | 读取文件并在当前行的后边插入 || :nr file | 读取文件并在第 n 行后边插入 | 文本查找**如果希望进行全文件搜索，可以在普通模式（按两次 Esc 键）下输入 / 命令，这时状态栏（最后一行）出现”/“并提示输入要查找的字符串，回车即可。/ 命令是向下查找，如果希望向上查找，可以使用 ? 命令。这时，输入 n 命令可以按相同的方向继续查找，输入 N 命令可以按相反的方向继续查找。搜索的字符串中可以包含一些有特殊含义的字符，如果希望搜索这些字符本身，需要在前面加反斜杠()。| 部分特殊字符列表 | || ———- | ———- || 字符** | 说明** || ^ | 匹配一行的开头 || . | 匹配一个字符 || * | 匹配0个或多个字符 || $ | 匹配一行的结尾 || [ ] | 匹配一组字符 |如果希望搜索某行中的单个字符，可以使用 f 或 F 命令，f 向上搜索，F 向下搜索，并且会把光标定位到匹配的字符。也可以使用 t 或 T 命令：t 命令向上搜索，并把光标定位到匹配字符的前面；T 命令向下搜索，并把光标定位到匹配字符的后面。 set 命令**set 命令可以对 vi 编辑器进行一些设置。使用 set 命令需要进入命令模式。| :set 命令选项 | || ———- | ———————————— || 命令** | 说明** || :set ic | 搜索时忽略大小写。 || :set ai | 设置自动缩进（自动对齐）。 || :set noai | 取消自动缩进（自动对齐）。 || :set nu | 显示行号。 || :set sw | 设置缩进的空格数，例如，将缩进空格数设置为4：:set sw=4。 || :set ws | 循环搜索：如果直到文件末尾也没有查找到指定字符，那么会回到开头继续查找。 || :set wm | 设置自动换行，例如，设置距离边际2个字符时换行：:set wm=2 。 || :set ro | 将文件类型改为只读。 || :set term | 输出终端类型。 || :set bf | 忽略输入的控制字符，如 BEL(响铃)、BS(退格)、CR(回车)等。 | 运行命令**切换到命令模式，再输入 ! 命令即可运行 Linux 命令。例如，保存文件前，如果希望查看该文件是否存在，那么输入:! ls即可列出当前目录下的文件。按任意键回到 vi 编辑器。 文本替换**切换到命令模式，再输入 s/ 命令即可对文本进行替换。语法为：:s/search/replace/gsearch 为检索的文本，replace 为要替换的文本，g 表示全局替换。 几点提示**vi 编辑器的使用讲解完毕，但是请记住下面几点：· 输入冒号(:)进入命令模式，按两次 Esc 键进入普通模式。· 命令大小写的含义是不一样的。· 必须在编辑模式下才能输入内容。 Linux文件系统**文件系统就是分区或磁盘上的所有文件的逻辑集合。文件系统不仅包含着文件中的数据而且还有文件系统的结构，所有Linux 用户和程序看到的文件、目录、软连接及文件保护信息等都存储在其中。不同Linux发行版本之间的文件系统差别很少，主要表现在系统管理的特色工具以及软件包管理方式的不同，文件目录结构基本上都是一样的。文件系统有多种类型，如：· ext2 ： 早期linux中常用的文件系统；· ext3 ： ext2的升级版，带日志功能；· RAMFS ： 内存文件系统，速度很快；· iso9660：光盘或光盘镜像；· NFS ： 网络文件系统，由SUN发明，主要用于远程文件共享；· MS-DOS ： MS-DOS文件系统；· FAT ： Windows XP 操作系统采用的文件系统；· NTFS ： Windows NT/XP 操作系统采用的文件系统。 分区与目录**文件系统位于磁盘分区中；一个硬盘可以有多个分区，也可以只有一个分区；一个分区只能包含一个文件系统。Linux文件系统与Windows有较大的差别。Windows的文件结构是多个并列的树状结构，最顶部的是不同的磁盘（分区），如 C、D、E、F等。Linux的文件结构是单个的树状结构，根目录是“/”，其他目录都要位于根目录下。每次安装系统的时候我们都会进行分区，Linux下磁盘分区和目录的关系如下：· 任何一个分区都必须对应到某个目录上，才能进行读写操作，称为“挂载”。· 被挂载的目录可以是根目录，也可以是其他二级、三级目录，任何目录都可以是挂载点。· 目录是逻辑上的区分。分区是物理上的区分。· 根目录是所有Linux的文件和目录所在的地方，需要挂载上一个磁盘分区。下图是常见的目录和分区的对应关系： img 为什么要分区，如何分区？· 可以把不同资料，分别放入不同分区中管理，降低风险。· 大硬盘搜索范围大，效率低。· /home、/var、/usr/local 经常是单独分区，因为经常会操作，容易产生碎片。为了便于定位和查找，Linux中的每个目录一般都存放特定类型的文件，下表列出了各种Linux发行版本的常见目录：| 目录** | 说明** || ———- | —————————————- || / | 根目录，只能包含目录，不能包含具体文件。 || /bin | 存放可执行文件。很多命令就对应/bin目录下的某个程序，例如 ls、cp、mkdir。/bin目录对所有用户有效。 || /dev | 硬件驱动程序。例如声卡、磁盘驱动等，还有如 /dev/null、/dev/console、/dev/zero、/dev/full 等文件。 || /etc | 主要包含系统配置文件和用户、用户组配置文件。 || /lib | 主要包含共享库文件，类似于Windows下的DLL；有时也会包含内核相关文件。 || /boot | 系统启动文件，例如Linux内核、引导程序等。 || /home | 用户工作目录（主目录），每个用户都会分配一个目录。 || /mnt | 临时挂载文件系统。这个目录一般是用于存放挂载储存设备的挂载目录的，例如挂载CD-ROM的cdrom目录。 || /proc | 操作系统运行时，进程（正在运行中的程序）信息及内核信息（比如cpu、硬盘分区、内存信息等）存放在这里。/proc目录伪装的文件系统proc的挂载目录，proc并不是真正的文件系统。 || /tmp | 临时文件目录，系统重启后不会被保存。 || /usr | /user目下的文件比较混杂，包含了管理命令、共享文件、库文件等，可以被很多用户使用。 || /var | 主要包含一些可变长度的文件，会经常对数据进行读写，例如日志文件和打印队列里的文件。 || /sbin | 和 /bin 类似，主要包含可执行文件，不过一般是系统管理所需要的，不是所有用户都需要。 | 常用文件管理命令**你可以通过下面的命令来管理文件：| Command** | Description** || —————– | —————————- || cat filename | 查看文件内容。 || cd dirname | 改变所在目录。 || cp file1 file2 | 复制文件或目录。 || file filename | 查看文件类型(binary, text, etc)。 || find filename dir | 搜索文件或目录。 || head filename | 显示文件的开头，与tail命令相对。 || less filename | 查看文件的全部内容，可以分页显示，比more命令要强大。 || ls dirname | 遍历目录下的文件或目录。 || mkdir dirname | 创建目录。 || more filename | 查看文件的全部内容，可以分页显示。 || mv file1 file2 | 移动文件或重命名。 || pwd | 显示用户当前所在目录。 || rm filename | 删除文件。 || rmdir dirname | 删除目录。 || tail filename | 显示文件的结尾，与head命令相对。 || touch filename | 文件不存在时创建一个空文件，存在时修改文件时间戳。 || whereis filename | 查看文件所在位置。 || which filename | 如果文件在环境变量PATH中有定义，那么显示文件位置。 | df命令**管理磁盘分区时经常会使用 df (disk free) 命令，df -k 命令可以用来查看磁盘空间的使用情况（以千字节计），例如：$df -kFilesystem 1K-blocks Used Available Use% Mounted on/dev/vzfs 10485760 7836644 2649116 75% //devices 0 0 0 0% /devices$每一列的含义如下：| 列** | 说明** || ———- | —————————– || Filesystem | 代表文件系统对应的设备文件的路径名（一般是硬盘上的分区）。 || kbytes | 分区包含的数据块（1024字节）的数目。 || used | 已用空间。 || avail | 可用空间。 || capacity | 已用空间的百分比。 || Mounted on | 文件系统挂载点。 |某些目录（例如 /devices）的 kbytes、used、avail 列为0，use列为0%，这些都是特殊（或虚拟）文件系统，即使位于根目录下，也不占用硬盘空间。你可以结合 -h (human readable) 选项将输出信息格式化，让人更易阅读。 du 命令**du (disk usage) 命令可以用来查看特定目录的空间使用情况。du 命令会显示每个目录所占用数据块。根据系统的不同，一个数据块可能是 512 字节或 1024 字节。举例如下：$du /etc10 /etc/cron.d126 /etc/default6 /etc/dfs…$结合 -h 选项可以让信息显示的更加清晰：$du -h /etc5k /etc/cron.d63k /etc/default3k /etc/dfs…$ 挂载文件系统**挂载是指将一个硬件设备（例如硬盘、U盘、光盘等）对应到一个已存在的目录上。 若要访问设备中的文件，必须将文件挂载到一个已存在的目录上， 然后通过访问这个目录来访问存储设备。这样就为用户提供了统一的接口，屏蔽了硬件设备的细节。Linux将所有的硬件设备看做文件，对硬件设备的操作等同于对文件的操作。注意：挂载目录可以不为空，但挂载后这个目录下以前的内容将不可用。需要知道的是，光盘、软盘、其他操作系统使用的文件系统的格式与linux使用的文件系统格式是不一样的，挂载需要确认Linux是否支持所要挂载的文件系统格式。查看当前系统所挂载的硬件设备可以使用 mount 命令：$ mount/dev/vzfs on / type reiserfs (rw,usrquota,grpquota)proc on /proc type proc (rw,nodiratime)devpts on /dev/pts type devpts (rw)$一般约定，/mnt 为临时挂载目录，例如挂载CD-ROM、远程网络设备、软盘等。也可以通过mount命令来挂载文件系统，语法为：mount -t file_system_type device_to_mount directory_to_mount_to例如：$ mount -t iso9660 /dev/cdrom /mnt/cdrom将 CD-ROM 挂载到 /mnt/cdrom 目录。注意：file_system_type用来指定文件系统类型，通常可以不指定，Linux会自动正确选择文件系统类型。挂载文件系统后，就可以通过 cd、cat 等命令来操作对应文件。可以通过 umount 命令来卸载文件系统。例如，卸载 cdrom：$ umount /dev/cdrom不过，大部分现代的Linux系统都有自动挂载卸载功能，unmount 命令较少用到。 用户和群组配额**用户和群组配额可以让管理员为每个用户或群组分配固定的磁盘空间。管理员有两种方式来分配磁盘空间：· 软限制：如果用户超过指定的空间，会有一个宽限期，等待用户释放空间。· 硬限制：没有宽限期，超出指定空间立即禁止操作。下面的命令可以用来管理配额：| 命令** | 说明** || ———- | ————————— || quota | 显示磁盘使用情况以及每个用户组的配额。 || edquota | 编辑用户和群组的配额。 || quotacheck | 查看文件系统的磁盘使用情况，创建、检查并修复配额文件。 || setquota | 设置配额。 || quotaon | 开启用户或群组的配额功能。 || quotaoff | 关闭用户或群组的配额功能。 || repquota | 打印指定文件系统的配额。 | Linux文件存储结构，包括目录项、inode、数据块**大部分的Linux文件系统（如ext2、ext3）规定，一个文件由目录项、inode和数据块组成：· 目录项：包括文件名和inode节点号。· Inode：又称文件索引节点，包含文件的基础信息以及数据块的指针。· 数据块：包含文件的具体内容。 先说inode**理解inode，要从文件储存说起。文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector），每个扇区储存512字节（相当于0.5KB）。操作系统读取硬盘的时候，不会一个扇区一个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。inode包含文件的元信息，具体来说有以下内容：· 文件的字节数。· 文件拥有者的User ID。· 文件的Group ID。· 文件的读、写、执行权限。· 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。· 链接数，即有多少文件名指向这个inode。· 文件数据block的位置。可以用stat命令，查看某个文件的inode信息：stat demo.txt总之，除了文件名以外的所有文件信息，都存在inode之中。至于为什么没有文件名，下文会有详细解释。当查看某个文件时，会先从inode表中查出文件属性及数据存放点，再从数据块中读取数据。请看文件存储结构示意图： img inode的大小**inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。每个inode节点的大小，一般是128字节或256字节。inode节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个inode。假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，占整块硬盘的12.8%。查看每个硬盘分区的inode总数和已经使用的数量，可以使用df -i 命令。查看每个inode节点的大小，可以用如下命令：sudo dumpe2fs -h /dev/hda | grep “Inode size”由于每个文件都必须有一个inode，因此有可能发生inode已经用光，但是硬盘还未存满的情况。这时，就无法在硬盘上创建新文件。 inode号码**每个inode都有一个号码，操作系统用inode号码来识别不同的文件。这里值得重复一遍，Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：首先，系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。使用ls -i命令，可以看到文件名对应的inode号码，例如：ls -i demo.txt 目录项**Linux系统中，目录（directory）也是一种文件。打开目录，实际上就是打开目录文件。目录文件的结构非常简单，就是一系列目录项（dirent）的列表。每个目录项，由两部分组成：所包含文件的文件名，以及该文件名对应的inode号码。ls命令只列出目录文件中的所有文件名：ls /etcls -i命令列出整个目录文件，即文件名和inode号码：ls -i /etc如果要查看文件的详细信息，就必须根据inode号码，访问inode节点，读取信息。ls -l命令列出文件的详细信息。ls -l /etc 硬链接和软链接**硬链接**一般情况下，文件名和inode号码是”一一对应”关系，每个inode号码对应一个文件名。但是，Linux系统允许，多个文件名指向同一个inode号码。这意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访问。这种情况就被称为”硬链接”（hard link）。ln命令可以创建硬链接，语法为：ln source_file target_file运行上面这条命令以后，源文件与目标文件的inode号码相同，都指向同一个inode。inode信息中有一项叫做”链接数”，记录指向该inode的文件名总数，这时就会增加1。反过来，删除一个文件名，就会使得inode节点中的”链接数”减1。当这个值减到0，表明没有文件名指向这个inode，系统就会回收这个inode号码，以及其所对应block区域。这里顺便说一下目录文件的”链接数”。创建目录时，默认会生成两个目录项：”.”和”..”。前者的inode号码就是当前目录的inode号码，等同于当前目录的”硬链接”；后者的inode号码就是当前目录的父目录的inode号码，等同于父目录的”硬链接”。所以，任何一个目录的”硬链接”总数，总是等于2加上它的子目录总数（含隐藏目录）,这里的2是父目录对其的“硬链接”和当前目录下的”.硬链接“。 软链接**除了硬链接以外，还有一种特殊情况。文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的”软链接”（soft link）或者”符号链接（symbolic link）。这意味着，文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错：”No such file or directory”。这是软链接与硬链接最大的不同：文件A指向文件B的文件名，而不是文件B的inode号码，文件B的inode”链接数”不会因此发生变化。ln -s命令可以创建软链接，语法为：ln source_file target_file Linux用户管理**在Linux中，有三种用户：· Root 用户：也称为超级用户，对系统拥有完全的控制权限。超级用户可以不受限制的运行任何命令。Root 用户可以看做是系统管理员。· 系统用户：系统用户是Linux运行某些程序所必须的用户，例如 mail 用户、sshd 用户等。系统用户通常为系统功能所必须的，不建议修改这些用户。· 普通用户：一般用户都是普通用户，这些用户对系统文件的访问受限，不能执行全部Linux命令。Linux支持用户组，用户组就是具有相同特征的用户的集合。一个组可以包含多个用户，每个用户也可以属于不同的组。用户组在Linux中扮演着重要的角色，方便管理员对用户进行集中管理。 与用户和组有关的系统文件**与用户和组有关的系统文件：| 系统文件** | 说明** || ———— | —————————————- || /etc/passwd | 保存用户名和密码等信息，Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行。这个文件对所有用户都是可读的。 || /etc/shadow | /etc/shadow中的记录行和/etc/passwd中的相对应，他由pwconv命令根据/etc/passwd中的数据自动产生，它的格式和/etc/passwd类似，只是对密码进行了加密。并不是所有的系统都支持这个文件。 || /etc/group | 以记录行的形式保存了用户组的所有信息。 |来看一下/etc/passwd文件的结构：$cat /etc/passwdroot:x:0:0:Superuser:/:daemon:x:1:1:System daemons:/etc:bin:x:2:2:Owner of system commands:/bin:sys:x:3:3:Owner of system files:/usr/sys:adm:x:4:4:System accounting:/usr/adm:uucp:x:5:5:UUCP administrator:/usr/lib/uucp:auth:x:7:21:Authentication administrator:/tcb/files/auth:cron:x:9:16:Cron daemon:/usr/spool/cron:listen:x:37:4:Network daemon:/usr/net/nls:lp:x:71:18:printer administrator:/usr/spool/lp:sam:x:200:50:Sam san:/usr/sam:/bin/sh可以看到，/etc/passwd文件中一行记录对应着一个用户，每行记录又被冒号分隔为7个字段，其格式和具体含义如下图所示： img 对每个字段的说明：| 字段** | 说明** || ———- | —————————————- || 用户名 | 用户名是惟一的，长度根据不同的linux系统而定，一般是8位。 || 密码 | 由于系统中还有一个/etc/shadow文件用于存放加密后的口令，所以在这里这一项是“x”来表示，如果用户没有设置口令，则该项为空。如果passwd字段中的第一个字符是“*”的话，那么，就表示该账号被查封了，系统不允许持有该账号的用户登录。 || 用户ID | 系统内部根据用户ID而不是用户名来识别不同的用户，用户ID有以下几种：· 0代表系统管理员，如果你想建立一个系统管理员的话，可以建立一个普通帐户，然后将该账户的用户ID改为0即可。· 1~500系统预留的ID。· 500以上是普通用户使用。 || 组ID | 其实这个和用户ID差不多，用来管理群组，与/etc/group文件相关。 || 描述信息 | 这个字段几乎没有什么用，只是用来解释这个账号的意义。在不同的Linux系统中，这个字段的 格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用做finger命令的输出。 || 用户主目录 | 用户登录系统的起始目录。用户登录系统后将首先进入该目录。root用户默认是/，普通用户是/home/username。 || 用户Shell | 用户登录系统时使用的Shell。 | 管理用户和组**下面是一些常用的管理用户和组的命令：| 命令** | 说明** || ———- | ———- || useradd | 添加用户。 || usermod | 修改用户信息。 || userdel | 删除用户。 || groupadd | 添加用户组。 || groupmod | 修改用户组信息。 || groupdel | 删除用户组。 | 创建用户组**添加用户时，可以将用户添加到现有的用户组，或者创建一个新的用户组。可以在 /etc/groups 文件中看到所有的用户组信息。默认的用户组通常用来管理系统用户，不建议将普通用户添加到这些用户组。使用groupadd命令创建用户组的语法为：groupadd [-g gid [-o]] [-r] [-f] groupname每个选项的含义如下：| 选项** | 说明** || ———- | ————— || -g GID | 以数字表示的用户组ID。 || -o | 可以使用重复的组ID。 || -r | 建立系统组，用来管理系统用户。 || -f | 强制创建。 || groupname | 用户组的名称。 |如果不指定选项，系统将使用默认值。例如创建一个 developers 用户组：$ groupadd developers 修改用户组**groupmod命令可以用来修改用户组，语法为：$ groupmod -n new_modified_group_name old_group_name例如，将用户组 developers_2 重命名为 developer：$ groupmod -n developer developer_2将developer用户组的ID改为545：$ groupmod -g 545 developer 删除用户组**通过groupdel命令可以删除用户组。例如，删除developer组：$ groupdel developergroupdel 仅仅删除用户组，并不删除与之相关的文件，这些文件仍然可以被所有者访问。 添加用户**添加用户可以使用useradd命令，语法为：useradd -d homedir -g groupname -m -s shell -u userid accountname每个选项的含义如下：| 选项** | 描述** || ———— | ————- || -d homedir | 指定用户主目录。 || -g groupname | 指定用户组。 || -m | 如果主目录不存在，就创建。 || -s shell | 为用户指定默认Shell。 || -u userid | 指定用户ID。 || accountname | 用户名。 |如果不指定任何选项，系统将使用默认值。useradd 命令将会修改 /etc/passwd、/etc/shadow、and /etc/group 三个文件，并创建用户主目录。下面的例子将会添加用户 mcmohd，并设置主目录为 /home/mcmohd，用户组为 developers，默认 Shell 为 Korn Shell：$ useradd -d /home/mcmohd -g developers -s /bin/ksh mcmohd注意：添加用户前请确认 developers 用户组存在。用户被创建后，可以使用 passwd 命令来设置密码，例如：$ passwd mcmohd20Changing password for user mcmohd20.New Linux password:**Retype new UNIX password:**passwd: all authentication tokens updated successfully.注意：如果你是管理员，输入 $ passwd username 可以修改你所管理的用户的密码；否则只能修改你自己的密码（不需要提供username）。 修改用户**usermod 命令可以修改现有用户的信息。usermod 命令的选项和 useradd 相同，不过可以增加 -l 选项来更改用户名。下面的例子将用户 mcmohd 的用户名修改为 mcmohd20，主目录修改为 /home/mcmohd20：$ usermod -d /home/mcmohd20 -m -l mcmohd mcmohd20 删除用户**userdel 命令可以用来删除现有用户。userdel 是一个危险的命令，请谨慎使用。userdel 命令仅有一个选项 -r，用来删除用户主目录和本地邮件。例如，删除用户 mcmohd20：$ userdel -r mcmohd20为了便于恢复被误删的用户，可以忽略 -r 选项，保留用户主目录，之后确认无误可以随时删除主目录。 Linux系统性能分析**这篇教程的目的是向大家介绍一些免费的系统性能分析工具（命令），使用这些工具可以监控系统资源使用情况，便于发现性能瓶颈。系统的整体性能取决于各种资源的平衡，类似木桶理论，某种资源的耗尽会严重阻碍系统的性能。 img Linux中需要监控的资源主要有 CPU、主存（内存）、硬盘空间、I/O时间、网络时间、应用程序等。影响系统性能的主要因素有：| 因素** | 说明** || ———– | —————————————- || 用户态CPU | CPU在用户态运行用户程序所花费的时间，包括库调用，但是不包括内核花费的时间。 || 内核态CPU | CPU在内核态运行系统服务所花费的时间。所有的 I/O 操作都需要调用系统服务，程序员可以通过阻塞 I/O 传输来影响这部分的时间。 || I/O 时间和网络时间 | 响应 I/O 请求、处理网络连接所花费的时间。 || 内存 | 切换上下文和交换数据（虚拟内存页导入和导出）花费的时间。 || 应用程序 | 程序等待运行的时间——CPU正在运行其他程序，等待切换到当前程序。 |说明：一般认为用户态CPU和内核态CPU花费的时间小于70%时是良好状态。下面的命令可以用来监控系统性能并作出相应调整：| 命令** | 说明** || ———- | —————————————- || nice | 启动程序时指定进程优先级。 || renice | 调整现有进程的优先级。 || netstat | 显示各种网络相关信息，包括网络连接情况、路由表、接口状态(Interface Statistics)、masquerade 连接、多播成员 (Multicast Memberships)等。实际上，netstat 用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。 || time | 检测一个命令运行时间以及资源（CPU、内存、I/O等）使用情况。 || uptime | 查看系统负载情况。 || ps | 查看系统中进程的资源使用情况（瞬时状态，不是动态监控）。 || vmstat | 报告虚拟内存使用情况。 || gprof | 精确分析程序的性能，能给出函数调用时间、调用次数、调用关系等。 || top | 实时监控系统中各个进程资源的资源使用情况。 |常用命令组合：· vmstat、sar、mpstat检测是否存在CPU瓶颈；· vmstat、free检测是否存在内存瓶颈；· iostat检测是否存在磁盘I/O瓶颈；· netstat检测是否存在网络I/O瓶颈。 Linux系统日志及日志分析**Linux系统拥有非常灵活和强大的日志功能，可以保存几乎所有的操作记录，并可以从中检索出我们需要的信息。大部分Linux发行版默认的日志守护进程为 syslog，位于 /etc/syslog 或 /etc/syslogd，默认配置文件为 /etc/syslog.conf，任何希望生成日志的程序都可以向 syslog 发送信息。Linux系统内核和许多程序会产生各种错误信息、警告信息和其他的提示信息，这些信息对管理员了解系统的运行状态是非常有用的，所以应该把它们写到日志文件中去。完成这个过程的程序就是syslog。syslog可以根据日志的类别和优先级将日志保存到不同的文件中。例如，为了方便查阅，可以把内核信息与其他信息分开，单独保存到一个独立的日志文件中。默认配置下，日志文件通常都保存在“/var/log”目录下。 日志类型**下面是常见的日志类型，但并不是所有的Linux发行版都包含这些类型：| 类型** | 说明** || ————- | —————————————- || auth | 用户认证时产生的日志，如login命令、su命令。 || authpriv | 与 auth 类似，但是只能被特定用户查看。 || console | 针对系统控制台的消息。 || cron | 系统定期执行计划任务时产生的日志。 || daemon | 某些守护进程产生的日志。 || ftp | FTP服务。 || kern | 系统内核消息。 || local0.local7 | 由自定义程序使用。 || lpr | 与打印机活动有关。 || mail | 邮件日志。 || mark | 产生时间戳。系统每隔一段时间向日志文件中输出当前时间，每行的格式类似于 May 26 11:17:09 rs2 – MARK –，可以由此推断系统发生故障的大概时间。 || news | 网络新闻传输协议(nntp)产生的消息。 || ntp | 网络时间协议(ntp)产生的消息。 || user | 用户进程。 || uucp | UUCP子系统。 | 日志优先级**常见的日志优先级请见下标：| 优先级** | 说明** || ———– | —————————– || emerg | 紧急情况，系统不可用（例如系统崩溃），一般会通知所有用户。 || alert | 需要立即修复，例如系统数据库损坏。 || crit | 危险情况，例如硬盘错误，可能会阻碍程序的部分功能。 || err | 一般错误消息。 || warning | 警告。 || notice | 不是错误，但是可能需要处理。 || info | 通用性消息，一般用来提供有用信息。 || debug | 调试程序产生的信息。 || none | 没有优先级，不记录任何日志消息。 | 常见日志文件**所有的系统应用都会在 /var/log 目录下创建日志文件，或创建子目录再创建日志文件。例如：| 文件/目录** | 说明** || —————– | ————————————— || /var/log/boot.log | 开启或重启日志。 || /var/log/cron | 计划任务日志 || /var/log/maillog | 邮件日志。 || /var/log/messages | 该日志文件是许多进程日志文件的汇总，从该文件可以看出任何入侵企图或成功的入侵。 || /var/log/httpd 目录 | Apache HTTP 服务日志。 || /var/log/samba 目录 | samba 软件日志 | /etc/syslog.conf 文件**/etc/syslog.conf 是 syslog 的配置文件，会根据日志类型和优先级来决定将日志保存到何处。典型的 syslog.conf 文件格式如下所示：.err;kern.debug;auth.notice /dev/consoledaemon,auth.notice /var/log/messageslpr.info /var/log/lpr.logmail. /var/log/mail.logftp. /var/log/ftp.logauth. @see.xidian.edu.cnauth. root,amroodnetinfo.err /var/log/netinfo.loginstall. /var/log/install.log.emerg .alert |program_namemark. /dev/console第一列为日志类型和日志优先级的组合，每个类型和优先级的组合称为一个选择器；后面一列为保存日志的文件、服务器，或输出日志的终端。syslog 进程根据选择器决定如何操作日志。对配置文件的几点说明：· 日志类型和优先级由点号(.)分开，例如 kern.debug 表示由内核产生的调试信息。· kern.debug 的优先级大于 debug。· 星号()表示所有，例如 .debug 表示所有类型的调试信息，kern.* 表示由内核产生的所有消息。· 可以使用逗号(,)分隔多个日志类型，使用分号(;)分隔多个选择器。对日志的操作包括：· 将日志输出到文件，例如 /var/log/maillog 或 /dev/console。· 将消息发送给用户，多个用户用逗号(,)分隔，例如 root, amrood。· 通过管道将消息发送给用户程序，注意程序要放在管道符(|)后面。· 将消息发送给其他主机上的 syslog 进程，这时 /etc/syslog.conf 文件后面一列为以@开头的主机名，例如@see.xidian.edu.cn。 logger 命令**logger 是Shell命令，可以通过该命令使用 syslog 的系统日志模块，还可以从命令行直接向系统日志文件写入一行信息。logger命令的语法为：logger [-i] [-f filename] [-p priority] [-t tag] [message…]每个选项的含义如下：| 选项** | 说明** || ———– | —————————————- || -f filename | 将 filename 文件的内容作为日志。 || -i | 每行都记录 logger 进程的ID。 || -p priority | 指定优先级；优先级必须是形如 facility.priority 的完整的选择器，默认优先级为 user.notice。 || -t tag | 使用指定的标签标记每一个记录行。 || message | 要写入的日志内容，多条日志以空格为分隔；如果没有指定日志内容，并且 -f filename 选项为空，那么会把标准输入作为日志内容。 |例如，将ping命令的结果写入日志：$ ping 192.168.0.1 | logger -it logger_test -p local3.notice&amp;$ tail -f /var/log/userlogOct 6 12:48:43 kevein logger_test[22484]: PING 192.168.0.1 (192.168.0.1) 56(84) bytes of data.Oct 6 12:48:43 kevein logger_test[22484]: 64 bytes from 192.168.0.1: icmp_seq=1 ttl=253 time=49.7 msOct 6 12:48:44 kevein logger_test[22484]: 64 bytes from 192.168.0.1: icmp_seq=2 ttl=253 time=68.4 msOct 6 12:48:45 kevein logger_test[22484]: 64 bytes from 192.168.0.1: icmp_seq=3 ttl=253 time=315 msOct 6 12:48:46 kevein logger_test[22484]: 64 bytes from 192.168.0.1: icmp_seq=4 ttl=253 time=279 msOct 6 12:48:47 kevein logger_test[22484]: 64 bytes from 192.168.0.1: icmp_seq=5 ttl=253 time=347 msOct 6 12:48:49 kevein logger_test[22484]: 64 bytes from 192.168.0.1: icmp_seq=6 ttl=253 time=701 msOct 6 12:48:50 kevein logger_test[22484]: 64 bytes from 192.168.0.1: icmp_seq=7 ttl=253 time=591 msOct 6 12:48:51 kevein logger_test[22484]: 64 bytes from 192.168.0.1: icmp_seq=8 ttl=253 time=592 msOct 6 12:48:52 kevein logger_test[22484]: 64 bytes from 192.168.0.1: icmp_seq=9 ttl=253 time=611 msOct 6 12:48:53 kevein logger_test[22484]: 64 bytes from 192.168.0.1: icmp_seq=10 ttl=253 time=931 msping命令的结果成功输出到 /var/log/userlog 文件。命令 logger -it logger_test -p local3.notice 各选项的含义：· -i：在每行都记录进程ID；· -t logger_test：每行记录都加上“logger_test”这个标签；· -p local3.notice：设置日志类型和优先级。 日志转储**日志转储也叫日志回卷或日志轮转。Linux中的日志通常增长很快，会占用大量硬盘空间，需要在日志文件达到指定大小时分开存储。syslog 只负责接收日志并保存到相应的文件，但不会对日志文件进行管理，因此经常会造成日志文件过大，尤其是WEB服务器，轻易就能超过1G，给检索带来困难。大多数Linux发行版使用 logrotate 或 newsyslog 对日志进行管理。logrotate 程序不但可以压缩日志文件，减少存储空间，还可以将日志发送到指定 E-mail，方便管理员及时查看日志。例如，规定邮件日志 /var/log/maillog 超过1G时转储，每周一次，那么每隔一周 logrotate 进程就会检查 /var/log/maillog 文件的大小：· 如果没有超过1G，不进行任何操作。· 如果在1G~2G之间，就会创建新文件 /var/log/maillog.1，并将多出的1G日志转移到该文件，以给 /var/log/maillog 文件瘦身。· 如果在2G~3G之间，会继续创建新文件 /var/log/maillog.2，并将 /var/log/maillog.1 的内容转移到该文件，将 /var/log/maillog 的内容转移到 /var/log/maillog.1，以保持 /var/log/maillog 文件不超过1G。可以看到，每次转存都会创建一个新文件（如果不存在），命名格式为日志文件名加一个数字（从1开始自动增长），以保持当前日志文件和转存后的日志文件不超过指定大小。logrotate 的主要配置文件是 /etc/logrotate.conf，/etc/logrotate.d 目录是对 /etc/logrotate.conf 的补充，或者说为了不使 /etc/logrotate.conf 过大而设置。可以通过 cat 命令查看它的内容：$cat /etc/logrotate.conf# see “man logrotate” for details //可以查看帮助文档# rotate log files weeklyweekly //设置每周转储一次# keep 4 weeks worth of backlogsrotate 4 //最多转储4次# create new (empty) log files after rotating old onescreate //当转储后文件不存储时创建它# uncomment this if you want your log files compressed#compress //以压缩方式转储# RPM packages drop log rotation information into this directoryinclude /etc/logrotate.d //其他日志文件的转储方式，包含在该目录下# no packages own wtmp – we’ll rotate them here/var/log/wtmp { //设置/var/log/wtmp日志文件的转储参数​ monthly //每月转储​ create 0664 root utmp //转储后文件不存在时创建它，文件所有者为root，所属组为utmp，对应的权限为0664​ rotate 1 //最多转储一次}注意：include 允许管理员把多个分散的文件集中到一个，类似于C语言的 #include，将其他文件的内容包含进当前文件。include 非常有用，一些程序会把转储日志的配置文件放在 /etc/logrotate.d 目录，这些配置文件会覆盖或增加 /etc/logrotate.conf 的配置项，如果没有指定相关配置，那么采用 /etc/logrotate.conf 的默认配置。所以，建议将 /etc/logrotate.conf 作为默认配置文件，第三方程序在 /etc/logrotate.d 目录下自定义配置文件。logrotate 也可以作为命令直接运行来修改配置文件。 Linux信号机制与信号处理**信号(signal)是Linux进程间通信的一种机制，全称为软中断信号，也被称为软中断。信号本质上是在软件层次上对硬件中断机制的一种模拟。与其他进程间通信方式（例如管道、共享内存等）相比，信号所能传递的信息比较粗糙，只是一个整数。但正是由于传递的信息量少，信号也便于管理和使用，可以用于系统管理相关的任务，例如通知进程终结、中止或者恢复等。每种信号用一个整型常量宏表示，以SIG开头，比如SIGCHLD、SIGINT等，它们在系统头文件中定义。信号由内核(kernel)管理，产生方式多种多样：· 可以由内核自身产生，比如出现硬件错误、内存读取错误，分母为0的除法等，内核需要通知相应进程。· 也可以由其他进程产生并发送给内核，再由内核传递给目标进程。信号传递的过程：· 内核中针对每一个进程都有一个表来保存信号。· 当内核需要将信号传递给某个进程时，就在该进程对应的表中写入信号，这样就生成了信号。· 当该进程由用户态陷入内核态，再次切换到用户态之前，会查看表中的信号。如果有信号，进程就会首先执行信号对应的操作，此时叫做执行信号。· 从生成信号到将信号传递给对应进程这段时间，信号处于等待状态。· 我们可以编写代码，让进程阻塞(block)某些信号，也就是让这些信号始终处于等待的状态，直到进程取消阻塞(unblock)或者忽略信号。 信号种类**下表列出了一些常见信号：| 信号名称** | 数字表示** | 说明** || ———— | ———— | —————————————- || SIGHUP | 1 | 终端挂起或控制进程终止。当用户退出Shell时，由该进程启动的所有进程都会收到这个信号，默认动作为终止进程。 || SIGINT | 2 | 键盘中断。当用户按下组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号。默认动作为终止进程。 || SIGQUIT | 3 | 键盘退出键被按下。当用户按下或组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号。默认动作为退出程序。 || SIGFPE | 8 | 发生致命的运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为0等所有的算法错误。默认动作为终止进程并产生core文件。 || SIGKILL | 9 | 无条件终止进程。进程接收到该信号会立即终止，不进行清理和暂存工作。该信号不能被忽略、处理和阻塞，它向系统管理员提供了可以杀死任何进程的方法。 || SIGALRM | 14 | 定时器超时，默认动作为终止进程。 || SIGTERM | 15 | 程序结束信号，可以由 kill 命令产生。与SIGKILL不同的是，SIGTERM 信号可以被阻塞和终止，以便程序在退出前可以保存工作或清理临时文件等。 |通过 kill -l 命令可以查看系统支持的所有信号：$ kill -l1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE9) SIGKILL 10) SIGUSR1 11) SIGSEGV 12) SIGUSR213) SIGPIPE 14) SIGALRM 15) SIGTERM 16) SIGSTKFLT17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU25) SIGXFSZ 26) SIGVTALRM 27) SIGPROF 28) SIGWINCH29) SIGIO 30) SIGPWR 31) SIGSYS 34) SIGRTMIN35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+3 38) SIGRTMIN+439) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+843) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+1247) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-1451) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-1055) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-7 58) SIGRTMAX-659) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-263) SIGRTMAX-1 64) SIGRTMAX上面仅是一个演示，不同的Linux发行版支持的信号可能不同。每种信号都会有一个默认动作。默认动作就是脚本或程序接收到该信号所做出的默认操作。常见的默认动作有终止进程、退出程序、忽略信号、重启暂停的进程等，上表中也对部分默认动作进行了说明。 发送信号**有多种方式可以向程序或脚本发送信号，例如按下组合键会发送SIGINT信号，终止当前进程。还可以通过 kill 命令发送信号，语法为：$ kill -signal pidsignal为要发送的信号，可以是信号名称或数字；pid为接收信号的进程ID。例如：$ kill -1 1001将SIGHUP信号发送给进程ID为1001的程序，程序会终止执行。又如，强制杀死ID为1001的进程：$ kill -9 1001 捕获信号**通常情况下，直接终止进程并不是我们所希望的。例如，按下，进程被立即终止，不会清理创建的临时文件，带来系统垃圾，也不会保存正在进行的工作，导致需要重做。可以通过编程来捕获这些信号，当终止信号出现时，可以先进行清场和保存处理，再退出程序。用户程序可以通过C/C++等代码捕获信号，这将在Linux C编程中进行讲解，这里仅介绍如果通过Linux命令捕获信号。通过 trap 命令就可以捕获信号，语法为：$ trap commands signalscommands为Linux系统命令或用户自定义命令；signals为要捕获的信号，可以为信号名称或数字。捕获到信号后，可以有三种处理：· 执行一段脚本来做一些处理工作，例如清理临时文件；· 接受（恢复）信号的默认操作；· 忽略当前信号。 1) 清理临时文件**脚本捕获到终止信号后一个常见的动作就是清理临时文件。例如：$ trap “rm -f $WORKDIR/work1$$ $WORKDIR/dataout$$; exit” 2当用户按下后，脚本先清理临时文件 work1$$ 和 dataout$$ 再退出。注意：exit 命令是必须的，否则脚本捕获到信号后会继续执行而不是退出。修改上面的脚本，使接收到 SIGHUP 时进行同样的操作：$ trap “rm $WORKDIR/work1$$ $WORKDIR/dataout$$; exit” 1 2几点注意：· 如果执行多个命令，需要将命令用引号包围；· 只有脚本执行到 trap 命令时才会捕获信号；· 再次接收到信号时还会执行同样的操作。上面的脚本，执行到 trap 命令时就会替换 WORKDIR 和 $$ 的值。如果希望接收到 SIGHUP 或 SIGINT 信号时再替换其值，那么可以将命令放在单引号内，例如：$ trap ‘rm $WORKDIR/work1$$ $WORKDIR/dataout$$; exit’ 1 2 2) 忽略信号**如果 trap 命令的 commands 为空，将会忽略接收到的信号，即不做任何处理，也不执行默认动作。例如：$ trap ‘’ 2也可以同时忽略多个信号：$ trap ‘’ 1 2 3 15注意：必须被引号包围，不能写成下面的形式：$ trap 2 3) 恢复默认动作**如果希望改变信号的默认动作后再次恢复默认动作，那么省略 trap 命令的 commands 即可，例如：$ trap 1 2将恢复SIGHUP 和 SIGINT 信号的默认动作。","categories":[],"tags":[]},{"title":"C语言中文网：Shell教程","slug":"shell-base","date":"2017-07-03T16:00:00.000Z","updated":"2017-07-05T02:10:22.538Z","comments":true,"path":"2017/07/04/shell-base/","link":"","permalink":"http://yoursite.com/2017/07/04/shell-base/","excerpt":"","text":"Shell简介：什么是Shell，Shell命令的两种执行方式 **Shell本身是一个用C语言编写的程序，它是用户使用Unix/Linux的桥梁，用户的大部分工作都是通过Shell完成的。Shell既是一种命令语言，又是一种程序设计语言。作为命令语言，它交互式地解释和执行用户输入的命令；作为程序设计语言，它定义了各种变量和参数，并提供了许多在高级语言中才具有的控制结构，包括循环和分支。它虽然不是Unix/Linux系统内核的一部分，但它调用了系统核心的大部分功能来执行程序、建立文件并以并行的方式协调各个程序的运行。因此，对于用户来说，shell是最重要的实用程序，深入了解和熟练掌握shell的特性极其使用方法，是用好Unix/Linux系统的关键。可以说，shell使用的熟练程度反映了用户对Unix/Linux使用的熟练程度。注意：单独地学习 Shell 是没有意义的，请先参考Unix/Linux入门教程，了解 Unix/Linux 基础。 Shell有两种执行命令的方式：**· 交互式（Interactive）：解释执行用户的命令，用户输入一条命令，Shell就解释执行一条。 · 批处理（Batch）：用户事先写一个Shell脚本(Script)，其中有很多条命令，让Shell一次把这些命令执行完，而不必一条一条地敲命令。 Shell脚本和编程语言很相似，也有变量和流程控制语句，但Shell脚本是解释执行的，不需要编译，Shell程序从脚本中一行一行读取并执行这些命令，相当于一个用户把脚本中的命令一行一行敲到Shell提示符下执行。Shell初学者请注意，在平常应用中，建议不要用 root 帐号运行 Shell 。作为普通用户，不管您有意还是无意，都无法破坏系统；但如果是 root，那就不同了，只要敲几个字母，就可能导致灾难性后果。 几种常见的Shell**上面提到过，Shell是一种脚本语言，那么，就必须有解释器来执行这些脚本。Unix/Linux上常见的Shell脚本解释器有bash、sh、csh、ksh等，习惯上把它们称作一种Shell。我们常说有多少种Shell，其实说的是Shell脚本解释器。 bash**bash是Linux标准默认的shell，本教程也基于bash讲解。bash由Brian Fox和Chet Ramey共同完成，是BourneAgain Shell的缩写，内部命令一共有40个。Linux使用它作为默认的shell是因为它有诸如以下的特色： · 可以使用类似DOS下面的doskey的功能，用方向键查阅和快速输入并修改命令。 · 自动通过查找匹配的方式给出以某字符串开头的命令。 · 包含了自身的帮助功能，你只要在提示符下面键入help就可以得到相关的帮助。 sh**sh 由Steve Bourne开发，是Bourne Shell的缩写，sh 是Unix 标准默认的shell。 ash**ash shell 是由Kenneth Almquist编写的，Linux中占用系统资源最少的一个小shell，它只包含24个内部命令，因而使用起来很不方便。 csh**csh 是Linux比较大的内核，它由以William Joy为代表的共计47位作者编成，共有52个内部命令。该shell其实是指向/bin/tcsh这样的一个shell，也就是说，csh其实就是tcsh。 ksh**ksh 是Korn shell的缩写，由Eric Gisin编写，共有42条内部命令。该shell最大的优点是几乎和商业发行版的ksh完全兼容，这样就可以在不用花钱购买商业版本的情况下尝试商业版本的性能了。注意：bash是 Bourne Again Shell 的缩写，是linux标准的默认shell ，它基于Bourne shell，吸收了C shell和Korn shell的一些特性。bash完全兼容sh，也就是说，用sh写的脚本可以不加修改的在bash中执行。 Shell脚本语言与编译型语言的差异**大体上，可以将程序设计语言可以分为两类：编译型语言和解释型语言。 编译型语言**很多传统的程序设计语言，例如Fortran、Ada、Pascal、C、C++和Java，都是编译型语言。这类语言需要预先将我们写好的源代码(source code)转换成目标代码(object code)，这个过程被称作“编译”。运行程序时，直接读取目标代码(object code)。由于编译后的目标代码(object code)非常接近计算机底层，因此执行效率很高，这是编译型语言的优点。但是，由于编译型语言多半运作于底层，所处理的是字节、整数、浮点数或是其他机器层级的对象，往往实现一个简单的功能需要大量复杂的代码。例如，在C++里，就很难进行“将一个目录里所有的文件复制到另一个目录中”之类的简单操作。 解释型语言**解释型语言也被称作“脚本语言”。执行这类程序时，解释器(interpreter)需要读取我们编写的源代码(source code)，并将其转换成目标代码(object code)，再由计算机运行。因为每次执行程序都多了编译的过程，因此效率有所下降。使用脚本编程语言的好处是，它们多半运行在比编译型语言还高的层级，能够轻易处理文件与目录之类的对象；缺点是它们的效率通常不如编译型语言。不过权衡之下，通常使用脚本编程还是值得的：花一个小时写成的简单脚本，同样的功能用C或C++来编写实现，可能需要两天，而且一般来说，脚本执行的速度已经够快了，快到足以让人忽略它性能上的问题。脚本编程语言的例子有awk、Perl、Python、Ruby与Shell。 什么时候使用Shell**因为Shell似乎是各UNIX系统之间通用的功能，并且经过了POSIX的标准化。因此，Shell脚本只要“用心写”一次，即可应用到很多系统上。因此，之所以要使用Shell脚本是基于： · 简单性：Shell是一个高级语言；通过它，你可以简洁地表达复杂的操作。 · 可移植性：使用POSIX所定义的功能，可以做到脚本无须修改就可在不同的系统上执行。 · 开发容易：可以在短时间内完成一个功能强大又妤用的脚本。 但是，考虑到Shell脚本的命令限制和效率问题，下列情况一般不使用Shell： 资源密集型的任务，尤其在需要考虑效率时（比如，排序，hash等等）。 需要处理大任务的数学操作，尤其是浮点运算，精确运算，或者复杂的算术运算（这种情况一般使用C++或FORTRAN 来处理）。 有跨平台（操作系统）移植需求（一般使用C 或Java）。 复杂的应用，在必须使用结构化编程的时候（需要变量的类型检查，函数原型，等等）。 对于影响系统全局性的关键任务应用。 对于安全有很高要求的任务，比如你需要一个健壮的系统来防止入侵、破解、恶意破坏等等。 项目由连串的依赖的各个部分组成。 需要大规模的文件操作。 需要多维数组的支持。 需要数据结构的支持，比如链表或数等数据结构。 需要产生或操作图形化界面 GUI。 需要直接操作系统硬件。 需要 I/O 或socket 接口。 需要使用库或者遗留下来的老代码的接口。 私人的、闭源的应用（shell 脚本把代码就放在文本文件中，全世界都能看到）。 如果你的应用符合上边的任意一条，那么就考虑一下更强大的语言吧——或许是Perl、Tcl、Python、Ruby——或者是更高层次的编译语言比如C/C++，或者是Java。即使如此，你会发现，使用shell来原型开发你的应用，在开发步骤中也是非常有用的。 第一个Shell脚本**打开文本编辑器，新建一个文件，扩展名为sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用php写shell 脚本，扩展名就用php好了。输入一些代码： 12#!/bin/bashecho \"Hello World !\" “#!” 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种Shell。echo命令用于向窗口输出文本。运行Shell脚本有两种方法。 作为可执行程序**将上面的代码保存为test.sh，并 cd 到相应目录： 12$ chmod +x ./test.sh #使脚本具有执行权限$ ./test.sh #执行脚本 注意，一定要写成./test.sh，而不是test.sh。运行其它二进制的程序也一样，直接写test.sh，linux系统会去PATH里寻找有没有叫test.sh的，而只有/bin, /sbin, /usr/bin，/usr/sbin等在PATH里，你的当前目录通常不在PATH里，所以写成test.sh是会找不到命令的，要用./test.sh告诉系统说，就在当前目录找。通过这种方式运行bash脚本，第一行一定要写对，好让系统查找到正确的解释器。这里的”系统”，其实就是shell这个应用程序（想象一下Windows Explorer），但我故意写成系统，是方便理解，既然这个系统就是指shell，那么一个使用/bin/sh作为解释器的脚本是不是可以省去第一行呢？是的。 作为解释器参数**这种运行方式是，直接运行解释器，其参数就是shell脚本的文件名，如： 12$ /bin/sh test.sh$ /bin/php test.php 这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。再看一个例子。下面的脚本使用 read 命令从 stdin 获取输入并赋值给 PERSON 变量，最后在 stdout 上输出： 1234567#!/bin/bash# Author : mozhiyan# Copyright (c) http://see.xidian.edu.cn/cpp/linux/# Script follows here:echo \"What is your name?\"read PERSONecho \"Hello, $PERSON\" 运行脚本： 123456$ chmod +x ./test.sh$ ./test.shWhat is your name?mozhiyanHello, mozhiyan$ Shell变量：Shell变量的定义、删除变量、只读变量、变量类型**Shell支持自定义变量。 定义变量**定义变量时，变量名不加美元符号（$），如： 1variableName=\"value\" 注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则： · 首个字符必须为字母（a-z，A-Z）。 · 中间不能有空格，可以使用下划线（_）。 · 不能使用标点符号。 · 不能使用bash里的关键字（可用help命令查看保留关键字）。 变量定义举例： 12myUrl=\"http://see.xidian.edu.cn/cpp/linux/\"myNum=100 使用变量**使用一个定义过的变量，只要在变量名前面加美元符号（$）即可，如： 123your_name=\"mozhiyan\"echo $your_nameecho $&#123;your_name&#125; 变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况： 1234for skill in Ada Coffe Action Java do echo \"I am good at $&#123;skill&#125;Script\"done 如果不给skill变量加花括号，写成echo &quot;I am good at $skillScript&quot;，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。推荐给所有变量加上花括号，这是个好的编程习惯。 重新定义变量**已定义的变量，可以被重新定义，如： 1234myUrl=\"http://see.xidian.edu.cn/cpp/linux/\"echo $&#123;myUrl&#125;myUrl=\"http://see.xidian.edu.cn/cpp/shell/\"echo $&#123;myUrl&#125; 这样写是合法的，但注意，第二次赋值的时候不能写 $myUrl=&quot;http://see.xidian.edu.cn/cpp/shell/&quot;，使用变量的时候才加美元符（$）。 只读变量**使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。下面的例子尝试更改只读变量，结果报错： 123myUrl=\"http://see.xidian.edu.cn/cpp/shell/\"readonly myUrlmyUrl=\"http://see.xidian.edu.cn/cpp/danpianji/\" 运行脚本，结果如下： 1/bin/sh: NAME: This variable is read only. 删除变量**使用 unset 命令可以删除变量。语法： 1unset variable_name 变量被删除后不能再次使用；unset 命令不能删除只读变量。举个例子： 1234#!/bin/shmyUrl=\"http://see.xidian.edu.cn/cpp/u/xitong/\"unset myUrlecho $myUrl 上面的脚本没有任何输出。 变量类型**运行shell时，会同时存在三种变量： 1) 局部变量**局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。 2) 环境变量**所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。 3) shell变量**shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行 Shell特殊变量：Shell $0, $#, $*, $@, $?, `# 和命令行参数**前面已经讲到，变量名只能包含数字、字母和下划线，因为某些包含其他字符的变量有特殊含义，这样的变量被称为特殊变量。例如，$ 表示当前Shell进程的ID，即pid，看下面的代码： $echo $$ 运行结果 29949 特殊变量列表 变量** 含义** $0 当前脚本的文件名 $n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。 $# 传递给脚本或函数的参数个数。 $* 传递给脚本或函数的所有参数。 $@ 传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 $* 稍有不同，下面将会讲到。 $? 上个命令的退出状态，或函数的返回值。 $$ 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。 命令行参数**运行脚本时传递给脚本的参数称为命令行参数。命令行参数用$n表示，例如，$1表示第一个参数，$2 表示第二个参数，依次类推。请看下面的脚本： 1234567#!/bin/bashecho \"File Name: $0\"echo \"First Parameter : $1\"echo \"First Parameter : $2\"echo \"Quoted Values: $@\"echo \"Quoted Values: $*\"echo \"Total Number of Parameters : $#\" 运行结果： 1234567$./test.sh Zara AliFile Name : ./test.shFirst Parameter : ZaraSecond Parameter : AliQuoted Values: Zara AliQuoted Values: Zara AliTotal Number of Parameters : 2 $* 和 $@ 的区别**$* 和$@都表示传递给函数或脚本的所有参数， 不被双引号(“ “)包含时，都以&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot;的形式输出所有参数。但是当它们被双引号(“ “)包含时，&quot;$*&quot;会将所有的参数作为一个整体，以&quot;$1 $2 … $n&quot;的形式输出所有参数；&quot;$@&quot; 会将各个参数分开，以&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数。 下面的例子可以清楚的看到$*和$@ 的区别： 123456789101112131415161718192021222324252627282930#!/bin/bashecho \"$*=\" $*echo \"\\\"$*\\\"=\" \"$*\"echo \"$@=\" $@echo \"\\\"$@\\\"=\" \"$@\"echo \"print each param from $*\"for var in $*do echo \"$var\"doneecho \"print each param from $@\"for var in $@do echo \"$var\"doneecho \"print each param from \\\"$*\\\"\"for var in \"$*\"do echo \"$var\"doneecho \"print each param from \\\"$@\\\"\"for var in \"$@\"do echo \"$var\"done 执行 ./test.sh “a” “b” “c” “d”，看到下面的结果： 123456789101112131415161718192021$*= a b c d\"$*\"= a b c d$@= a b c d\"$@\"= a b c dprint each param from $*abcdprint each param from $@abcdprint each param from \"$*\"a b c dprint each param from \"$@\"abcd 退出状态**$?可以获取上一个命令的退出状态。所谓退出状态，就是上一个命令执行后的返回结果。退出状态是一个数字，一般情况下，大部分命令执行成功会返回 0，失败返回 1。不过，也有一些命令返回其他值，表示不同类型的错误。下面例子中，命令成功执行： 12345678910$./test.sh Zara AliFile Name : ./test.shFirst Parameter : ZaraSecond Parameter : AliQuoted Values: Zara AliQuoted Values: Zara AliTotal Number of Parameters : 2echo ?0$ $? 也可以表示函数的返回值，后续将会讲解。 Shell替换：Shell变量替换，命令替换，转义字符**如果表达式中包含特殊字符，Shell 将会进行替换。例如，在双引号中使用变量就是一种替换，转义字符也是一种替换。举个例子： 1234#!/bin/basha=10echo -e \"Value of a is $a \\n\" 运行结果： Value of a is 10 这里 -e表示对转义字符进行替换。如果不使用 -e 选项，将会原样输出： Value of a is 10\\n 下面的转义字符都可以用在echo中： 转义字符** 含义** \\ 反斜杠 \\a 警报，响铃 \\b 退格（删除键） \\f 换页(FF)，将当前位置移到下页开头 \\n 换行 \\r 回车 \\t 水平制表符（tab键） \\v 垂直制表符 可以使用echo命令的 -E选项禁止转义，默认也是不转义的；使用-n选项可以禁止插入换行符。 命令替换**命令替换是指Shell可以先执行命令，将输出结果暂时保存，在适当的地方输出。命令替换的语法： 1`command` 注意是反引号，不是单引号，这个键位于 Esc` 键下方。下面的例子中，将命令执行结果保存在变量中： 12345678910#!/bin/bashDATE=dateecho \"Date is $DATE\"USERS=who | wc -lecho \"Logged in user are $USERS\"UP=date ; uptimeecho \"Uptime is $UP\" 运行结果： 1234Date is Thu Jul 2 03:59:57 MST 2009Logged in user are 1Uptime is Thu Jul 2 03:59:57 MST 200903:59:57 up 20 days, 14:03, 1 user, load avg: 0.13, 0.07, 0.15 变量替换**变量替换可以根据变量的状态（是否为空、是否定义等）来改变它的值可以使用的变量替换形式： 形式** 说明** ${var} 变量本来的值 ${var:-word} 如果变量 var 为空或已被删除(unset)，那么返回 word，但不改变 var 的值。 ${var:=word} 如果变量 var 为空或已被删除(unset)，那么返回 word，并将 var 的值设置为 word。 ${var:?message} 如果变量 var 为空或已被删除(unset)，那么将消息 message 送到标准错误输出，可以用来检测变量 var 是否可以被正常赋值。若此替换出现在Shell脚本中，那么脚本将停止运行。 ${var:+word} 如果变量 var 被定义，那么返回 word，但不改变 var 的值。 请看下面的例子： 123456789101112131415161718#!/bin/bashecho $&#123;var:-\"Variable is not set\"&#125;echo \"1 - Value of var is $&#123;var&#125;\"echo $&#123;var:=\"Variable is not set\"&#125;echo \"2 - Value of var is $&#123;var&#125;\"unset varecho $&#123;var:+\"This is default value\"&#125;echo \"3 - Value of var is $var\"var=\"Prefix\"echo $&#123;var:+\"This is default value\"&#125;echo \"4 - Value of var is $var\"echo $&#123;var:?\"Print this message\"&#125;echo \"5 - Value of var is $&#123;var&#125;\" 运行结果： 12345678910Variable is not set1 - Value of var isVariable is not set2 - Value of var is Variable is not set3 - Value of var isThis is default value4 - Value of var is PrefixPrefix5 - Value of var is Prefix Shell运算符：Shell算数运算符、关系运算符、布尔运算符、字符串运算符等**Bash 支持很多运算符，包括算数运算符、关系运算符、布尔运算符、字符串运算符和文件测试运算符。原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。expr 是一款表达式计算工具，使用它能完成表达式的求值操作。例如，两个数相加： 123#!/bin/bashval=`expr 2 + 2`echo \"Total value : $val\" 运行脚本输出： Total value : 4 两点注意： · 表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。 · 完整的表达式要被(``)包含，注意这个字符不是常用的单引号，在 Esc 键下边。 算术运算符**先来看一个使用算术运算符的例子： 12345678910111213141516171819202122232425262728#!/bin/sh# 加法a=10b=20val=`expr $a + $b`echo \"a + b : $val\"# 减法val=`expr $a - $b`echo \"a - b : $val\"# 乘法val=`expr $a \\* $b`echo \"a * b : $val\"# 除法val=`expr $b / $a`echo \"b / a : $val\"# 取余val=`expr $b % $a`echo \"b % a : $val\"# 相等if [ $a == $b ]then echo \"a is equal to b\"fi# 不相等if [ $a != $b ]then echo \"a is not equal to b\"fi 运行结果： 123456a + b : 30a - b : -10a * b : 200b / a : 2b % a : 0a is not equal to b 注意： · 乘号(*)前边必须加反斜杠(\\)才能实现乘法运算； · if...then...fi是条件语句，后续将会讲解。 算术运算符列表 运算符** 说明** 举例** + 加法 expr $a + $b 结果为 30。 - 减法 expr $a - $b 结果为 10。 * 乘法 expr $a \\* $b 结果为 200。 / 除法 expr $b / $a 结果为 2。 % 取余 expr $b % $a 结果为 0。 = 赋值 a=$b 将把变量 b 的值赋给 a。 == 相等。用于比较两个数字，相同则返回 true。 [ $a == $b ] 返回 false。 != 不相等。用于比较两个数字，不相同则返回 true。 [ $a != $b ] 返回 true。 注意：条件表达式要放在方括号之间，并且要有空格，例如[$a==$b]是错误的，必须写成[ $a == $b ]。 关系运算符**关系运算符只支持数字，不支持字符串，除非字符串的值是数字。先来看一个关系运算符的例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#!/bin/sha=10b=20# 相等if [ $a -eq $b ]then echo \"$a -eq $b : a is equal to b\"else echo \"$a -eq $b: a is not equal to b\"fi# 不相等if [ $a -ne $b ]then echo \"$a -ne $b: a is not equal to b\"else echo \"$a -ne $b : a is equal to b\"fi# 大于if [ $a -gt $b ]then echo \"$a -gt $b: a is greater than b\"else echo \"$a -gt $b: a is not greater than b\"fi# 小于if [ $a -lt $b ]then echo \"$a -lt $b: a is less than b\"else echo \"$a -lt $b: a is not less than b\"fi# 大于等于if [ $a -ge $b ]then echo \"$a -ge $b: a is greater or equal to b\"else echo \"$a -ge $b: a is not greater or equal to b\"fi# 小于等于if [ $a -le $b ]then echo \"$a -le $b: a is less or equal to b\"else echo \"$a -le $b: a is not less or equal to b\"fi 运行结果： 12345610 -eq 20: a is not equal to b10 -ne 20: a is not equal to b10 -gt 20: a is not greater than b10 -lt 20: a is less than b10 -ge 20: a is not greater or equal to b10 -le 20: a is less or equal to b 关系运算符列表 运算符** 说明** 举例** -eq 检测两个数是否相等，相等返回 true。 [ $a -eq $b ]返回 true。 -ne 检测两个数是否相等，不相等返回 true。 [ $a -ne $b ]返回 true。 -gt 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ]返回 false。 -lt 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ]返回 true。 -ge 检测左边的数是否大等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。 -le 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ]返回 true。 布尔运算符**先来看一个布尔运算符的例子： 1234567891011121314151617181920212223242526272829303132#!/bin/sha=10b=20if [ $a != $b ]then echo \"$a != $b : a is not equal to b\"else echo \"$a != $b: a is equal to b\"fi# -a 与运算 andif [ $a -lt 100 -a $b -gt 15 ]then echo \"$a -lt 100 -a $b -gt 15 : returns true\"else echo \"$a -lt 100 -a $b -gt 15 : returns false\"fi# -o 或运算 orif [ $a -lt 100 -o $b -gt 100 ]then echo \"$a -lt 100 -o $b -gt 100 : returns true\"else echo \"$a -lt 100 -o $b -gt 100 : returns false\"fi# -o 或运算 orif [ $a -lt 5 -o $b -gt 100 ]then echo \"$a -lt 100 -o $b -gt 100 : returns true\"else echo \"$a -lt 100 -o $b -gt 100 : returns false\"fi 运行结果： 123410 != 20 : a is not equal to b10 -lt 100 -a 20 -gt 15 : returns true10 -lt 100 -o 20 -gt 100 : returns true10 -lt 5 -o 20 -gt 100 : returns false 布尔运算符列表 运算符** 说明** 举例** ! 非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ]返回 true。 -o 或运算，有一个表达式为 true 则返回 true。 [ $a -lt 20 -o $b -gt 100 ]返回 true。 -a 与运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 返回 false。 字符串运算符**先来看一个例子： 123456789101112131415161718192021222324252627282930313233343536373839#!/bin/sha=\"abc\"b=\"efg\"# 相等返回trueif [ $a = $b ]then echo \"$a = $b : a is equal to b\"else echo \"$a = $b: a is not equal to b\"fi# 不相等返回trueif [ $a != $b ]then echo \"$a != $b : a is not equal to b\"else echo \"$a != $b: a is equal to b\"fi# -z 长度为0返回true if [ -z $a ]then echo \"-z $a : string length is zero\"else echo \"-z $a : string length is not zero\"fi# -n 长度不为0返回true if [ -n $a ]then echo \"-n $a : string length is not zero\"else echo \"-n $a : string length is zero\"fi# 检测字符串是否为空，不为空返回 trueif [ $a ]then echo \"$a : string is not empty\"else echo \"$a : string is empty\"fi 运行结果： 12345abc = efg: a is not equal to babc != efg : a is not equal to b-z abc : string length is not zero-n abc : string length is not zeroabc : string is not empty 字符串运算符列表 运算符** 说明** 举例** = 检测两个字符串是否相等，相等返回 true。 [ $a = $b ]返回 false。 != 检测两个字符串是否相等，不相等返回 true。 [ $a != $b ]返回 true。 -z 检测字符串长度是否为0，为0返回 true。 [ -z $a ]返回 false。 -n 检测字符串长度是否为0，不为0返回 true。 [ -z $a ] 返回 true。 str 检测字符串是否为空，不为空返回 true。 [ $a ]返回 true。 文件测试运算符**文件测试运算符用于检测 Unix 文件的各种属性。例如，变量 file 表示文件“/var/www/tutorialspoint/unix/test.sh”，它的大小为100字节，具有 rwx 权限。下面的代码，将检测该文件的各种属性： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#!/bin/shfile=\"/var/www/tutorialspoint/unix/test.sh\"# 检测文件是否可读 readif [ -r $file ]then echo \"File has read access\"else echo \"File does not have read access\"fi# 检测文件是否可写 whiteif [ -w $file ]then echo \"File has write permission\"else echo \"File does not have write permission\"fi# 检测文件是否可执行if [ -x $file ]then echo \"File has execute permission\"else echo \"File does not have execute permission\"fi# 检测文件是否是普通文件（既不是目录，也不是设备文件） fileif [ -f $file ]then echo \"File is an ordinary file\"else echo \"This is sepcial file\"fi# 检测文件是否是目录 dirif [ -d $file ]then echo \"File is a directory\"else echo \"This is not a directory\"fi# 检测文件是否为空（文件大小是否大于0）spaceif [ -s $file ]then echo \"File size is zero\"else echo \"File size is not zero\"fi# 检测文件（包括目录）是否存在if [ -e $file ]then echo \"File exists\"else echo \"File does not exist\"fi 运行结果： 1234567File has read accessFile has write permissionFile has execute permissionFile is an ordinary fileThis is not a directoryFile size is zeroFile exists 文件测试运算符列表 操作符** 说明** 举例** -b file 检测文件是否是块设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。 -c file 检测文件是否是字符设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。 -d file 检测文件是否是目录，如果是，则返回 true。 [ -d $file ] 返回 false。 -f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 [ -f $file ] 返回 true。 -g file 检测文件是否设置了 SGID 位，如果是，则返回 true。 [ -g $file ] 返回 false。 -k file 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 [ -k $file ] 返回 false。 -p file 检测文件是否是具名管道，如果是，则返回 true。 [ -p $file ]返回 false。 -u file 检测文件是否设置了 SUID 位，如果是，则返回 true。 [ -u $file ] 返回 false。 -r file 检测文件是否可读，如果是，则返回 true。 [ -r $file ] 返回 true。 -w file 检测文件是否可写，如果是，则返回 true。 [ -w $file ] 返回 true。 -x file 检测文件是否可执行，如果是，则返回 true。 [ -x $file ]返回 true。 -s file 检测文件是否为空（文件大小是否大于0），不为空返回 true。 [ -s $file ]返回 true。 -e file 检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 返回 true。 Shell注释** 以“#”开头的行就是注释，会被解释器忽略。sh里没有多行注释，只能每一行加一个#号。只能像这样： 12345678910111213#--------------------------------------------# 这是一个自动打ipa的脚本，基于webfrogs的ipa-build书写：# https://github.com/webfrogs/xcode_shell/blob/master/ipa-build# 功能：自动为etao ios app打包，产出物为14个渠道的ipa包# 特色：全自动打包，不需要输入任何参数#--------------------------------------------##### 用户配置区 开始 ######## 项目根目录，推荐将此脚本放在项目的根目录，这里就不用改了# 应用名，确保和Xcode里Product下的target_name.app名字一致###### 用户配置区 结束 ##### 如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。 Shell字符串**字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似。 单引号**1str='this is a string' 单引号字符串的限制： · 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的； · 单引号字串中不能出现单引号（对单引号使用转义符后也不行）。 双引号**12your_name='qinjx'str=\"Hello, I know your are \\\"$your_name\\\"! \\n\" 双引号的优点： · 双引号里可以有变量 · 双引号里可以出现转义字符 拼接字符串**12345your_name=\"qinjx\"greeting=\"hello, \"$your_name\" !\"greeting_1=\"hello, $&#123;your_name&#125; !\"echo $greeting $greeting_1 获取字符串长度**12string=\"abcd\"echo $&#123;#string&#125; #输出 4 提取子字符串**12string=\"alibaba is a great company\"echo $&#123;string:1:4&#125; #输出liba 查找子字符串**12string=\"alibaba is a great company\"echo `expr index \"$string\" is` Shell数组：shell数组的定义、数组长度**Shell在编程方面比Windows批处理强大很多，无论是在循环、运算。bash支持一维数组（不支持多维数组），并且没有限定数组的大小。类似与C语言，数组元素的下标由0开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于0。 定义数组**在Shell中，用括号来表示数组，数组元素用“空格”符号分割开。定义数组的一般形式为： 1array_name=(value1 ... valuen) 例如： 1array_name=(value0 value1 value2 value3) 或者 123456array_name=(value0value1value2value3) 还可以单独定义数组的各个分量： 123array_name[0]=value0array_name[1]=value1array_name[2]=value2 可以不使用连续的下标，而且下标的范围没有限制。 读取数组**读取数组元素值的一般格式是： 1$&#123;array_name[index]&#125; 例如： 1valuen=$&#123;array_name[2]&#125; 举个例子： 123456789#!/bin/shNAME[0]=\"Zara\"NAME[1]=\"Qadir\"NAME[2]=\"Mahnaz\"NAME[3]=\"Ayan\"NAME[4]=\"Daisy\"echo \"First Index: $&#123;NAME[0]&#125;\"echo \"Second Index: $&#123;NAME[1]&#125;\" 运行脚本，输出： 123$./test.shFirst Index: ZaraSecond Index: Qadir 使用@ 或 * 可以获取数组中的所有元素，例如： 12$&#123;array_name[*]&#125;$&#123;array_name[@]&#125; 举个例子： 123456789#!/bin/shNAME[0]=\"Zara\"NAME[1]=\"Qadir\"NAME[2]=\"Mahnaz\"NAME[3]=\"Ayan\"NAME[4]=\"Daisy\"echo \"First Method: $&#123;NAME[*]&#125;\"echo \"Second Method: $&#123;NAME[@]&#125;\" 运行脚本，输出： 123$./test.shFirst Method: Zara Qadir Mahnaz Ayan DaisySecond Method: Zara Qadir Mahnaz Ayan Daisy 获取数组的长度**获取数组长度的方法与获取字符串长度的方法相同，例如： 123456# 取得数组元素的个数length=$&#123;#array_name[@]&#125;# 或者length=$&#123;#array_name[*]&#125;# 取得数组单个元素的长度lengthn=$&#123;#array_name[n]&#125; Shell echo命令**echo是Shell的一个内部指令，用于在屏幕上打印出指定的字符串。命令格式： 1echo arg 您可以使用echo实现更复杂的输出格式控制。 显示转义字符**1echo \"\\\"It is a test\\\"\" 结果将是： 1\"It is a test\" 双引号也可以省略。 显示变量**12name=\"OK\"echo \"$name It is a test\" 结果将是： 1OK It is a test 同样双引号也可以省略。如果变量与其它字符相连的话，需要使用大括号（{ }）： 12mouth=8echo \"$&#123;mouth&#125;-1-2009\" 结果将是： 18-1-2009 显示换行**12echo \"OK!\\n\"echo \"It is a test\" 输出： 12OK!It is a test 显示不换行**12echo \"OK!\\c\"echo \"It is a test\" 输出： 1OK!It si a test 显示结果重定向至文件**1echo \"It is a test\" &gt; myfile 原样输出字符串**若需要原样输出字符串（不进行转义），请使用单引号。例如： 1echo '$name\\\"' 显示命令执行结果**1echo `date` 结果将显示当前日期 从上面可看出，双引号可有可无，单引号主要用在原样输出中。 shell printf命令：格式化输出语句**printf 命令用于格式化输出， 是echo命令的增强版。它是C语言printf()库函数的一个有限的变形，并且在语法上有些不同。注意：printf 由 POSIX 标准所定义，移植性要比 echo 好。如同 echo 命令，printf命令也可以输出简单的字符串： 123$printf \"Hello, Shell\\n\"Hello, Shell$ printf 不像echo 那样会自动换行，必须显式添加换行符(\\n)。printf命令的语法： 1printf format-string [arguments...] format-string为格式控制字符串，arguments为参数列表。printf()在C语言入门教程中已经讲到，功能和用法与 printf 命令类似，请查看：C语言格式输出函数printf()详解这里仅说明与C语言printf()函数的不同： · printf 命令不用加括号 · format-string 可以没有引号，但最好加上，单引号双引号均可。 · 参数多于格式控制符(%)时，format-string 可以重用，可以将所有参数都转换。 · arguments 使用空格分隔，不用逗号。 请看下面的例子： 12345678910111213141516171819202122232425262728# format-string为双引号$ printf \"%d %s\\n\" 1 \"abc\"1 abc# 单引号与双引号效果一样 $ printf '%d %s\\n' 1 \"abc\" 1 abc# 没有引号也可以输出$ printf %s abcdefabcdef# 格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用$ printf %s abc defabcdef$ printf \"%s\\n\" abc defabcdef$ printf \"%s %s %s\\n\" a b c d e f g h i ja b cd e fg h ij# 如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替$ printf \"%s and %d \\n\" and 0# 如果以 %d 的格式来显示字符串，那么会有警告，提示无效的数字，此时默认置为 0$ printf \"The first program always prints'%s,%d\\n'\" Hello Shell-bash: printf: Shell: invalid numberThe first program always prints 'Hello,0'$ 注意，根据POSIX标准，浮点格式%e、%E、%f、%g与%G是“不需要被支持”。这是因为awk支持浮点预算，且有它自己的printf语句。这样Shell程序中需要将浮点数值进行格式化的打印时，可使用小型的awk程序实现。然而，内建于bash、ksh93和zsh中的printf命令都支持浮点格式。 Shell if else语句**if语句通过关系运算符判断表达式的真假来决定执行哪个分支。Shell 有三种if … else 语句： · if … fi 语句； · if … else … fi 语句； · if … elif … else … fi 语句。 1) if … else 语句**if … else 语句的语法： 1234if [ expression ]then Statement(s) to be executed if expression is truefi 如果 expression 返回 true，then后边的语句将会被执行；如果返回 false，不会执行任何语句。最后必须以 fi 来结尾闭合 if，fi 就是 if 倒过来拼写，后面也会遇见。注意：expression 和方括号([ ])之间必须有空格，否则会有语法错误。举个例子： 1234567891011121314#!/bin/sha=10b=20if [ $a == $b ]then echo \"a is equal to b\"fiif [ $a != $b ]then echo \"a is not equal to b\"fi 运行结果： 1a is not equal to b 2) if … else … fi 语句**if … else … fi 语句的语法： 123456if [ expression ]then Statement(s) to be executed if expression is trueelse Statement(s) to be executed if expression is not truefi 如果 expression 返回 true，那么 then 后边的语句将会被执行；否则，执行 else 后边的语句。举个例子： 1234567891011#!/bin/sha=10b=20if [ $a == $b ]then echo \"a is equal to b\"else echo \"a is not equal to b\"fi 执行结果： 1a is not equal to b 3) if … elif … fi 语句**if … elif … fi 语句可以对多个条件进行判断，语法为： 123456789101112if [ expression 1 ]then Statement(s) to be executed if expression 1 is trueelif [ expression 2 ]then Statement(s) to be executed if expression 2 is trueelif [ expression 3 ]then Statement(s) to be executed if expression 3 is trueelse Statement(s) to be executed if no expression is truefi 哪一个 expression 的值为 true，就执行哪个 expression 后面的语句；如果都为 false，那么不执行任何语句。举个例子： 1234567891011121314151617#!/bin/sha=10b=20if [ $a == $b ]then echo \"a is equal to b\"elif [ $a -gt $b ]then echo \"a is greater than b\"elif [ $a -lt $b ]then echo \"a is less than b\"else echo \"None of the condition met\"fi 运行结果： 1a is less than b if … else 语句也可以写成一行，以命令的方式来运行，像这样： 1if test $[2*3] -eq $[1+5]; then echo 'The two numbers are equal!'; fi; if … else 语句也经常与 test 命令结合使用，如下所示： 12345678num1=$[2*3]num2=$[1+5]if test $[num1] -eq $[num2]then echo 'The two numbers are equal!'else echo 'The two numbers are not equal!'fi 输出： 1The two numbers are equal! test 命令用于检查某个条件是否成立，与方括号([ ])类似。 Shell test命令**Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。 数值测试** 参数** 说明** -eq 等于则为真 -ne 不等于则为真 -gt 大于则为真 -ge 大于等于则为真 -lt 小于则为真 -le 小于等于则为真 例如： 12345678num1=100num2=100if test $[num1] -eq $[num2]then echo 'The two numbers are equal!'else echo 'The two numbers are not equal!'fi 输出：1The two numbers are equal! 字符串测试** 参数** 说明** = 等于则为真 != 不相等则为真 -z 字符串 字符串长度为0则为真 -n 字符串 字符串长度不为0则为真 例如： 12345678num1=100num2=100if test num1=num2then echo 'The two strings are equal!'else echo 'The two strings are not equal!'fi 输出：1The two strings are equal! 文件测试** 参数** 说明** -e 文件名 如果文件存在则为真 -r 文件名 如果文件存在且可读则为真 -w 文件名 如果文件存在且可写则为真 -x 文件名 如果文件存在且可执行则为真 -s 文件名 如果文件存在且至少有一个字符则为真 -d 文件名 如果文件存在且为目录则为真 -f 文件名 如果文件存在且为普通文件则为真 -c 文件名 如果文件存在且为字符型特殊文件则为真 -b 文件名 如果文件存在且为块特殊文件则为真 例如： 1234567cd /binif test -e ./bashthen echo 'The file already exists!'else echo 'The file does not exists!'fi 输出：1The file already exists! 另外，Shell还提供了与(-a )、或( -o )、非( ! )三个逻辑操作符用于将测试条件连接起来，其优先级为：“!”最高，“-a”次之，“-o”最低。例如： 1234567cd /binif test -e ./notFile -o ./bashthen echo 'One file exists at least!'else echo 'Both dose not exists!'fi 输出：1One file exists at least! Shell case esac语句**case … esac 与其他语言中的 switch … case 语句类似，是一种多分枝选择结构。case 语句匹配一个值或一个模式，如果匹配成功，执行相匹配的命令。case语句格式如下： 1234567891011121314151617case 值 in模式1) command1 command2 command3 ;;模式2） command1 command2 command3 ;;*) command1 command2 command3 ;;esac case工作方式如上所示。取值后面必须为关键字 in，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。;; 与其他语言中的 break 类似，意思是跳到整个 case 语句的最后。取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。下面的脚本提示输入1到4，与每一种模式进行匹配： 123456789101112131415echo 'Input a number between 1 to 4'echo 'Your number is:\\c'read aNumcase $aNum in 1) echo 'You select 1' ;; 2) echo 'You select 2' ;; 3) echo 'You select 3' ;; 4) echo 'You select 4' ;; *) echo 'You do not select a number between 1 to 4' ;;esac 输入不同的内容，会有不同的结果，例如： 123Input a number between 1 to 4Your number is:3You select 3 再举一个例子： 123456789101112131415#!/bin/bashoption=\"$&#123;1&#125;\"case $&#123;option&#125; in -f) FILE=\"$&#123;2&#125;\" echo \"File name is $FILE\" ;; -d) DIR=\"$&#123;2&#125;\" echo \"Dir name is $DIR\" ;; *) echo \"`basename $&#123;0&#125;`:usage: [-f file] | [-d directory]\" exit 1 # Command to come out of the program with status 1 ;;esac 运行结果： 123456789$./test.shtest.sh: usage: [ -f filename ] | [ -d directory ]$ ./test.sh -f index.htm$ vi test.sh$ ./test.sh -f index.htmFile name is index.htm$ ./test.sh -d unixDir name is unix$ Shell for循环**与其他编程语言类似，Shell支持for循环。for循环一般格式为： 1234567for 变量 in 列表do command1 command2 ... commandNdone 列表是一组值（数字、字符串等）组成的序列，每个值通过空格分隔。每循环一次，就将列表中的下一个值赋给变量。in 列表是可选的，如果不用它，for 循环使用命令行的位置参数。例如，顺序输出当前列表中的数字： 1234for loop in 1 2 3 4 5do echo \"The value is: $loop\"done 运行结果： 12345The value is: 1The value is: 2The value is: 3The value is: 4The value is: 5 顺序输出字符串中的字符： 1234for str in 'This is a string'do echo $strdone 运行结果： 1This is a string 显示主目录下以 .bash 开头的文件： 123456#!/bin/bashfor FILE in $HOME/.bash*do echo $FILEdone 运行结果： 1234/root/.bash_history/root/.bash_logout/root/.bash_profile/root/.bashrc Shell while循环**while循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。其格式为： 1234while commanddo Statement(s) to be executed if command is truedone 命令执行完毕，控制返回循环顶部，从头开始直至测试条件为假。以下是一个基本的while循环，测试条件是：如果COUNTER小于5，那么返回 true。COUNTER从0开始，每次循环处理时，COUNTER加1。运行上述脚本，返回数字1到5，然后终止。 123456COUNTER=0while [ $COUNTER -lt 5 ]do COUNTER='expr $COUNTER+1' echo $COUNTERdone 运行脚本，输出： 1234512345 while循环可用于读取键盘信息。下面的例子中，输入信息被设置为变量FILM，按Ctrl-D结束循环。 123456echo 'type &lt;CTRL-D&gt; to terminate'echo -n 'enter your most liked film: 'while read FILMdo echo \"Yeah! great film the $FILM\"done 运行脚本，输出类似下面： 123type &lt;CTRL-D&gt; to terminateenter your most liked film: Sound of MusicYeah! great film the Sound of Music Shell until循环**until 循环执行一系列命令直至条件为 true 时停止。until 循环与 while 循环在处理方式上刚好相反。一般while循环优于until循环，但在某些时候，也只是极少数情况下，until 循环更加有用。until 循环格式为： 1234until commanddo Statement(s) to be executed until command is truedone command 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。例如，使用 until 命令输出 0 ~ 9 的数字： 123456789#!/bin/basha=0until [ ! $a -lt 10 ]do echo $a a=`expr $a + 1`done 运行结果： 123456789100123456789 Shell break和continue命令**在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，像大多数编程语言一样，Shell也使用 break 和 continue 来跳出循环。 break命令**break命令允许跳出所有循环（终止执行后面的所有循环）。下面的例子中，脚本进入死循环直至用户输入数字大于5。要跳出这个循环，返回到shell提示符下，就要使用break命令。 1234567891011121314#!/bin/bashwhile :do echo -n \"Input a number between 1 to 5: \" read aNum case $aNum in 1|2|3|4|5) echo \"Your number is $aNum!\" ;; *) echo \"You do not select a number between 1 to 5, game is over!\" break ;; esacdone 在嵌套循环中，break 命令后面还可以跟一个整数，表示跳出第几层循环。例如： 1break n 表示跳出第 n 层循环。下面是一个嵌套循环的例子，如果 var1 等于 2，并且 var2 等于 0，就跳出循环： 1234567891011121314#!/bin/bashfor var1 in 1 2 3do for var2 in 0 5 do if [ $var1 -eq 2 -a $var2 -eq 0 ] then break 2 else echo \"$var1 $var2\" fi donedone 如上，break 2 表示直接跳出外层循环。运行结果： 121 01 5 continue命令**continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。对上面的例子进行修改： 1234567891011121314#!/bin/bashwhile :do echo -n \"Input a number between 1 to 5: \" read aNum case $aNum in 1|2|3|4|5) echo \"Your number is $aNum!\" ;; *) echo \"You do not select a number between 1 to 5!\" continue echo \"Game is over!\" ;; esacdone 运行代码发现，当输入大于5的数字时，该例中的循环不会结束，语句 1echo \"Game is over!\" 永远不会被执行。同样，continue 后面也可以跟一个数字，表示跳出第几层循环。再看一个 continue 的例子： 1234567891011121314#!/bin/bashNUMS=\"1 2 3 4 5 6 7\"for NUM in $NUMSdo Q=`expr $NUM % 2` if [ $Q -eq 0 ] then echo \"Number is an even number!!\" continue fi echo \"Found odd number\"done 运行结果： 1234567Found odd numberNumber is an even number!!Found odd numberNumber is an even number!!Found odd numberNumber is an even number!!Found odd number Shell函数：Shell函数返回值、删除函数、在终端调用函数**函数可以让我们将一个复杂功能划分成若干模块，让程序结构更加清晰，代码重复利用率更高。像其他编程语言一样，Shell 也支持函数。Shell 函数必须先定义后使用。Shell 函数的定义格式如下：1234function_name () &#123; list of commands [ return value ]&#125; 如果你愿意，也可以在函数名前加上关键字 function： 1234function function_name () &#123; list of commands [ return value ]&#125; 函数返回值，可以显式增加return语句；如果不加，会将最后一条命令运行结果作为返回值。Shell 函数返回值只能是整数，一般用来表示函数执行成功与否，0表示成功，其他值表示失败。如果 return 其他数据，比如一个字符串，往往会得到错误提示：“numeric argument required”。如果一定要让函数返回字符串，那么可以先定义一个变量，用来接收函数的计算结果，脚本在需要的时候访问这个变量来获得函数返回值。先来看一个例子： 123456789#!/bin/bash# Define your function hereHello () &#123; echo \"Url is http://see.xidian.edu.cn/cpp/shell/\"&#125;# Invoke your functionHello 运行结果：?? 123$./test.shHello World$ 调用函数只需要给出函数名，不需要加括号。再来看一个带有return语句的函数： 123456789101112131415#!/bin/bashfunWithReturn()&#123; echo \"The function is to get the sum of two numbers...\" echo -n \"Input first number: \" read aNum echo -n \"Input another number: \" read anotherNum echo \"The two numbers are $aNum and $anotherNum !\" return $(($aNum+$anotherNum))&#125;funWithReturn# Capture value returnd by last commandret=$?echo \"The sum of two numbers is $ret !\" 运行结果： 12345The function is to get the sum of two numbers...Input first number: 25Input another number: 50The two numbers are 25 and 50 !The sum of two numbers is 75 ! 函数返回值在调用该函数后通过 $?来获得。再来看一个函数嵌套的例子： 12345678910111213#!/bin/bash# Calling one function from anothernumber_one () &#123; echo \"Url_1 is http://see.xidian.edu.cn/cpp/shell/\" number_two&#125;number_two () &#123; echo \"Url_2 is http://see.xidian.edu.cn/cpp/u/xitong/\"&#125;number_one 运行结果： 12Url_1 is http://see.xidian.edu.cn/cpp/shell/Url_2 is http://see.xidian.edu.cn/cpp/u/xitong/ 像删除变量一样，删除函数也可以使用 unset 命令，不过要加上.f选项，如下所示： 1$unset .f function_name 如果你希望直接从终端调用函数，可以将函数定义在主目录下的 .profile 文件，这样每次登录后，在命令提示符后面输入函数名字就可以立即调用。 Shell函数参数**在Shell中，调用函数时可以向其传递参数。在函数体内部，通过$n的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数…带参数的函数示例： 123456789101112#!/bin/bashfunWithParam()&#123; echo \"The value of the first parameter is $1 !\" echo \"The value of the second parameter is $2 !\" echo \"The value of the tenth parameter is $10 !\" echo \"The value of the tenth parameter is $&#123;10&#125; !\" echo \"The value of the eleventh parameter is $&#123;11&#125; !\" echo \"The amount of the parameters is $# !\" # 参数个数 echo \"The string of the parameters is $* !\" # 传递给函数的所有参数&#125;funWithParam 1 2 3 4 5 6 7 8 9 34 73 运行脚本： 1234567The value of the first parameter is 1 !The value of the second parameter is 2 !The value of the tenth parameter is 10 !The value of the tenth parameter is 34 !The value of the eleventh parameter is 73 !The amount of the parameters is 12 !The string of the parameters is 1 2 3 4 5 6 7 8 9 34 73 !\" 注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n&gt;=10时，需要使用${n}来获取参数。另外，还有几个特殊变量用来处理参数，前面已经提到： 特殊变量** 说明** $# 传递给函数的参数个数。 $* 显示所有传递给函数的参数。 $@ 与$*相同，但是略有区别，请查看Shell特殊变量。 $? 函数的返回值。 Shell输入输出重定向：Shell Here Document，/dev/null文件**Unix 命令默认从标准输入设备(stdin)获取输入，将结果输出到标准输出设备(stdout)显示。一般情况下，标准输入设备就是键盘，标准输出设备就是终端，即显示器。 输出重定向**命令的输出不仅可以是显示器，还可以很容易的转移向到文件，这被称为输出重定向。命令输出重定向的语法为： 1$ command &gt; file 这样，输出到显示器的内容就可以被重定向到文件。例如，下面的命令在显示器上不会看到任何输出： 1$ who &gt; users 打开 users 文件，可以看到下面的内容： 1234567$ cat usersoko tty01 Sep 12 07:30ai tty15 Sep 12 13:32ruth tty21 Sep 12 10:10pat tty24 Sep 12 13:07steve tty25 Sep 12 13:03$ 输出重定向会覆盖文件内容，请看下面的例子： 1234$ echo line 1 &gt; users$ cat usersline 1$ 如果不希望文件内容被覆盖，可以使用 &gt;&gt; 追加到文件末尾，例如： 12345$ echo line 2 &gt;&gt; users$ cat usersline 1line 2$ 输入重定向**和输出重定向一样，Unix 命令也可以从文件获取输入，语法为： 1command &lt; file 这样，本来需要从键盘获取输入的命令会转移到文件读取内容。注意：输出重定向是大于号(&gt;)，输入重定向是小于号(&lt;)。例如，计算 users 文件中的行数，可以使用下面的命令： 123$ wc -l users2 users$ 也可以将输入重定向到 users 文件： 123$ wc -l &lt; users2$ 注意：上面两个例子的结果不同：第一个例子，会输出文件名；第二个不会，因为它仅仅知道从标准输入读取内容。 重定向深入讲解**一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件： · 标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。 · 标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。 · 标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。 默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。如果希望 stderr 重定向到 file，可以这样写： 1$command 2 &gt; file 如果希望 stderr 追加到 file 文件末尾，可以这样写： 1$command 2 &gt;&gt; file 2 表示标准错误文件(stderr)。如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写： 1$command &gt; file 2&gt;&amp;1 或 1$command &gt;&gt; file 2&gt;&amp;1 如果希望对 stdin 和 stdout 都重定向，可以这样写： 1$command &lt; file1 &gt;file2 command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。 全部可用的重定向命令列表 命令** 说明** command &gt; file 将输出重定向到 file。 command &lt; file 将输入重定向到 file。 command &gt;&gt; file 将输出以追加的方式重定向到 file。 n &gt; file 将文件描述符为 n 的文件重定向到 file。 n &gt;&gt; file 将文件描述符为 n 的文件以追加的方式重定向到 file。 n &gt;&amp; m 将输出文件 m 和 n 合并。 n &lt;&amp; m 将输入文件 m 和 n 合并。 &lt;&lt; tag 将开始标记 tag 和结束标记 tag 之间的内容作为输入。 Here Document**Here Document 目前没有统一的翻译，这里暂译为”嵌入文档“。Here Document 是 Shell 中的一种特殊的重定向方式，它的基本的形式如下： 123command &lt;&lt; delimiter documentdelimiter 它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。注意： · 结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。 · 开始的delimiter前后的空格会被忽略掉。 下面的例子，通过 wc -l 命令计算 document 的行数： 1234567$wc -l &lt;&lt; EOF This is a simple lookup program for good (and bad) restaurants in Cape Town.EOF3$ 也可以 将 Here Document 用在脚本中，例如： 1234567#!/bin/bashcat &lt;&lt; EOFThis is a simple lookup programfor good (and bad) restaurantsin Cape Town.EOF 运行结果： 123This is a simple lookup programfor good (and bad) restaurantsin Cape Town. 下面的脚本通过 vi 编辑器将 document 保存到 test.txt 文件： 12345678910#!/bin/shfilename=test.txtvi $filename &lt;&lt;EndOfCommandsiThis file was created automatically froma shell script^[ZZEndOfCommands 运行脚本： 123$ sh test.shVim: Warning: Input is not from a terminal$ 打开 test.txt，可以看到下面的内容： 1234$ cat test.txtThis file was created automatically froma shell script$ /dev/null 文件**如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null： 1$ command &gt; /dev/null /dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到”禁止输出“的效果。如果希望屏蔽 stdout 和 stderr，可以这样写：1$ command &gt; /dev/null 2&gt;&amp;1 Shell文件包含**像其他语言一样，Shell 也可以包含外部脚本，将外部脚本的内容合并到当前脚本。Shell 中包含脚本可以使用： 1. filename 或1source filename 两种方式的效果相同，简单起见，一般使用点号(.)，但是注意点号(.)和文件名中间有一空格。例如，创建两个脚本，一个是被调用脚本 subscript.sh，内容如下： 1url=\"http://see.xidian.edu.cn/cpp/view/2738.html\" 一个是主文件 main.sh，内容如下： 123#!/bin/bash. ./subscript.shecho $url 执行脚本： 1234$chomd +x main.sh./main.shhttp://see.xidian.edu.cn/cpp/view/2738.html$ 注意：被包含脚本不需要有执行权限。","categories":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/categories/shell/"}],"tags":[]},{"title":"webpack3.0 配置","slug":"webpack-setting","date":"2017-06-25T16:00:00.000Z","updated":"2017-06-26T07:10:49.135Z","comments":true,"path":"2017/06/26/webpack-setting/","link":"","permalink":"http://yoursite.com/2017/06/26/webpack-setting/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372const path = require('path');module.exports = &#123; entry: \"./app/entry\", // string | object | array entry: [\"./app/entry1\", \"./app/entry2\"], entry: &#123; a: \"./app/entry-a\", b: [\"./app/entry-b1\", \"./app/entry-b2\"] &#125;, // 这里应用程序开始执行 // webpack 开始打包 output: &#123; // webpack 如何输出结果的相关选项 path: path.resolve(__dirname, \"dist\"), // string // 所有输出文件的目标路径 // 必须是绝对路径（使用 Node.js 的 path 模块） filename: \"bundle.js\", // string filename: \"[name].js\", // 用于多个入口点(entry point)（出口点？） filename: \"[chunkhash].js\", // 用于长效缓存 // 「入口分块(entry chunk)」的文件名模板（出口分块？） publicPath: \"/assets/\", // string publicPath: \"\", publicPath: \"https://cdn.example.com/\", // 输出解析文件的目录，url 相对于 HTML 页面 library: \"MyLibrary\", // string, // 导出库(exported library)的名称 libraryTarget: \"umd\", // 通用模块定义 libraryTarget: \"umd2\", // 通用模块定义 libraryTarget: \"commonjs2\", // exported with module.exports libraryTarget: \"commonjs-module\", // 使用 module.exports 导出 libraryTarget: \"commonjs\", // 作为 exports 的属性导出 libraryTarget: \"amd\", // 使用 AMD 定义方法来定义 libraryTarget: \"this\", // 在 this 上设置属性 libraryTarget: \"var\", // 变量定义于根作用域下 libraryTarget: \"assign\", // 盲分配(blind assignment) libraryTarget: \"window\", // 在 window 对象上设置属性 libraryTarget: \"global\", // property set to global object libraryTarget: \"jsonp\", // jsonp wrapper // 导出库(exported library)的类型 /* 高级输出配置（点击显示） */ pathinfo: true, // boolean // 在生成代码时，引入相关的模块、导出、请求等有帮助的路径信息。 chunkFilename: \"[id].js\", chunkFilename: \"[chunkhash].js\", // 长效缓存(/guides/caching) // 「附加分块(additional chunk)」的文件名模板 jsonpFunction: \"myWebpackJsonp\", // string // 用于加载分块的 JSONP 函数名 sourceMapFilename: \"[file].map\", // string sourceMapFilename: \"sourcemaps/[file].map\", // string // 「source map 位置」的文件名模板 devtoolModuleFilenameTemplate: \"webpack:///[resource-path]\", // string // 「devtool 中模块」的文件名模板 devtoolFallbackModuleFilenameTemplate: \"webpack:///[resource-path]?[hash]\", // string // 「devtool 中模块」的文件名模板（用于冲突） umdNamedDefine: true, // boolean // 在 UMD 库中使用命名的 AMD 模块 crossOriginLoading: \"use-credentials\", // 枚举 crossOriginLoading: \"anonymous\", crossOriginLoading: false, // 指定运行时如何发出跨域请求问题 /* 专家级输出配置（自行承担风险） */ &#125;, module: &#123; // 关于模块配置 rules: [ // 模块规则（配置 loader、解析器等选项） &#123; test: /\\.jsx?$/, include: [ path.resolve(__dirname, \"app\") ], exclude: [ path.resolve(__dirname, \"app/demo-files\") ], // 这里是匹配条件，每个选项都接收一个正则表达式或字符串 // test 和 include 具有相同的作用，都是必须匹配选项 // exclude 是必不匹配选项（优先于 test 和 include） // 最佳实践： // - 只在 test 和 文件名匹配 中使用正则表达式 // - 在 include 和 exclude 中使用绝对路径数组 // - 尽量避免 exclude，更倾向于使用 include issuer: &#123; test, include, exclude &#125;, // issuer 条件（导入源） enforce: \"pre\", enforce: \"post\", // 标识应用这些规则，即使规则覆盖（高级选项） loader: \"babel-loader\", // 应该应用的 loader，它相对上下文解析 // 为了更清晰，`-loader` 后缀在 webpack 2 中不再是可选的 // 查看 webpack 1 升级指南。 options: &#123; presets: [\"es2015\"] &#125;, // loader 的可选项 &#125;, &#123; test: \"\\.html$\" use: [ // 应用多个 loader 和选项 \"htmllint-loader\", &#123; loader: \"html-loader\", options: &#123; /* ... */ &#125; &#125; ] &#125;, &#123; oneOf: [ /* rules */ ] &#125;, // 只使用这些嵌套规则之一 &#123; rules: [ /* rules */ ] &#125;, // 使用所有这些嵌套规则（合并可用条件） &#123; resource: &#123; and: [ /* 条件 */ ] &#125; &#125;, // 仅当所有条件都匹配时才匹配 &#123; resource: &#123; or: [ /* 条件 */ ] &#125; &#125;, &#123; resource: [ /* 条件 */ ] &#125;, // 任意条件匹配时匹配（默认为数组） &#123; resource: &#123; not: /* 条件 */ &#125; &#125; // 条件不匹配时匹配 ], /* 高级模块配置（点击展示） */ noParse: [ /special-library\\.js$/ ], // 不解析这里的模块 unknownContextRequest: \".\", unknownContextRecursive: true, unknownContextRegExp: /^\\.\\/.*$/, unknownContextCritical: true, exprContextRequest: \".\", exprContextRegExp: /^\\.\\/.*$/, exprContextRecursive: true, exprContextCritical: true, wrappedContextRegExp: /.*/, wrappedContextRecursive: true, wrappedContextCritical: false, // specifies default behavior for dynamic requests &#125;, resolve: &#123; // 解析模块请求的选项 // （不适用于对 loader 解析） modules: [ \"node_modules\", path.resolve(__dirname, \"app\") ], // 用于查找模块的目录 extensions: [\".js\", \".json\", \".jsx\", \".css\"], // 使用的扩展名 alias: &#123; // 模块别名列表 \"module\": \"new-module\", // 起别名：\"module\" -&gt; \"new-module\" 和 \"module/path/file\" -&gt; \"new-module/path/file\" \"only-module$\": \"new-module\", // 起别名 \"only-module\" -&gt; \"new-module\"，但不匹配 \"module/path/file\" -&gt; \"new-module/path/file\" \"module\": path.resolve(__dirname, \"app/third/module.js\"), // 起别名 \"module\" -&gt; \"./app/third/module.js\" 和 \"module/file\" 会导致错误 // 模块别名相对于当前上下文导入 &#125;, /* 可供选择的别名语法（点击展示） */ alias: [ &#123; name: \"module\", // 旧的请求 alias: \"new-module\", // 新的请求 onlyModule: true // 如果为 true，只有 \"module\" 是别名 // 如果为 false，\"module/inner/path\" 也是别名 &#125; ], /* 高级解析选项（点击展示） */ symlinks: true, // 遵循符号链接(symlinks)到新位置 descriptionFiles: [\"package.json\"], // 从 package 描述中读取的文件 mainFields: [\"main\"], // 从描述文件中读取的属性 // 当请求文件夹时 aliasFields: [\"browser\"], // 从描述文件中读取的属性 // 以对此 package 的请求起别名 enforceExtension: false, // 如果为 true，请求必不包括扩展名 // 如果为 false，请求可以包括扩展名 moduleExtensions: [\"-module\"], enforceModuleExtension: false, // 类似 extensions/enforceExtension，但是用模块名替换文件 unsafeCache: true, unsafeCache: &#123;&#125;, // 为解析的请求启用缓存 // 这是不安全，因为文件夹结构可能会改动 // 但是性能改善是很大的 cachePredicate: (path, request) =&gt; true, // predicate function which selects requests for caching plugins: [ // ... ] // 应用于解析器的附加插件 &#125;, performance: &#123; hints: \"warning\", // 枚举 hints: \"error\", // 性能提示中抛出错误 hints: false, // 关闭性能提示 maxAssetSize: 200000, // 整数类型（以字节为单位） maxEntrypointSize: 400000, // 整数类型（以字节为单位） assetFilter: function(assetFilename) &#123; // 提供资源文件名的断言函数 return assetFilename.endsWith('.css') || assetFilename.endsWith('.js'); &#125; &#125;, devtool: \"source-map\", // enum devtool: \"inline-source-map\", // 嵌入到源文件中 devtool: \"eval-source-map\", // 将 SourceMap 嵌入到每个模块中 devtool: \"hidden-source-map\", // SourceMap 不在源文件中引用 devtool: \"cheap-source-map\", // 没有模块映射(module mappings)的 SourceMap 低级变体(cheap-variant) devtool: \"cheap-module-source-map\", // 有模块映射(module mappings)的 SourceMap 低级变体 devtool: \"eval\", // 没有模块映射，而是命名模块。以牺牲细节达到最快。 // 通过在浏览器调试工具(browser devtools)中添加元信息(meta info)增强调试 // 牺牲了构建速度的 `source-map' 是最详细的。 context: __dirname, // string（绝对路径！） // webpack 的主目录 // entry 和 module.rules.loader 选项 // 相对于此目录解析 target: \"web\", // 枚举 target: \"webworker\", // WebWorker target: \"node\", // node.js 通过 require target: \"async-node\", // Node.js 通过 fs and vm target: \"node-webkit\", // nw.js target: \"electron-main\", // electron，主进程(main process) target: \"electron-renderer\", // electron，渲染进程(renderer process) target: (compiler) =&gt; &#123; /* ... */ &#125;, // 自定义 // 包(bundle)应该运行的环境 // 更改 块加载行为(chunk loading behavior) 和 可用模块(available module) externals: [\"react\", /^@angular\\//], externals: \"react\", // string（精确匹配） externals: /^[a-z\\-]+($|\\/)/, // 正则 externals: &#123; // 对象 angular: \"this angular\", // this[\"angular\"] react: &#123; // UMD commonjs: \"react\", commonjs2: \"react\", amd: \"react\", root: \"React\" &#125; &#125;, externals: (request) =&gt; &#123; /* ... */ return \"commonjs \" + request &#125; // 不要遵循/打包这些模块，而是在运行时从环境中请求他们 stats: \"errors-only\", stats: &#123; //object assets: true, colors: true, errors: true, errorDetails: true, hash: true, // ... &#125;, // 精确控制要显示的 bundle 信息 devServer: &#123; proxy: &#123; // proxy URLs to backend development server '/api': 'http://localhost:3000' &#125;, contentBase: path.join(__dirname, 'public'), // boolean | string | array, static file location compress: true, // enable gzip compression historyApiFallback: true, // true for index.html upon 404, object for multiple paths hot: true, // hot module replacement. Depends on HotModuleReplacementPlugin https: false, // true for self-signed, object for cert authority noInfo: true, // only errors &amp; warns on hot reload // ... &#125;, plugins: [ // ... ], // 附加插件列表 /* 高级配置（点击展示） */ resolveLoader: &#123; /* 等同于 resolve */ &#125; // 独立解析选项的 loader profile: true, // boolean // 捕获时机信息 bail: true, //boolean // 在第一个错误出错时抛出，而不是无视错误。 cache: false, // boolean // 禁用/启用缓存 watch: true, // boolean // 启用观察 watchOptions: &#123; aggregateTimeout: 1000, // in ms // 将多个更改聚合到单个重构建(rebuild) poll: true, poll: 500, // 间隔单位 ms // 启用轮询观察模式 // 必须用在不通知更改的文件系统中 // 即 nfs shares（译者注：Network FileSystem，最大的功能就是可以透過網路，讓不同的機器、不同的作業系統、可以彼此分享個別的檔案 ( share file )） &#125;, node: &#123; /* TODO */ &#125;, recordsPath: path.resolve(__dirname, \"build/records.json\"), recordsInputPath: path.resolve(__dirname, \"build/records.json\"), recordsOutputPath: path.resolve(__dirname, \"build/records.json\"), // TODO&#125;","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"ES6中的模块介绍","slug":"es6-model","date":"2017-05-17T07:44:45.000Z","updated":"2017-05-19T09:38:39.257Z","comments":true,"path":"2017/05/17/es6-model/","link":"","permalink":"http://yoursite.com/2017/05/17/es6-model/","excerpt":"","text":"ES6在语言规格的层面上，实现了模块功能，而且实现得相当简单，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。 ES6模块主要有两个功能：export和import export用于对外输出本模块（一个文件可以理解为一个模块）变量的接口 import用于在一个模块中加载另一个含有export接口的模块。 以对象属性形式的export和import1234567//export.jslet var1=1;let var2=2;function method1()&#123;&#125;let method2=function()&#123;&#125;export &#123;var1,var2,method1,method2&#125; 12345//export.jsexport let var1=1;export let var2=2;export function method1()&#123;&#125;export let method2=function()&#123;&#125; 123456789//import.jsimport&#123;var1,var2,method1,method2&#125; from \"./export.js\"import * as myVar from \"./export.js\"console.log(var1,var2,method1,method2,myVar)//1//2 //method1() &#123;&#125; //method2() &#123;&#125; //Object &#123;var1: 1, var2: 2, method1:method1(),method2:method2(),default: \"aaaa\",__esModule: true&#125; 以模板形式的export和import123456//export.jsexport default let x=1;1212//import.jsimport x from \"./export.js\";console.log(x) //输出的是x 可以发现，通过export模板的话，输出的格式不是以对象的形式{x}，而是直接的x。","categories":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/categories/es6/"}],"tags":[]},{"title":"路由的配置项","slug":"react-router","date":"2017-05-17T07:35:12.000Z","updated":"2017-05-19T08:40:22.009Z","comments":true,"path":"2017/05/17/react-router/","link":"","permalink":"http://yoursite.com/2017/05/17/react-router/","excerpt":"","text":"路由的基本使用方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import React from 'react'import &#123; render &#125; from 'react-dom'import &#123; Router, Route, Link &#125; from 'react-router'const App = React.createClass(&#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;App&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=\"/about\"&gt;About&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/inbox\"&gt;Inbox&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &#123;this.props.children&#125; &lt;/div&gt; ) &#125;&#125;)const About = React.createClass(&#123; render() &#123; return &lt;h3&gt;About&lt;/h3&gt; &#125;&#125;)const Inbox = React.createClass(&#123; render() &#123; return ( &lt;div&gt; &lt;h2&gt;Inbox&lt;/h2&gt; &#123;this.props.children || \"Welcome to your Inbox\"&#125; &lt;/div&gt; ) &#125;&#125;)const Message = React.createClass(&#123; render() &#123; return &lt;h3&gt;Message &#123;this.props.params.id&#125;&lt;/h3&gt; &#125;&#125;)render(( &lt;Router&gt; &lt;Route path=\"/\" component=&#123;App&#125;&gt; &lt;Route path=\"about\" component=&#123;About&#125; /&gt; &lt;Route path=\"inbox\" component=&#123;Inbox&#125;&gt; &lt;Route path=\"messages/:id\" component=&#123;Message&#125; /&gt; &lt;/Route&gt; &lt;/Route&gt; &lt;/Router&gt;), document.body) 如果路由按这种配置，我们就可以得到路由与URL的映射表： URL Components / App /about App -&gt; About /inbox App -&gt; Inbox /inbox/messages/:id App -&gt; Inbox -&gt; Message Router的基础配置（1）路由默认首页（IndexRoute） 当URL为/的时候，我们需要增加一个默认的初始显示子组件。我们可以通过IndexRoute来设置默认页。 1234567891011121314151617181920import &#123; IndexRoute &#125; from 'react-router'const Dashboard = React.createClass(&#123; render() &#123; return &lt;div&gt;Welcome to the app!&lt;/div&gt; &#125;&#125;)render(( &lt;Router&gt; &lt;Route path=\"/\" component=&#123;App&#125;&gt; &#123;/* Show the dashboard at / */&#125; &lt;IndexRoute component=&#123;Dashboard&#125; /&gt; &lt;Route path=\"about\" component=&#123;About&#125; /&gt; &lt;Route path=\"inbox\" component=&#123;Inbox&#125;&gt; &lt;Route path=\"messages/:id\" component=&#123;Message&#125; /&gt; &lt;/Route&gt; &lt;/Route&gt; &lt;/Router&gt;), document.body) 通过这样的设置，现在我们就有了默认元素了，这种方式类似于apache的直接根目录（directorIndex）或 者是nginx的index.是对直接根路径匹配路由，下面我们来看现在这种方式下的路由与URL的关系： URL Components / App -&gt; Dashboard /about App -&gt; About /inbox App -&gt; Inbox /inbox/messages/:id App -&gt; Inbox -&gt; Message 我们发现与上面相比，这里多了默认的首页路由：url为：/，路由的组件为App -&gt;Dashboard （2）从URL中解耦UI 如果我们能从URL为/inbox/messages/:id 的路由中，移除/inbox使得路由的真正页面为：/message/:id 同时保留了JSX的页面结构，React-router允许我们使用这种缺省路径的方法。我们来看如下代码： 1234567891011121314render(( &lt;Router&gt; &lt;Route path=\"/\" component=&#123;App&#125;&gt; &lt;IndexRoute component=&#123;Dashboard&#125; /&gt; &lt;Route path=\"about\" component=&#123;About&#125; /&gt; &lt;Route path=\"inbox\" component=&#123;Inbox&#125; /&gt; &#123;/* Use /messages/:id instead of /inbox/messages/:id */&#125; &lt;Route component=&#123;Inbox&#125;&gt; &lt;Route path=\"messages/:id\" component=&#123;Message&#125; /&gt; &lt;/Route&gt; &lt;/Route&gt; &lt;/Router&gt;), document.body) 注意：这里的message所在的父路由，缺省了path，这样实际上我们就将路由从/inbox/message/:id转化 成为了/message/:id，但是整体的JSX结构并没有发生变化，只是缺省了path而已。这种缺省的方式， 使得我们能够避免非常复杂的层层url的书写方式，这样使得我们整个路由的控制显得简单名了。这种方式 的访问结果如下： URl Components / App -&gt; Dashboard /about App -&gt; About /inbox App -&gt; Inbox /messages/:id App -&gt; Inbox -&gt; Message 上图中，值得注意的是我们只要通过url: /message/:id就可以访问到组件：App -&gt; Inbox -&gt; Message，大大的简化了url，但是访问结果却与inbox/message/:id完全相同。 （3）重定向路由（Redirect） 通过Redirect，我们可以重新定向路由。我们来看下面的例子： 12345678910111213141516171819import &#123; Redirect &#125; from 'react-router'render(( &lt;Router&gt; &lt;Route path=\"/\" component=&#123;App&#125;&gt; &lt;IndexRoute component=&#123;Dashboard&#125; /&gt; &lt;Route path=\"about\" component=&#123;About&#125; /&gt; &lt;Route path=\"inbox\" component=&#123;Inbox&#125;&gt; &#123;/* Redirect /inbox/messages/:id to /messages/:id */&#125; &lt;Redirect from=\"messages/:id\" to=\"/messages/:id\" /&gt; &lt;/Route&gt; &lt;Route component=&#123;Inbox&#125;&gt; &lt;Route path=\"messages/:id\" component=&#123;Message&#125; /&gt; &lt;/Route&gt; &lt;/Route&gt; &lt;/Router&gt;), document.body) 现在，当我们访问/inbox/message/:id的时候，路由会自动跳转到新的url：/message/:id，这样我们就实现了路由的重定向。 （4）路由的leave和enter,路由的进入和移除的过程 路由定义了进入和移除时的hook，也就是路由的移入或者移除的时候会触发一定的事件，这些hooks是非常 有用的，比如路由移入（进入访问）的时候需要做一个权限认证，或者说路由移除（移除访问）的时候需要 保存一些参数等，我们来看什么时候会触发leave hook，什么时候会触发enter hook。 举一个例子：当我们从url：/messages/5，跳转到新的url：/about的过程。 （a）首先触发/messages/:id 路由的leave hook （b）再次触发/inbox路由的leave hook （c）最后触发/about路由的enter hook （5）利用插件的方法来配置路由，并且同时根据leave和enter hook，在JS中实现Redirect 123456789101112131415161718192021222324const routes = &#123; path: '/', component: App, indexRoute: &#123; component: Dashboard &#125;, childRoutes: [ &#123; path: 'about', component: About &#125;, &#123; path: 'inbox', component: Inbox, childRoutes: [&#123; path: 'messages/:id', onEnter: (&#123; params &#125;, replace) =&gt; replace(`/messages/$&#123;params.id&#125;`) &#125;] &#125;, &#123; component: Inbox, childRoutes: [&#123; path: 'messages/:id', component: Message &#125;] &#125; ]&#125;render(&lt;Router routes=&#123;routes&#125; /&gt;, document.body) 这里通过onEnter中的方法来触发重定向，从而实现Redirect. 参考地址 Reacter-router（config）基础配置项","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[]},{"title":"react-scu","slug":"react-scu","date":"2017-05-17T07:20:09.000Z","updated":"2017-05-19T08:46:50.095Z","comments":true,"path":"2017/05/17/react-scu/","link":"","permalink":"http://yoursite.com/2017/05/17/react-scu/","excerpt":"","text":"shouldComponentUpdate，就是指明什么时候component（组件）需要进行更新。 常见的shouldComponentUpdate的用法（1）比如在下面的例子中，组件中只有2个值，props.color和state.count可以发生改变，我们可以这样 使用shouldComponentUpdate。 123456789101112131415161718192021222324class CounterButton extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;count: 1&#125;; &#125; shouldComponentUpdate(nextProps, nextState) &#123; if (this.props.color !== nextProps.color) &#123; return true; &#125; if (this.state.count !== nextState.count) &#123; return true; &#125; return false; &#125; render() &#123; &lt;button color=&#123;this.props.color&#125; onClick=&#123;() =&gt; this.setState(state =&gt; (&#123;count: state.count + 1&#125;))&#125;&gt; Count: &#123;this.state.count&#125; &lt;/button&gt; &#125;&#125; 在上述代码中，组件仅仅会校验prop.color和state.count,如果这些值都不会改变，那么组件就不会有更新。 （2）如果组件更加复杂，拥有的状态变量更多 当组件复杂化，拥有状态变多时，我们需要设计一种模式，对所有的props变量和state变量，做一个“shallow comparison(浅比较）”，这样会使得shouldComponentUpdate函数冗杂化，为了解决该问题，React给了我们提供了另一个继承方法——React.PureComponent： 1234567891011121314class CounterButton extends React.PureComponent &#123; constructor(props) &#123; super(props); this.state = &#123;count: 1&#125;; &#125; render() &#123; &lt;button color=&#123;this.props.color&#125; onClick=&#123;() =&gt; this.setState(state =&gt; (&#123;count: state.count + 1&#125;))&#125;&gt; Count: &#123;this.state.count&#125; &lt;/button&gt; &#125;&#125; 在大多数的情况下，”shallow comparison（浅比较）”是有意义的，因此在大部门情况下我们可以用React.PureComponent来代替shouldComponentUpdate，但是当props和state中的变量发生突变的情况下，“shallow comparison”会失效，因此在props和state的变量发生突变的情况下，不能通过React.PureComponent来更新组件。 shallow comparison失效的情况shallow comparion在js中： 1234var x=[1,2];var y=x;x.push(3);console.log(x==y)//输出true 1234var x=&#123;a:1&#125;;var y=x;x.b=2;console.log(x==y)//输出true 从上面我们可以看出，shallow comparison不能进行深层比较的原因是，js中数组和对象的本质都是Object，一旦赋值y=x后，无论x如何变化，x,y都会只想的是同一个对象。 如何解决shallow comparison失效的问题失效状态1： 123456handleClick() &#123; // This section is bad style and causes a bug const words = this.state.words; words.push('marklar'); this.setState(&#123;words: words&#125;); &#125; 解决方法： 12345handleClick() &#123; this.setState(prevState =&gt; (&#123; words: prevState.words.concat(['marklar']) &#125;));&#125; 失效状态2： 123function updateColorMap(colormap) &#123; colormap.right = 'blue';&#125; 解决方法： 123function updateColorMap(colormap) &#123; return Object.assign(&#123;&#125;, colormap, &#123;right: 'blue'&#125;);&#125; 本质:解决方法的本质是生成了一个新的对象，新对象与原对象比较一定返回的是false。 另一种方法是通过插件Immutable.js解决，不详细描述。 参考地址 React高级教程（es6）——（4）ShouldComponentUpdate的用法","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[]},{"title":"React中的Context","slug":"react-context","date":"2017-05-17T07:07:23.000Z","updated":"2017-05-17T07:11:32.077Z","comments":true,"path":"2017/05/17/react-context/","link":"","permalink":"http://yoursite.com/2017/05/17/react-context/","excerpt":"","text":"简介：在React中，数据可以以流的形式自上而下的传递，每当你使用一个组件的时候，你可以看到组件的props属性会自上而下的传递。但是，在某些情况下，我们不想通过父组件的props属性一级一级的往下传递，我们希望在某一级子组件中，直接得到上N级父组件中props中的值。 一般情况下通过props传值的情况1234567891011121314151617181920212223242526272829class Button extends React.Component &#123; render() &#123; return ( &lt;button style=&#123;&#123;background: this.props.color&#125;&#125;&gt; &#123;this.props.children&#125; &lt;/button&gt; ); &#125;&#125;class Message extends React.Component &#123; render() &#123; return ( &lt;div&gt; &#123;this.props.text&#125; &lt;Button color=&#123;this.props.color&#125;&gt;Delete&lt;/Button&gt; &lt;/div&gt; ); &#125;&#125;class MessageList extends React.Component &#123; render() &#123; const color = \"purple\"; const children = this.props.messages.map((message) =&gt; &lt;Message text=&#123;message.text&#125; color=&#123;color&#125; /&gt; ); return &lt;div&gt;&#123;children&#125;&lt;/div&gt;; &#125;&#125; 我们来分析一下这段代码，大致的组件分为3级: 顶层MessageLists——&gt;Message一级子类——&gt;Button底层子类 我们来看从父组件到子组件的值的传递情况： （1）text: 我们可以看到，在顶层组件MessageLists中的值，传递到一级子组件Message中，并在此组件中被使用。 （2）color: 再看props中的color的传递情况，在顶层组件MessageLists中的值，先传递到一级子组件Message中， 在传递到二级子组件Button中，最后在二级子组件中被使用。 综上：这就是一般在React中，所使用的通过props属性，在父组件与子组件中进行值传递。 如何利用React中的Context来进行值的越级传递。12345678910111213141516171819202122232425262728293031323334353637383940class Button extends React.Component &#123; render() &#123; return ( &lt;button style=&#123;&#123;background: this.context.color&#125;&#125;&gt; &#123;this.props.children&#125; &lt;/button&gt; ); &#125;&#125;Button.contextTypes = &#123; color: React.PropTypes.string&#125;;class Message extends React.Component &#123; render() &#123; return ( &lt;div&gt; &#123;this.props.text&#125; &lt;Button&gt;Delete&lt;/Button&gt; &lt;/div&gt; ); &#125;&#125;class MessageList extends React.Component &#123; getChildContext() &#123; return &#123;color: \"purple\"&#125;; &#125; render() &#123; const children = this.props.messages.map((message) =&gt; &lt;Message text=&#123;message.text&#125; /&gt; ); return &lt;div&gt;&#123;children&#125;&lt;/div&gt;; &#125;&#125;MessageList.childContextTypes = &#123; color: React.PropTypes.string&#125;; 上述代码，我们实现了通过React的Context实现了值——color的越级传递。我们来分析一下上述的方法。 （1）首先在顶层组件中： 123MessageList.childContextTypes = &#123; color: React.PropTypes.string&#125;; 定义了顶层组件所拥有的子类context对象——该顶层组件所拥有的的子类context对象为color，且必须为字符串。 然后通过getChildText方法，来给子context对象的属性赋值： 123getChildContext() &#123; return &#123;color: \"purple\"&#125;; &#125; 这样就完成了顶层组件中，context对象的赋值。 （2）越级传递，因为color属性只在最底层使用 我们来看color属性的越级传递，因为color属性，在一级子组件Message中并没有直接用到，因此我们可以 直接传递到最底层（越级），在Button组件中使用。 首先Button组件中，再次声明了所接受到的context的子组件color的类型，声明必须为字符串： 123Button.contextTypes = &#123; color: React.PropTypes.string&#125;; 然后可以通过this.context.color这种方式调用： 123&lt;button style=&#123;&#123;background: this.context.color&#125;&#125;&gt; &#123;this.props.children&#125;&lt;/button&gt;123123 综上：这样，我们发现通过Context，我们就能实现值得越级传递。 参考地址 React高级教程（es6）——（3）React中的Context","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[]},{"title":"JSX语法深入理解","slug":"react-jsx-syntax","date":"2017-05-17T06:51:31.000Z","updated":"2017-05-17T06:53:20.705Z","comments":true,"path":"2017/05/17/react-jsx-syntax/","link":"","permalink":"http://yoursite.com/2017/05/17/react-jsx-syntax/","excerpt":"","text":"简介：从根本上来说，JSX语法提供了一种创建React元素的语法糖，JSX语句可以编译成：React.createElement(component, props, …children)的形式，比如： 123&lt;MyButton color=\"blue\" shadowSize=&#123;2&#125;&gt; Click Me&lt;/MyButton&gt; 编译结果： 12345React.createElement( MyButton, &#123;color: 'blue', shadowSize: 2&#125;, 'Click Me') 指定React元素的类型JSX标签的头部，决定了React元素的类型，大写的标签，意味着JSX的标签与React的组件一一对应，比如 1&lt;Foo/&gt;标签就对应了Foo组件 （1）必须包裹在一定的范围内 1234567import React from 'react';import CustomButton from './CustomButton';function WarningButton() &#123; // return React.createElement(CustomButton, &#123;color: 'red'&#125;, null); return &lt;CustomButton color=\"red\" /&gt;;&#125; 比如这样，引入了2个组件，构成了一个新的组件WarningButton，组件的返回值的元素，必须包含在一定范围内，这里通过函数的’{ ‘, ’ } ‘实现包裹的效果。 （2）用户定义的组件必须大写 我们前面已经说过，JSX的标签与组件是一一对应的，当我们使用JSX语法，引用组件的时候，标签必须要大写（同时定义组件的函数名也必须是大写的）。 1234567function Hello()&#123; return &lt;h2&gt;Hello,World&lt;/h2&gt;&#125;//定义过程&lt;Hello/&gt;//使用过程 （3）不能在运行期间，动态的选择类型我们不能在JSX中，动态的规定组件的类型，举例来说： 123456789101112import React from 'react';import &#123; PhotoStory, VideoStory &#125; from './stories';const components = &#123; photo: PhotoStory, video: VideoStory&#125;;function Story(props) &#123; return &lt;components[props.storyType] story=&#123;props.story&#125; /&gt;; //这样写是不对的，我们在返回的组件中，动态定义了组件，这种动态的定义是无效的&#125; 应该改写为： 1234567891011121314import React from 'react';import &#123; PhotoStory, VideoStory &#125; from './stories';const components = &#123; photo: PhotoStory, video: VideoStory&#125;;function Story(props) &#123; const SpecificStory = components[props.storyType]; return &lt; SpecificStory story=&#123;props.story&#125; /&gt;; //这样就是正确的，我们不要在JSX的标签中使用动态定义&#125; JSX中的Props属性（1）JS表达式可以通过{}，包裹js的语法来使用。比如： 1&lt;MyComponent foo=&#123;1 + 2 + 3 + 4&#125; /&gt; 等价于： 1&lt;MyComponent foo=&#123;10&#125; /&gt; 如果不是js表达式，则不能包裹在{}中使用。 （2）Props属性的默认值Props上的属性可以有默认值，并且默认值为true，比如： 12&lt;MyTextBox autocomplete /&gt;&lt;MyTextBox autocomplete=&#123;true&#125; /&gt; 上面这两个式子是等价的，但是不推荐使用默认值，因为在ES6的语法中{foo}代表的意思是：{foo:foo}的意思，并不是{foo:true}。 （3）扩展属性可以通过ES6的…方法，给组件赋属性值，例如： 12345678function App1() &#123; return &lt;Greeting firstName=\"Ben\" lastName=\"Hector\" /&gt;;&#125;function App2() &#123; const props = &#123;firstName: 'Ben', lastName: 'Hector'&#125;; return &lt;Greeting &#123;...props&#125; /&gt;;&#125; 上面的这两种方式是等价的。 JSX中的children（1）children中的function 我们来考虑自定义组件中包含函数的情况： 1234567function ListOfTenThings() &#123; return ( &lt;Repeat numTimes=&#123;10&#125;&gt; &#123;(index) =&gt; &lt;div key=&#123;index&#125;&gt;This is item &#123;index&#125; in the list&lt;/div&gt;&#125; &lt;/Repeat&gt; );&#125; 那么何时调用这个children中的方法呢？ 1234567function Repeat(props) &#123; let items = []; for (let i = 0; i &lt; props.numTimes; i++) &#123; items.push(props.children(i)); &#125; return &lt;div&gt;&#123;items&#125;&lt;/div&gt;;&#125; 我们从上述的Repeat组件的定义中可以看出来，children中的方法按此定义会一直执行10次。 （2）忽略Boolean，Null以及Undefined false,null,undefined以及true是不能通过render()方法，呈现在页面上的，下面的这些div块的样式相同，都是空白块： 12345&lt;div /&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&#123;false&#125;&lt;/div&gt;&lt;div&gt;&#123;null&#125;&lt;/div&gt;&lt;div&gt;&#123;true&#125;&lt;/div&gt; 这种属性，在通过render呈现元素的时候，是十分有用的，比如我们只想在div元素中展现Head组件，例子如下： 1234&lt;div&gt; &#123;showHeader &amp;&amp; &lt;Header /&gt;&#125; &lt;Content /&gt;&lt;/div&gt; 这里的逻辑是，只有showHeader==true，在会在页面呈现Header组件，否则为null，即为不显示任何东西，这相当于一个if的判断了。 再举一个例子： 12345&lt;div&gt; &#123;props.messages.length &amp;&amp; &lt;MessageList messages=&#123;props.messages&#125; /&gt; &#125;&lt;/div&gt; 在这个div中，我们需要知道的是即使元素为0，0是能够呈现在页面中的。也就是说上述代码中，只要props.messages数组存在，不管长度是否为0都是存在的。（这里不同于js，js中的语法认为0==false） （3）如何显示Null，Undefined和Boolean 如果我们一定要再页面上显示Null等，可以将其先转化为字符串之后再显示。 123&lt;div&gt; My JavaScript variable is &#123;String(myVariable)&#125;.&lt;/div&gt; 通过String的转化后就能在页面上显示了。 参考地址http://blog.csdn.net/liwusen/article/details/53383922","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[]},{"title":"为什么文件名要小写？","slug":"name-the-file","date":"2017-05-12T01:26:21.000Z","updated":"2017-05-12T02:37:14.171Z","comments":true,"path":"2017/05/12/name-the-file/","link":"","permalink":"http://yoursite.com/2017/05/12/name-the-file/","excerpt":"","text":"为什么文件名要小写？ “文件名建议只使用小写字母，不使用大写字母。” “为了醒目，某些说明文件的文件名，可以使用大写字母，比如README、LICENSE。” 网友看见了，就提问为什么文件名要小写？ 说实话，虽然这是 Linux 传统，我却从没认真想过原因。赶紧查资料，结果发现四个很有说服力的理由，支持这样做。 下面就是这四个理由。另外，文后我还会发布一条前端培训的消息。 一、可移植性Linux 系统是大小写敏感的，而 Windows 系统和 Mac 系统正好相反，大小写不敏感。一般来说，这不是大问题。 但是，如果两个文件名只有大小写不同，其他都相同，跨平台就会出问题。 foobar Foobar FOOBAR fOObAr 上面四个文件名，Windows 系统会把它们都当作foobar。如果它们同时存在，你可能没办法打开后面三个文件。 另一方面，在 Mac 系统上开发时，有时会疏忽，写错大小写。 12// 正确文件名是 MyModule.jsconst module = require('./myModule'); 上面的代码在 Mac 上面可以运行，因为 Mac 认为MyModule.js和myModule.js是同一个文件。但是，一旦代码到服务器运行就会报错，因为 Linux 系统找不到myModule.js。 如果所有的文件名都采用小写，就不会出现上面的问题，可以保证项目有良好的可移植性。 二、易读性小写文件名通常比大写文件名更易读，比如accessibility.txt就比ACCESSIBILITY.TXT易读。 有人习惯使用驼峰命名法，单词的第一个字母大写，其他字母小写。这种方法的问题是，如果遇到全部是大写的缩略词，就会不适用。 比如，一个姓李的纽约特警，无论写成NYPoliceSWATLee还是NyPoliceSwatlee，都怪怪的，还是写成ny-police-swat-lee比较容易接受。 三、易用性某些系统会生成一些预置的用户目录，采用首字母大写的目录名。比如，Ubuntu 在用户主目录会默认生成Downloads、 Pictures、Documents等目录。 Mac 系统更过分，一部分系统目录也是大写的，比如/Library/Audio/Apple Loops/。 另外，某些常见的配置文件或说明文件，也采用大写的文件名，比如Makefile、INSTALL、CHANGELOG、.Xclients和.Xauthority等等。 所以，用户的文件都采用小写文件名，就很方便与上面这些目录或文件相区分。 如果你打破砂锅问到底，为什么操作系统会采用这样的大写文件名？原因也很简单，因为早期 Unix 系统上，ls命令先列出大写字母，再列出小写字母，大写的路径会排在前面。因此，如果目录名或文件名是大写的，就比较容易被用户首先看到。 img 四、便捷性文件名全部小写，还有利于命令行操作。比如，某些命令可以不使用-i参数了。 1234567# 大小写敏感的搜索$ find . -name abc$ locate \"*.htmL\"# 大小写不敏感的搜索$ find . -iname abc$ locate -i \"*.HtmL\" img 另外，大写字母需要按下 Shift 键，多多少少有些麻烦。如果文件名小写，就不用碰这个键了，不仅省事，还可以提高打字速度。 程序员长时间使用键盘，每分钟少按几次 Shift，一天下来就可以省掉很多手指动作。长年累月，也是对自己身体的一种保护。 综上所述，文件名全部使用小写字母和连词线（all-lowercase-with-dashes），是一种值得推广的正确做法。","categories":[],"tags":[{"name":"文件名","slug":"文件名","permalink":"http://yoursite.com/tags/文件名/"},{"name":"小写","slug":"小写","permalink":"http://yoursite.com/tags/小写/"}]},{"title":"CSS 变量","slug":"css-variable","date":"2017-05-12T01:25:09.000Z","updated":"2017-05-12T01:58:01.911Z","comments":true,"path":"2017/05/12/css-variable/","link":"","permalink":"http://yoursite.com/2017/05/12/css-variable/","excerpt":"","text":"CSS 变量今年三月，微软宣布 Edge 浏览器将支持 CSS 变量。 这个重要的 CSS 新功能，所有主要浏览器已经都支持了。本文全面介绍如何使用它，你会发现原生 CSS 从此变得异常强大。 img 一、变量的声明声明变量的时候，变量名前面要加两根连词线（--）。 12345&gt; body &#123;&gt; --foo: #7F583F;&gt; --bar: #F7EFD2;&gt; &#125;&gt; 上面代码中，body选择器里面声明了两个变量：--foo和--bar。 它们与color、font-size等正式属性没有什么不同，只是没有默认含义。所以 CSS 变量（CSS variable）又叫做“CSS 自定义属性”（CSS custom properties）。因为变量与自定义的 CSS 属性其实是一回事。 你可能会问，为什么选择两根连词线（--）表示变量？因为$foo被 Sass 用掉了，@foo被 Less 用掉了。为了不产生冲突，官方的 CSS 变量就改用两根连词线了。 各种值都可以放入 CSS 变量。 1234567891011121314&gt; :root&#123;&gt; --main-color: #4d4e53;&gt; --main-bg: rgb(255, 255, 255);&gt; --logo-border-color: rebeccapurple;&gt;&gt; --header-height: 68px;&gt; --content-padding: 10px 20px;&gt;&gt; --base-line-height: 1.428571429;&gt; --transition-duration: .35s;&gt; --external-link: &quot;external link&quot;;&gt; --margin-top: calc(2vh + 20px);&gt; &#125;&gt; 变量名大小写敏感，--header-color和--Header-Color是两个不同变量。 二、var() 函数var()函数用于读取变量。 12345&gt; a &#123;&gt; color: var(--foo);&gt; text-decoration-color: var(--bar);&gt; &#125;&gt; var()函数还可以使用第二个参数，表示变量的默认值。如果该变量不存在，就会使用这个默认值。 12&gt; color: var(--foo, #7F583F);&gt; 第二个参数不处理内部的逗号或空格，都视作参数的一部分。 123&gt; var(--font-stack, \"Roboto\", \"Helvetica\");&gt; var(--pad, 10px 15px 20px);&gt; var()函数还可以用在变量的声明。 12345&gt; :root &#123;&gt; --primary-color: red;&gt; --logo-text: var(--primary-color);&gt; &#125;&gt; 注意，变量值只能用作属性值，不能用作属性名。 123456&gt; .foo &#123;&gt; --side: margin-top;&gt; /* 无效 */&gt; var(--side): 20px;&gt; &#125;&gt; 上面代码中，变量--side用作属性名，这是无效的。 三、变量值的类型如果变量值是一个字符串，可以与其他字符串拼接。 123&gt; --bar: 'hello';&gt; --foo: var(--bar)' world';&gt; 利用这一点，可以 debug（例子）。 1234&gt; body:after &#123;&gt; content: '--screen-category : 'var(--screen-category);&gt; &#125;&gt; 如果变量值是数值，不能与数值单位直接连用。 123456&gt; .foo &#123;&gt; --gap: 20;&gt; /* 无效 */&gt; margin-top: var(--gap)px;&gt; &#125;&gt; 上面代码中，数值与单位直接写在一起，这是无效的。必须使用calc()函数，将它们连接。 12345&gt; .foo &#123;&gt; --gap: 20;&gt; margin-top: calc(var(--gap) * 1px);&gt; &#125;&gt; 如果变量值带有单位，就不能写成字符串。 123456789101112&gt; /* 无效 */&gt; .foo &#123;&gt; --foo: '20px';&gt; font-size: var(--foo);&gt; &#125;&gt;&gt; /* 有效 */&gt; .foo &#123;&gt; --foo: 20px;&gt; font-size: var(--foo);&gt; &#125;&gt; 四、作用域同一个 CSS 变量，可以在多个选择器内声明。读取的时候，优先级最高的声明生效。这与 CSS 的”层叠”（cascade）规则是一致的。 下面是一个例子。 1234567891011&gt; &lt;style&gt;&gt; :root &#123; --color: blue; &#125;&gt; div &#123; --color: green; &#125;&gt; #alert &#123; --color: red; &#125;&gt; * &#123; color: var(--color); &#125;&gt; &lt;/style&gt;&gt;&gt; &lt;p&gt;蓝色&lt;/p&gt;&gt; &lt;div&gt;绿色&lt;/div&gt;&gt; &lt;div id=\"alert\"&gt;红色&lt;/div&gt;&gt; 上面代码中，三个选择器都声明了--color变量。不同元素读取这个变量的时候，会采用优先级最高的规则，因此三段文字的颜色是不一样的。 这就是说，变量的作用域就是它所在的选择器的有效范围。 12345678&gt; body &#123;&gt; --foo: #7F583F;&gt; &#125;&gt;&gt; .content &#123;&gt; --bar: #F7EFD2;&gt; &#125;&gt; 上面代码中，变量--foo的作用域是body选择器的生效范围，--bar的作用域是.content选择器的生效范围。 由于这个原因，全局的变量通常放在根元素:root里面，确保任何选择器都可以读取它们。 1234&gt; :root &#123;&gt; --main-color: #06c;&gt; &#125;&gt; 五、响应式布局CSS 是动态的，页面的任何变化，都会导致采用的规则变化。 利用这个特点，可以在响应式布局的media命令里面声明变量，使得不同的屏幕宽度有不同的变量值。 1234567891011121314151617&gt; body &#123;&gt; --primary: #7F583F;&gt; --secondary: #F7EFD2;&gt; &#125;&gt;&gt; a &#123;&gt; color: var(--primary);&gt; text-decoration-color: var(--secondary);&gt; &#125;&gt;&gt; @media screen and (min-width: 768px) &#123;&gt; body &#123;&gt; --primary: #F7EFD2;&gt; --secondary: #7F583F;&gt; &#125;&gt; &#125;&gt; 六、兼容性处理对于不支持 CSS 变量的浏览器，可以采用下面的写法。 12345&gt; a &#123;&gt; color: #7F583F;&gt; color: var(--primary);&gt; &#125;&gt; 也可以使用@support命令进行检测。 12345678&gt; @supports ( (--a: 0)) &#123;&gt; /* supported */&gt; &#125;&gt;&gt; @supports ( not (--a: 0)) &#123;&gt; /* not supported */&gt; &#125;&gt; 七、JavaScript 操作JavaScript 也可以检测浏览器是否支持 CSS 变量。 1234567891011&gt; const isSupported =&gt; window.CSS &amp;&amp;&gt; window.CSS.supports &amp;&amp;&gt; window.CSS.supports('--a', 0);&gt;&gt; if (isSupported) &#123;&gt; /* supported */&gt; &#125; else &#123;&gt; /* not supported */&gt; &#125;&gt; JavaScript 操作 CSS 变量的写法如下。 12345678910&gt; // 设置变量&gt; document.body.style.setProperty('--primary', '#7F583F');&gt;&gt; // 读取变量&gt; document.body.style.getPropertyValue('--primary').trim();&gt; // '#7F583F'&gt;&gt; // 删除变量&gt; document.body.style.removeProperty('--primary');&gt; 这意味着，JavaScript 可以将任意值存入样式表。下面是一个监听事件的例子，事件信息被存入 CSS 变量。 1234567&gt; const docStyle = document.documentElement.style;&gt;&gt; document.addEventListener('mousemove', (e) =&gt; &#123;&gt; docStyle.setProperty('--mouse-x', e.clientX);&gt; docStyle.setProperty('--mouse-y', e.clientY);&gt; &#125;);&gt; 那些对 CSS 无用的信息，也可以放入 CSS 变量。 12&gt; --foo: if(x &gt; 5) this.width = 10;&gt; 上面代码中，--foo的值在 CSS 里面是无效语句，但是可以被 JavaScript 读取。这意味着，可以把样式设置写在 CSS 变量中，让 JavaScript 读取。 所以，CSS 变量提供了 JavaScript 与 CSS 通信的一种途径。 八、参考链接 Winning with CSS Variables CSS Variables: Why Should You Care? It’s Time To Start Using CSS Custom Properties Why I’m Excited About Native CSS Variables CSS变量教程","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"变量","slug":"变量","permalink":"http://yoursite.com/tags/变量/"}]},{"title":"linux vi 命令详解","slug":"linux-vi","date":"2017-05-11T02:33:03.000Z","updated":"2017-05-11T09:02:10.978Z","comments":true,"path":"2017/05/11/linux-vi/","link":"","permalink":"http://yoursite.com/2017/05/11/linux-vi/","excerpt":"","text":"vi编辑器是所有Unix及Linux系统下标准的编辑器，它的强大不逊色于任何最新的文本编辑器，这里只是简单地介绍一下它的用法和一小部分指 令。由于 对Unix及Linux系统的任何版本，vi编辑器是完全相同的，因此您可以在其他任何介绍vi的地方进一步了解它。vi也是Linux中最基本的文本编 辑器，学会它后，您将在Linux的世界里畅行无阻。 vi的基本概念基本上vi可以分为三种状态，分别是: 命令模式（command mode） 插入模式（Insert mode） 底行模式（last line mode） 各模式的功能区别如下： 命令行模式command mode） 控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入插入模式下，或者到底行模式。 插入模式（Insert mode） 只有在插入模式下，才可以做文字输入，按ESC键可回到命令行模式。 底行模式（last line mode） 将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。 不过一般我们在使用时把vi简化成两个模式，就是将底行模式也算入命令行模式。 vi的基本操作进入vi 在系统提示符号输入vi及文件名称后，就进入vi全屏幕编辑画面： 1$ vi myfile 不过有一点要特别注意，就是您进入vi之后，是处于「命令行模式」，您要切换到「插入模式」才能够输入文字。初次使用vi的人都会想先用上下左右键移动光标，结果电脑一直哔哔叫，把自己气个半死，所以进入vi后，先不要乱动，转换到 「插入模式」再说吧！ 切换至插入模式 编辑文件 在「命令行模式」下按一下字母 i 就可以进入「插入模式」，这时候你就可以开始输入文字了。 切换至命令行模式 您目前处于「插入模式」，您就只能一直输入文字。回到「命令行模式」，按一下 ESC 键就行啦。 切换至底行模式 退出vi及保存文件 在「命令行模式」下，按一下 : 冒号键进入「底行模式」，输入下面的命令： 123456# 将文章以指定的文件名filename保存: w filename # 存盘并退出vi: wq # 不存盘强制退出vi: q! 命令行模式（command mode）功能键插入模式 按i 进入插入模式后，是从光标当前位置开始输入文件； 按a进入插入模式后，是从目前光标所在位置的下一个位置开始输入文字； 按o进入插入模式后，是插入新的一行，从行首开始输入文字。 从插入模式切换为命令行模式 按ESC键 移动光标 vi可以直接用键盘上的光标来上下左右移动，但正规的vi是用小写英文字母h(左)、j(下)、k(上)、l(右)，分别控制光标左、下、上、右移一格。 key command Ctrl+B 屏幕往”后”移动一页 Ctrl+F 屏幕往”前”移动一页 Ctrl+U 屏幕往”后”移动半页 Ctrl+D 屏幕往”前”移动半页 0 移到文章的开头 g 移动到文章的最后 $ 移动到光标所在行的”行尾” ^ 移动到光标所在行的”行首” w 光标跳到下个字的开头 e 光标跳到下个字的字尾 b 光标回到上个字的开头 #l 光标移到该行的第#个位置，如：5l，56l 删除文字 key command x 每按一次，删除光标所在位置的”后面”一个字符 #x 例如，6x表示删除光标所在位置的”后面” 6 个字符 X 大写的 X ，每按一次，删除光标所在位置的”前面”一个字符 #X 例如，20X表示删除光标所在位置的”前面” 20 个字符 dd 删除光标所在行 #dd 从光标所在行开始删除#行 复制 key command yw 将光标所在之处到字尾的字符复制到缓冲区中 #yw 复制#个字到缓冲区 yy 复制光标所在行到缓冲区 #yy 例如，6yy表示拷贝从光标所在的该行”往下数”6行文字 p 将缓冲区内的字符贴到光标所在位置。注意：所有与”y”有关的复制命令都必须与”p”配合才能完成复制与粘贴功能 替换 key command r 替换光标所在处的字符 R 替换光标所到之处的字符，直到按下ESC键为止 回复上一次操作 key command u 如果您误执行一个命令，可以马上按下u，回到上一个操作。按多次”u”可以执行多次回复 更改 key command cw 更改光标所在处的字到字尾处 c#w 例如，c3w表示更改3个字 跳至指定的行 key command Ctrl+G 列出光标所在行的行号 #G 例如，15G，表示移动光标至文章的第15行行首 底行模式（last line mode）下命令简介在使用「底行模式」之前，请记住先按ESC键确定您已经处于「命令行模式」下后，再按:冒号即可进入「底行模式」。 列出行号 key command set nu 输入「set nu」后，会在文件中的每一行前面列出行号。 跳到文件中的某一行 key command # 「#」号表示一个数字，在冒号后输入一个数字，再按回车键就会跳到该行了，如输入数字15，再回车，就会跳到文章的第15行。 查找字符 key command /关键字 先按「/」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往后寻找到您要的关键字为止。 ?关键字 先按「?」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往前寻找到您要的关键字为止。 保存文件 key command w 在冒号输入字母「w」就可以将文件保存起来。 离开vi key command q 按「q」就是退出，如果无法离开vi，可以在「q」后跟一个「!」强制离开vi。 qw 一般建议离开时，搭配「w」一起使用，这样在退出的时候还可以保存文件。 参考地址http://www.cnblogs.com/mahang/archive/2011/09/01/2161672.html","categories":[],"tags":[]},{"title":"常用 Git 命令清单","slug":"git-commend","date":"2017-05-10T09:27:06.000Z","updated":"2017-05-11T09:42:15.755Z","comments":true,"path":"2017/05/10/git-commend/","link":"","permalink":"http://yoursite.com/2017/05/10/git-commend/","excerpt":"","text":"img 几个专用名词的译名如下： Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 新建代码库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name \"[name]\"$ git config [--global] user.email \"[email address]\" 增加/删除文件123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed]# 停止追踪指定文件(删除的文件追踪不了)，但该文件会保留在工作区$ git rm --cached [file] 代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 查看信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat \"@&#123;0 day ago&#125;\"# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 其他12# 生成一个可供发布的压缩包$ git archive 参考地址http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html","categories":[],"tags":[]},{"title":"使用svn客户端功能","slug":"svn-commend","date":"2017-05-05T06:23:58.000Z","updated":"2017-05-05T07:17:27.716Z","comments":true,"path":"2017/05/05/svn-commend/","link":"","permalink":"http://yoursite.com/2017/05/05/svn-commend/","excerpt":"","text":"使用svn客户端功能1.从本地导入代码到服务器(第一次初始化导入) 1$ svn import /Users/apple/Documents/eclipse_workspace/weibo svn://localhost/mycode/weibo --username=mj --password=123 -m &quot;初始化导入&quot; 我解释下指令的意思：将/Users/apple/Documents/eclipse_workspace/weibo中的所有内容，上传到服务器mycode仓库的weibo目录下，后面双引号中的”初始化导入”是注释 2.从服务器端下载代码到客户端本地 1svn checkout svn://localhost/mycode --username=mj --password=123 /Users/apple/Documents/code 我解释下指令的意思：将服务器中mycode仓库的内容下载到/Users/apple/Documents/code目录中 3.提交更改过的代码到服务器 在步骤2中已经将服务器端的代码都下载到/Users/apple/Documents/code目录中，现在修改下里面的一些代码，然后提交这些修改到服务器 12345//&lt;1&gt; 打开终端，先定位到/Users/apple/Documents/code目录$ cd/Users/apple/Documents/code//&lt;2&gt; 输入提交指令：$ svn commit -m &quot;修改了main.m文件&quot; 这个指令会将/Users/apple/Documents/code下的所有修改都同步到服务器端，假如这次我只修改了main.m文件 4.更新服务器端的代码到客户端 这个应该是最简单的指令了，在终端中定位到客户端代码目录后，比如上面的/Users/apple/Documents/code目录 1$ svn update 5.至于svn的其他用法 1$ svn help img 这里列出一大堆svn指令，后面括号中的内容的一般代表着指令的简称，比如我们可以用svn ci代替svn commit，用svn co代替svn checkout。","categories":[],"tags":[]},{"title":"SSH key (win)","slug":"sshkey","date":"2017-05-05T06:21:40.000Z","updated":"2017-05-05T07:17:47.079Z","comments":true,"path":"2017/05/05/sshkey/","link":"","permalink":"http://yoursite.com/2017/05/05/sshkey/","excerpt":"","text":"window系统1234567891011121314//运行git Bash客户端$ cd ~/.ssh//查看目录文件$ ls//创建一个SSH key$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot;//拷贝 id_rsa.pub 文件的内容，你可以用编辑器打开文件复制，也可以用git命令复制该文件的内容$ clip &lt; ~/.ssh/id_rsa.pub//测试一下该SSH key$ ssh -T git@github.com","categories":[],"tags":[]},{"title":"Visual Studio Code 常用快捷键(WIN)","slug":"vscode-keymap","date":"2017-05-05T01:59:54.000Z","updated":"2017-05-23T09:41:13.217Z","comments":true,"path":"2017/05/05/vscode-keymap/","link":"","permalink":"http://yoursite.com/2017/05/05/vscode-keymap/","excerpt":"","text":"主命令框F1或 Ctrl+Shift+P: 打开命令面板。在打开的输入框内，可以输入任何命令，例如： 按一下 Backspace会进入到Ctrl+P 模式 在Ctrl+P下输入 &gt;可以进入Ctrl+Shift+P模式 在 Ctrl+P 窗口下还可以: 直接输入文件名，跳转到文件 ?列出当前可执行的动作 ! 显示 Errors或 Warnings，也可以 Ctrl+Shift+M :跳转到行数，也可以 Ctrl+G直接进入 @跳转到 symbol（搜索变量或者函数），也可以 Ctrl+Shift+O直接进入 @根据分类跳转 symbol，查找属性或函数，也可以 Ctrl+Shift+O 后输入:进入 #根据名字查找 symbol，也可以 Ctrl+T 快捷键Basic Editing Key Command Command id Ctrl+X Cut line (empty selection) 剪切 Ctrl+C Copy line (empty selection) 复制 Ctrl+Shift+K Delete Line 删除当前行 Ctrl+Enter Insert Line Below 向下插入空行 Ctrl+Shift+Enter Insert Line Above 向上插入空行 Alt+Down Move Line Down 向下移动当前行 Alt+Up Move Line Up 向上移动当前行 Shift+Alt+Down Copy Line Down 向下插入当前行内容 Shift+Alt+Up Copy Line Up 向上插入当前行内容 Ctrl+D Add Selection To Next Find Match editor.action.addSelectionToNextFindMatch Ctrl+K Ctrl+D Move Last Selection To Next Find Match editor.action.moveSelectionToNextFindMatch Ctrl+U Undo last cursor operation 回退光标操作位置 Shift+Alt+I Insert cursor at end of each line selected editor.action.insertCursorAtEndOfEachLineSelected Ctrl+Shift+L Select all occurrences of current selection editor.action.selectHighlights Ctrl+F2 Select all occurrences of current word editor.action.changeAll Ctrl+I Select current line 选中当前行内容 Ctrl+Alt+Down Insert Cursor Below editor.action.insertCursorBelow Ctrl+Alt+Up Insert Cursor Above editor.action.insertCursorAbove Ctrl+Shift+\\ Jump to matching bracket editor.action.jumpToBracket Ctrl+] Indent Line 增加当前行缩进 Ctrl+[ Outdent Line 减少当前行缩进 Home Go to Beginning of Line 光标定位到行首 End Go to End of Line 光标定位到行尾 Ctrl+End Go to End of File 光标定位到文件的尾部 Ctrl+Home Go to Beginning of File 光标定位到文件的开头 Ctrl+Down Scroll Line Down 滚动条向下移动 Ctrl+Up Scroll Line Up 滚动条向上移动 Alt+PageDown Scroll Page Down 滚动条向下移动一屏 Alt+PageUp Scroll Page Up 滚动条向上移动一屏 Ctrl+Shift+[ Fold (collapse) region 折叠代码 Ctrl+Shift+] Unfold (uncollapse) region 展开代码 Ctrl+K Ctrl+[ Fold (collapse) all subregions editor.foldRecursively Ctrl+K Ctrl+] Unfold (uncollapse) all subregions editor.unfoldRecursively Ctrl+K Ctrl+0 Fold (collapse) all regions editor.foldAll Ctrl+K Ctrl+J Unfold (uncollapse) all regions editor.unfoldAll Ctrl+K Ctrl+C Add Line Comment editor.action.addCommentLine Ctrl+K Ctrl+U Remove Line Comment editor.action.removeCommentLine Ctrl+/ Toggle Line Comment 注释(或取消注释)当前行代码,//注释内容 Shift+Alt+A Toggle Block Comment 注释(或取消注释)选择代码,/*注释内容*/ Ctrl+F Find 查找 Ctrl+H Replace 替换 F3 Command Command id Shift+F3 Cut line (empty selection) 剪切 Ctrl+C Copy line (empty selection) 复制 Ctrl+Shift+K Delete Line 删除当前行 Ctrl+Enter Insert Line Below 向下插入空行 Ctrl+Shift+Enter Insert Line Above 向上插入空行 Alt+Down Move Line Down 向下移动当前行 Alt+Up Move Line Up 向上移动当前行 Shift+Alt+Down Copy Line Down 向下插入当前行内容 Rich Languages Editing Key Command Command id Ctrl+Space Trigger Suggest editor.action.triggerSuggest Ctrl+Shift+Space Trigger Parameter Hints editor.action.triggerParameterHints Shift+Alt+F Format Document editor.action.formatDocument Ctrl+K Ctrl+F Format Selection editor.action.formatSelection F12 Go to Definition editor.action.goToDeclaration Ctrl+K Ctrl+I Show Hover editor.action.showHover Alt+F12 Peek Definition editor.action.previewDeclaration Ctrl+K F12 Open Definition to the Side editor.action.openDeclarationToTheSide Ctrl+. Quick Fix editor.action.quickFix Shift+F12 Show References editor.action.referenceSearch.trigger F2 Rename Symbol editor.action.rename Ctrl+Shift+. Replace with Next Value editor.action.inPlaceReplace.down Ctrl+Shift+, Replace with Previous Value editor.action.inPlaceReplace.up Shift+Alt+Right Expand AST Select editor.action.smartSelect.grow Shift+Alt+Left Shrink AST Select editor.action.smartSelect.shrink Ctrl+K Ctrl+X Trim Trailing Whitespace editor.action.trimTrailingWhitespace Ctrl+K M Change Language Mode workbench.action.editor.changeLanguageMode Navigation Key Command Command id Ctrl+T Show All Symbols workbench.action.showAllSymbols Ctrl+G Go to Line… workbench.action.gotoLine Ctrl+P Go to File…, Quick Open workbench.action.quickOpen Ctrl+Shift+O Go to Symbol… workbench.action.gotoSymbol Ctrl+Shift+M Show Problems workbench.actions.view.problems F8 Go to Next Error or Warning editor.action.marker.next Shift+F8 Go to Previous Error or Warning editor.action.marker.prev Ctrl+Shift+P Show All Commands workbench.action.showCommands Ctrl+Shift+Tab Navigate Editor Group History workbench.action.openPreviousRecentlyUsedEditorInGroup Alt+Left Go Back workbench.action.navigateBack Alt+Right Go Forward workbench.action.navigateForward Editor/Window Management Key Command Command id Ctrl+Shift+N New Window workbench.action.newWindow Ctrl+W Close Window workbench.action.closeWindow Ctrl+F4 Close Editor workbench.action.closeActiveEditor Ctrl+K F Close Folder workbench.action.closeFolder unassigned Cycle Between Editor Groups workbench.action.navigateEditorGroups Ctrl+\\ Split Editor workbench.action.splitEditor Ctrl+1 Focus into First Editor Group workbench.action.focusFirstEditorGroup Ctrl+2 Focus into Second Editor Group workbench.action.focusSecondEditorGroup Ctrl+3 Focus into Third Editor Group workbench.action.focusThirdEditorGroup Ctrl+K Ctrl+Left Focus into Editor Group on the Left workbench.action.focusPreviousGroup Ctrl+K Ctrl+Right Focus into Editor Group on the Right workbench.action.focusNextGroup Ctrl+Shift+PageUp Move Editor Left workbench.action.moveEditorLeftInGroup Ctrl+Shift+PageDown Move Editor Right workbench.action.moveEditorRightInGroup Ctrl+K Left Move Active Editor Group Left workbench.action.moveActiveEditorGroupLeft Ctrl+K Right Move Active Editor Group Right workbench.action.moveActiveEditorGroupRight File Management Key Command Command id Ctrl+N New File workbench.action.files.newUntitledFile Ctrl+O Open File… workbench.action.files.openFile Ctrl+S Save workbench.action.files.save Ctrl+K S Save All workbench.action.files.saveAll Ctrl+Shift+S Save As… workbench.action.files.saveAs Ctrl+F4 Close workbench.action.closeActiveEditor unassigned Close Others workbench.action.closeOtherEditors Ctrl+K W Close Group workbench.action.closeEditorsInGroup unassigned Close Other Groups workbench.action.closeEditorsInOtherGroups unassigned Close Group to Left workbench.action.closeEditorsToTheLeft unassigned Close Group to Right workbench.action.closeEditorsToTheRight Ctrl+K Ctrl+W Close All workbench.action.closeAllEditors Ctrl+Shift+T Reopen Closed Editor workbench.action.reopenClosedEditor Ctrl+K Enter Keep Open workbench.action.keepEditor Ctrl+Tab Open Next workbench.action.openNextRecentlyUsedEditorInGroup Ctrl+Shift+Tab Open Previous workbench.action.openPreviousRecentlyUsedEditorInGroup Ctrl+K P Copy Path of Active File workbench.action.files.copyPathOfActiveFile Ctrl+K R Reveal Active File in Windows workbench.action.files.revealActiveFileInWindows Ctrl+K O Show Opened File in New Window workbench.action.files.showOpenedFileInNewWindow unassigned Compare Opened File With workbench.files.action.compareFileWith Display Key Command Command id F11 Toggle Full Screen workbench.action.toggleFullScreen Ctrl+K Z Toggle Zen Mode workbench.action.toggleZenMode Escape Escape Leave Zen Mode workbench.action.exitZenMode Ctrl+= Zoom in workbench.action.zoomIn Ctrl+- Zoom out workbench.action.zoomOut Ctrl+Numpad0 Reset Zoom workbench.action.zoomReset Ctrl+B Toggle Sidebar Visibility workbench.action.toggleSidebarVisibility Ctrl+Shift+E Show Explorer / Toggle Focus workbench.view.explorer Ctrl+Shift+D Show Debug workbench.view.debug Ctrl+Shift+G Show Source Control workbench.view.scm Ctrl+Shift+X Show Extensions workbench.view.extensions Ctrl+Shift+U Show Output workbench.action.output.toggleOutput Ctrl+Q Quick Open View workbench.action.quickOpenView Ctrl+Shift+F Show Search workbench.view.search Ctrl+Shift+H Replace in Files workbench.action.replaceInFiles Ctrl+Shift+J Toggle Search Details workbench.action.search.toggleQueryDetails Ctrl+Shift+C Open New Command Prompt workbench.action.terminal.openNativeConsole Ctrl+Shift+V Toggle Markdown Preview markdown.showPreview Ctrl+K V Open Preview to the Side markdown.showPreviewToSide Ctrl+` Toggle Integrated Terminal workbench.action.terminal.toggleTerminal Preferences Key Command Command id Ctrl+, Open User Settings workbench.action.openGlobalSettings unassigned Open Workspace Settings workbench.action.openWorkspaceSettings Ctrl+K Ctrl+S Open Keyboard Shortcuts workbench.action.openGlobalKeybindings unassigned Open User Snippets workbench.action.openSnippets Ctrl+K Ctrl+T Select Color Theme workbench.action.selectTheme unassigned Configure Display Language workbench.action.configureLocale Debug Key Command Command id F9 Toggle Breakpoint editor.debug.action.toggleBreakpoint F5 Start workbench.action.debug.start F5 Continue workbench.action.debug.continue Ctrl+F5 Start (without debugging) workbench.action.debug.run F6 Pause workbench.action.debug.pause F11 Step Into workbench.action.debug.stepInto Shift+F11 Step Out workbench.action.debug.stepOut F10 Step Over workbench.action.debug.stepOver Shift+F5 Stop workbench.action.debug.stop Ctrl+K Ctrl+I Show Hover editor.debug.action.showDebugHover Tasks Key Command Command id Ctrl+Shift+B Run Build Task workbench.action.tasks.build unassigned Run Test Task workbench.action.tasks.test Extensions Key Command Command id unassigned Install Extension workbench.extensions.action.installExtension unassigned Show Installed Extensions workbench.extensions.action.showInstalledExtensions unassigned Show Outdated Extensions workbench.extensions.action.listOutdatedExtensions unassigned Show Recommended Extensions workbench.extensions.action.showRecommendedExtensions unassigned Show Popular Extensions workbench.extensions.action.showPopularExtensions unassigned Update All Extensions workbench.extensions.action.updateAllExtensions 修改默认快捷键打开默认键盘快捷方式设置：File -&gt; Preferences -&gt; Keyboard Shortcuts 修改keybindings.json： 12345678910111213141516171819202122232425262728293031323334353637[ // ctrl+space 被切换输入法快捷键占用 &#123; \"key\": \"ctrl+alt+space\", \"command\": \"editor.action.triggerSuggest\", \"when\": \"editorTextFocus\" &#125;, // ctrl+d 删除一行 &#123; \"key\": \"ctrl+d\", \"command\": \"editor.action.deleteLines\", \"when\": \"editorTextFocus\" &#125;, // 与删除一行的快捷键互换 &#123; \"key\": \"ctrl+shift+k\", \"command\": \"editor.action.addSelectionToNextFindMatch\", \"when\": \"editorFocus\" &#125;, // ctrl+shift+/多行注释 &#123; \"key\":\"ctrl+shift+/\", \"command\": \"editor.action.blockComment\", \"when\": \"editorTextFocus\" &#125;, // 定制与 sublime 相同的大小写转换快捷键，需安装 TextTransform 插件 &#123; \"key\": \"ctrl+k ctrl+u\", \"command\": \"uppercase\", \"when\": \"editorTextFocus\" &#125;, &#123; \"key\": \"ctrl+k ctrl+l\", \"command\": \"lowercase\", \"when\": \"editorTextFocus\" &#125;] 前端开发必备插件 PostCSS Sorting stylelint stylefmt ESLint javascript standard format beautify Babel ES6/ES7 Debugger for Chrome Add jsdoc comments javascript(ES6) code snippets vue weex Reactjs code snippets React Native Tools Npm Intellisense Instant Markdown Markdown Shortcuts TextTransform 相关参考官方快捷键","categories":[],"tags":[{"name":"keymap","slug":"keymap","permalink":"http://yoursite.com/tags/keymap/"}]}]}